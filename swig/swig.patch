From d98cd9cc70c3dfa3289a51662a268fd475907fa4 Mon Sep 17 00:00:00 2001
From: Anthony Liot <wolfivking0@yahoo.com>
Date: Mon, 1 Mar 2021 10:13:57 -0800
Subject: [PATCH] patch

Signed-off-by: Anthony Liot <wolfivking0@yahoo.com>
---
 CMakeLists.txt                 |   230 +
 Source/CParse/parser.c         | 12779 +++++++++++++++++++++++++++++++
 Source/CParse/parser.h         |   388 +
 Tools/cmake/swigconfig.h.cmake |    92 +
 4 files changed, 13489 insertions(+)
 create mode 100644 CMakeLists.txt
 create mode 100644 Source/CParse/parser.c
 create mode 100644 Source/CParse/parser.h
 create mode 100644 Tools/cmake/swigconfig.h.cmake

diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
index 000000000..6d471ce8f
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,230 @@
+project(swig)
+
+cmake_minimum_required(VERSION 2.8)
+
+if ( NOT DEFINED CMAKE_BUILD_TYPE )
+  set( CMAKE_BUILD_TYPE RelWithDebInfo CACHE STRING "Build type" )
+endif ()
+
+project(swig)
+
+set(SWIG_VERSION 4.0.0)
+
+set(SWIG_ROOT ${PROJECT_SOURCE_DIR})
+
+set( SWIG_LIB ${CMAKE_INSTALL_PREFIX}/share/swig )
+
+# Project wide configuration variables
+# ------------------------------------
+
+set(SWIG_SOURCE_DIR "${SWIG_ROOT}/Source" CACHE INTERNAL "Path of swig sources" FORCE)
+
+set ( PACKAGE_NAME swig )
+set ( PACKAGE_VERSION ${SWIG_VERSION} )
+
+add_definitions(-DPACKAGE_VERSION=${PACKAGE_VERSION})
+
+# Options
+# -------
+
+# TODO...
+
+
+# Configure
+# ---------
+
+LIST(APPEND CMAKE_MODULE_PATH ${SWIG_ROOT}/Tools/cmake)
+
+include(CheckIncludeFiles)
+include(CheckIncludeFile)
+include(CheckTypeSize)
+include(CheckSymbolExists)
+include(CheckLibraryExists)
+include(CheckCSourceCompiles)
+
+# HACK: didn't get the bool check working for Visual Studio 2008
+if(MSVC)
+set(HAVE_BOOL 1)
+else()
+set(CMAKE_EXTRA_INCLUDE_FILES stdbool.h)
+check_type_size("bool" HAVE_BOOL)
+set(CMAKE_EXTRA_INCLUDE_FILES)
+endif()
+
+check_include_file("inttypes.h" HAVE_INTTYPES_H)
+check_include_file("memory.h" HAVE_MEMORY_H)
+check_include_file("stddef.h" HAVE_STDDEF_H)
+check_include_file("stdint.h" HAVE_STDINT_H)
+check_include_file("stdlib.h" HAVE_STDLIB_H)
+check_include_file("string.h" HAVE_STRING_H)
+check_include_file("strings.h" HAVE_STRINGS_H)
+check_include_file("sys/stat.h" HAVE_SYS_STAT_H)
+check_include_file("sys/types.h" HAVE_SYS_TYPES_H)
+check_include_file("unistd.h" HAVE_UNISTD_H)
+check_include_files( "stdlib.h;stdarg.h;string.h;float.h" HAVE_STDC_HEADERS )
+
+check_library_exists(dl dlopen "" HAVE_LIBDL)
+
+set(HAVE_PCRE 0)
+
+if ( ZLIB_FOUND )
+  set ( ENABLE_ZLIB 1 )
+  include_directories ( ${ZLIB_INCLUDE_DIRS} )
+else ()
+  set ( ENABLE_ZLIB 0 )
+endif ()
+
+# for ccache man
+find_program ( YODL2MAN_EXECUTABLE NAMES yodl2man )
+
+configure_file(
+    ${SWIG_ROOT}/Tools/cmake/swigconfig.h.cmake
+    ${CMAKE_CURRENT_BINARY_DIR}/Source/Include/swigconfig.h
+)
+
+#find_package(BISON REQUIRED)
+
+
+# Compiler flags
+# --------------
+
+include_directories(
+    "${SWIG_SOURCE_DIR}/Doxygen"
+    "${SWIG_SOURCE_DIR}/CParse"
+    "${SWIG_SOURCE_DIR}/Include"
+    "${SWIG_SOURCE_DIR}/DOH"
+    "${SWIG_SOURCE_DIR}/Swig"
+    "${SWIG_SOURCE_DIR}/Preprocessor"
+    "${SWIG_SOURCE_DIR}/Modules"
+    "${PROJECT_BINARY_DIR}/Source/Include"
+)
+
+# generate the parser source code (depends on bison)
+file(MAKE_DIRECTORY ${PROJECT_BINARY_DIR}/Source/CParse)
+
+#BISON_TARGET(swig_parser
+#    ${SWIG_SOURCE_DIR}/CParse/parser.y
+#    ${PROJECT_BINARY_DIR}/Source/CParse/parser.c
+#)
+
+# generate swigwarn.swg
+file(READ ${SWIG_SOURCE_DIR}/Include/swigwarn.h SWIG_WARN_H)
+string(REGEX REPLACE "#define WARN([^ \\t]*)[ \\t]*([0-9]+)" "%define SWIGWARN\\1 \\2 %enddef" SWIG_WARN_SWG ${SWIG_WARN_H})
+file(WRITE ${CMAKE_CURRENT_BINARY_DIR}/swigwarn.swg ${SWIG_WARN_SWG})
+set_property(SOURCE ${CMAKE_CURRENT_BINARY_DIR}/swigwarn.swg PROPERTY GENERATED 1)
+
+# install lib
+install ( DIRECTORY ${SWIG_ROOT}/Lib DESTINATION ${SWIG_LIB} )
+install ( FILES ${CMAKE_CURRENT_BINARY_DIR}/swigwarn.swg DESTINATION ${SWIG_LIB}/Lib )
+
+# Libraries
+# ---------
+
+add_library(cparse
+    "${SWIG_SOURCE_DIR}/CParse/cscanner.c"
+    "${SWIG_SOURCE_DIR}/CParse/templ.c"
+    "${SWIG_SOURCE_DIR}/CParse/util.c"
+    "${SWIG_SOURCE_DIR}/CParse/parser.c"
+    "${SWIG_SOURCE_DIR}/CParse/parser.h"
+)
+
+add_library(doxygen
+    "${SWIG_SOURCE_DIR}/Doxygen/doxycommands.h"
+    "${SWIG_SOURCE_DIR}/Doxygen/doxyentity.h"
+    "${SWIG_SOURCE_DIR}/Doxygen/doxyparser.h"
+    "${SWIG_SOURCE_DIR}/Doxygen/doxytranslator.h"
+    "${SWIG_SOURCE_DIR}/Doxygen/javadoc.h"
+    "${SWIG_SOURCE_DIR}/Doxygen/pydoc.h"
+    "${SWIG_SOURCE_DIR}/Doxygen/doxyentity.cxx"
+    "${SWIG_SOURCE_DIR}/Doxygen/doxyparser.cxx"
+    "${SWIG_SOURCE_DIR}/Doxygen/doxytranslator.cxx"
+    "${SWIG_SOURCE_DIR}/Doxygen/javadoc.cxx"
+    "${SWIG_SOURCE_DIR}/Doxygen/pydoc.cxx"
+)
+
+add_library(preprocessor
+    "${SWIG_SOURCE_DIR}/Preprocessor/cpp.c"
+    "${SWIG_SOURCE_DIR}/Preprocessor/expr.c"
+)
+
+add_library(doh
+    "${SWIG_SOURCE_DIR}/DOH/base.c"
+    "${SWIG_SOURCE_DIR}/DOH/file.c"
+    "${SWIG_SOURCE_DIR}/DOH/fio.c"
+    "${SWIG_SOURCE_DIR}/DOH/hash.c"
+    "${SWIG_SOURCE_DIR}/DOH/list.c"
+    "${SWIG_SOURCE_DIR}/DOH/memory.c"
+    "${SWIG_SOURCE_DIR}/DOH/string.c"
+    "${SWIG_SOURCE_DIR}/DOH/void.c"
+)
+
+add_library(core
+    "${SWIG_SOURCE_DIR}/Swig/cwrap.c"
+    "${SWIG_SOURCE_DIR}/Swig/deprecate.c"
+    "${SWIG_SOURCE_DIR}/Swig/error.c"
+    "${SWIG_SOURCE_DIR}/Swig/extend.c"
+    "${SWIG_SOURCE_DIR}/Swig/fragment.c"
+    "${SWIG_SOURCE_DIR}/Swig/getopt.c"
+    "${SWIG_SOURCE_DIR}/Swig/include.c"
+    "${SWIG_SOURCE_DIR}/Swig/misc.c"
+    "${SWIG_SOURCE_DIR}/Swig/naming.c"
+    "${SWIG_SOURCE_DIR}/Swig/parms.c"
+    "${SWIG_SOURCE_DIR}/Swig/scanner.c"
+    "${SWIG_SOURCE_DIR}/Swig/stype.c"
+    "${SWIG_SOURCE_DIR}/Swig/symbol.c"
+    "${SWIG_SOURCE_DIR}/Swig/tree.c"
+    "${SWIG_SOURCE_DIR}/Swig/typemap.c"
+    "${SWIG_SOURCE_DIR}/Swig/typeobj.c"
+    "${SWIG_SOURCE_DIR}/Swig/typesys.c"
+    "${SWIG_SOURCE_DIR}/Swig/wrapfunc.c"
+)
+
+add_library(modules
+    "${SWIG_SOURCE_DIR}/Modules/allegrocl.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/allocate.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/browser.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/cffi.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/chicken.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/clisp.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/contract.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/csharp.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/d.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/directors.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/emit.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/go.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/guile.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/interface.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/java.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/javascript.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/lang.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/lua.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/modula3.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/mzscheme.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/nested.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/ocaml.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/octave.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/overload.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/perl5.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/php.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/pike.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/python.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/r.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/ruby.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/s-exp.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/scilab.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/tcl8.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/typepass.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/uffi.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/utils.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/xml.cxx"
+    "${PROJECT_BINARY_DIR}/Source/Include/swigconfig.h"
+    "${SWIG_SOURCE_DIR}/Include/swigwarn.h"
+)
+
+add_executable(swig
+    "${SWIG_SOURCE_DIR}/Modules/main.cxx"
+    "${SWIG_SOURCE_DIR}/Modules/swigmain.cxx"
+)
+
+target_link_libraries ( swig cparse preprocessor doh core modules doxygen)
+install ( TARGETS swig DESTINATION bin )
diff --git a/Source/CParse/parser.c b/Source/CParse/parser.c
new file mode 100644
index 000000000..2d0119b45
--- /dev/null
+++ b/Source/CParse/parser.c
@@ -0,0 +1,12779 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton implementation for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.3"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     ID = 258,
+     HBLOCK = 259,
+     POUND = 260,
+     STRING = 261,
+     WSTRING = 262,
+     INCLUDE = 263,
+     IMPORT = 264,
+     INSERT = 265,
+     CHARCONST = 266,
+     WCHARCONST = 267,
+     NUM_INT = 268,
+     NUM_FLOAT = 269,
+     NUM_UNSIGNED = 270,
+     NUM_LONG = 271,
+     NUM_ULONG = 272,
+     NUM_LONGLONG = 273,
+     NUM_ULONGLONG = 274,
+     NUM_BOOL = 275,
+     TYPEDEF = 276,
+     TYPE_INT = 277,
+     TYPE_UNSIGNED = 278,
+     TYPE_SHORT = 279,
+     TYPE_LONG = 280,
+     TYPE_FLOAT = 281,
+     TYPE_DOUBLE = 282,
+     TYPE_CHAR = 283,
+     TYPE_WCHAR = 284,
+     TYPE_VOID = 285,
+     TYPE_SIGNED = 286,
+     TYPE_BOOL = 287,
+     TYPE_COMPLEX = 288,
+     TYPE_TYPEDEF = 289,
+     TYPE_RAW = 290,
+     TYPE_NON_ISO_INT8 = 291,
+     TYPE_NON_ISO_INT16 = 292,
+     TYPE_NON_ISO_INT32 = 293,
+     TYPE_NON_ISO_INT64 = 294,
+     LPAREN = 295,
+     RPAREN = 296,
+     COMMA = 297,
+     SEMI = 298,
+     EXTERN = 299,
+     INIT = 300,
+     LBRACE = 301,
+     RBRACE = 302,
+     PERIOD = 303,
+     CONST_QUAL = 304,
+     VOLATILE = 305,
+     REGISTER = 306,
+     STRUCT = 307,
+     UNION = 308,
+     EQUAL = 309,
+     SIZEOF = 310,
+     MODULE = 311,
+     LBRACKET = 312,
+     RBRACKET = 313,
+     BEGINFILE = 314,
+     ENDOFFILE = 315,
+     ILLEGAL = 316,
+     CONSTANT = 317,
+     NAME = 318,
+     RENAME = 319,
+     NAMEWARN = 320,
+     EXTEND = 321,
+     PRAGMA = 322,
+     FEATURE = 323,
+     VARARGS = 324,
+     ENUM = 325,
+     CLASS = 326,
+     TYPENAME = 327,
+     PRIVATE = 328,
+     PUBLIC = 329,
+     PROTECTED = 330,
+     COLON = 331,
+     STATIC = 332,
+     VIRTUAL = 333,
+     FRIEND = 334,
+     THROW = 335,
+     CATCH = 336,
+     EXPLICIT = 337,
+     STATIC_ASSERT = 338,
+     CONSTEXPR = 339,
+     THREAD_LOCAL = 340,
+     DECLTYPE = 341,
+     AUTO = 342,
+     NOEXCEPT = 343,
+     OVERRIDE = 344,
+     FINAL = 345,
+     USING = 346,
+     NAMESPACE = 347,
+     NATIVE = 348,
+     INLINE = 349,
+     TYPEMAP = 350,
+     EXCEPT = 351,
+     ECHO = 352,
+     APPLY = 353,
+     CLEAR = 354,
+     SWIGTEMPLATE = 355,
+     FRAGMENT = 356,
+     WARN = 357,
+     LESSTHAN = 358,
+     GREATERTHAN = 359,
+     DELETE_KW = 360,
+     DEFAULT = 361,
+     LESSTHANOREQUALTO = 362,
+     GREATERTHANOREQUALTO = 363,
+     EQUALTO = 364,
+     NOTEQUALTO = 365,
+     ARROW = 366,
+     QUESTIONMARK = 367,
+     TYPES = 368,
+     PARMS = 369,
+     NONID = 370,
+     DSTAR = 371,
+     DCNOT = 372,
+     TEMPLATE = 373,
+     OPERATOR = 374,
+     CONVERSIONOPERATOR = 375,
+     PARSETYPE = 376,
+     PARSEPARM = 377,
+     PARSEPARMS = 378,
+     DOXYGENSTRING = 379,
+     DOXYGENPOSTSTRING = 380,
+     CAST = 381,
+     LOR = 382,
+     LAND = 383,
+     OR = 384,
+     XOR = 385,
+     AND = 386,
+     RSHIFT = 387,
+     LSHIFT = 388,
+     MINUS = 389,
+     PLUS = 390,
+     MODULO = 391,
+     SLASH = 392,
+     STAR = 393,
+     LNOT = 394,
+     NOT = 395,
+     UMINUS = 396,
+     DCOLON = 397
+   };
+#endif
+/* Tokens.  */
+#define ID 258
+#define HBLOCK 259
+#define POUND 260
+#define STRING 261
+#define WSTRING 262
+#define INCLUDE 263
+#define IMPORT 264
+#define INSERT 265
+#define CHARCONST 266
+#define WCHARCONST 267
+#define NUM_INT 268
+#define NUM_FLOAT 269
+#define NUM_UNSIGNED 270
+#define NUM_LONG 271
+#define NUM_ULONG 272
+#define NUM_LONGLONG 273
+#define NUM_ULONGLONG 274
+#define NUM_BOOL 275
+#define TYPEDEF 276
+#define TYPE_INT 277
+#define TYPE_UNSIGNED 278
+#define TYPE_SHORT 279
+#define TYPE_LONG 280
+#define TYPE_FLOAT 281
+#define TYPE_DOUBLE 282
+#define TYPE_CHAR 283
+#define TYPE_WCHAR 284
+#define TYPE_VOID 285
+#define TYPE_SIGNED 286
+#define TYPE_BOOL 287
+#define TYPE_COMPLEX 288
+#define TYPE_TYPEDEF 289
+#define TYPE_RAW 290
+#define TYPE_NON_ISO_INT8 291
+#define TYPE_NON_ISO_INT16 292
+#define TYPE_NON_ISO_INT32 293
+#define TYPE_NON_ISO_INT64 294
+#define LPAREN 295
+#define RPAREN 296
+#define COMMA 297
+#define SEMI 298
+#define EXTERN 299
+#define INIT 300
+#define LBRACE 301
+#define RBRACE 302
+#define PERIOD 303
+#define CONST_QUAL 304
+#define VOLATILE 305
+#define REGISTER 306
+#define STRUCT 307
+#define UNION 308
+#define EQUAL 309
+#define SIZEOF 310
+#define MODULE 311
+#define LBRACKET 312
+#define RBRACKET 313
+#define BEGINFILE 314
+#define ENDOFFILE 315
+#define ILLEGAL 316
+#define CONSTANT 317
+#define NAME 318
+#define RENAME 319
+#define NAMEWARN 320
+#define EXTEND 321
+#define PRAGMA 322
+#define FEATURE 323
+#define VARARGS 324
+#define ENUM 325
+#define CLASS 326
+#define TYPENAME 327
+#define PRIVATE 328
+#define PUBLIC 329
+#define PROTECTED 330
+#define COLON 331
+#define STATIC 332
+#define VIRTUAL 333
+#define FRIEND 334
+#define THROW 335
+#define CATCH 336
+#define EXPLICIT 337
+#define STATIC_ASSERT 338
+#define CONSTEXPR 339
+#define THREAD_LOCAL 340
+#define DECLTYPE 341
+#define AUTO 342
+#define NOEXCEPT 343
+#define OVERRIDE 344
+#define FINAL 345
+#define USING 346
+#define NAMESPACE 347
+#define NATIVE 348
+#define INLINE 349
+#define TYPEMAP 350
+#define EXCEPT 351
+#define ECHO 352
+#define APPLY 353
+#define CLEAR 354
+#define SWIGTEMPLATE 355
+#define FRAGMENT 356
+#define WARN 357
+#define LESSTHAN 358
+#define GREATERTHAN 359
+#define DELETE_KW 360
+#define DEFAULT 361
+#define LESSTHANOREQUALTO 362
+#define GREATERTHANOREQUALTO 363
+#define EQUALTO 364
+#define NOTEQUALTO 365
+#define ARROW 366
+#define QUESTIONMARK 367
+#define TYPES 368
+#define PARMS 369
+#define NONID 370
+#define DSTAR 371
+#define DCNOT 372
+#define TEMPLATE 373
+#define OPERATOR 374
+#define CONVERSIONOPERATOR 375
+#define PARSETYPE 376
+#define PARSEPARM 377
+#define PARSEPARMS 378
+#define DOXYGENSTRING 379
+#define DOXYGENPOSTSTRING 380
+#define CAST 381
+#define LOR 382
+#define LAND 383
+#define OR 384
+#define XOR 385
+#define AND 386
+#define RSHIFT 387
+#define LSHIFT 388
+#define MINUS 389
+#define PLUS 390
+#define MODULO 391
+#define SLASH 392
+#define STAR 393
+#define LNOT 394
+#define NOT 395
+#define UMINUS 396
+#define DCOLON 397
+
+
+
+
+/* Copy the first part of user declarations.  */
+#line 25 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+
+#define yylex yylex
+
+#include "swig.h"
+#include "cparse.h"
+#include "preprocessor.h"
+#include <ctype.h>
+
+/* We do this for portability */
+#undef alloca
+#define alloca malloc
+
+/* -----------------------------------------------------------------------------
+ *                               Externals
+ * ----------------------------------------------------------------------------- */
+
+int  yyparse();
+
+/* NEW Variables */
+
+static Node    *top = 0;      /* Top of the generated parse tree */
+static int      unnamed = 0;  /* Unnamed datatype counter */
+static Hash    *classes = 0;        /* Hash table of classes */
+static Hash    *classes_typedefs = 0; /* Hash table of typedef classes: typedef struct X {...} Y; */
+static Symtab  *prev_symtab = 0;
+static Node    *current_class = 0;
+String  *ModuleName = 0;
+static Node    *module_node = 0;
+static String  *Classprefix = 0;
+static String  *Namespaceprefix = 0;
+static int      inclass = 0;
+static Node    *currentOuterClass = 0; /* for nested classes */
+static const char *last_cpptype = 0;
+static int      inherit_list = 0;
+static Parm    *template_parameters = 0;
+static int      parsing_template_declaration = 0;
+static int      extendmode   = 0;
+static int      compact_default_args = 0;
+static int      template_reduce = 0;
+static int      cparse_externc = 0;
+int        ignore_nested_classes = 0;
+int        kwargs_supported = 0;
+/* -----------------------------------------------------------------------------
+ *                            Doxygen Comment Globals
+ * ----------------------------------------------------------------------------- */
+static String *currentDeclComment = NULL; /* Comment of C/C++ declaration. */
+static Node *previousNode = NULL; /* Pointer to the previous node (for post comments) */
+static Node *currentNode = NULL; /* Pointer to the current node (for post comments) */
+
+/* -----------------------------------------------------------------------------
+ *                            Assist Functions
+ * ----------------------------------------------------------------------------- */
+
+
+
+/* Called by the parser (yyparse) when an error is found.*/
+static void yyerror (const char *e) {
+  (void)e;
+}
+
+static Node *new_node(const_String_or_char_ptr tag) {
+  Node *n = Swig_cparse_new_node(tag);
+  /* Remember the previous node in case it will need a post-comment */
+  previousNode = currentNode;
+  currentNode = n;
+  return n;
+}
+
+/* Copies a node.  Does not copy tree links or symbol table data (except for
+   sym:name) */
+
+static Node *copy_node(Node *n) {
+  Node *nn;
+  Iterator k;
+  nn = NewHash();
+  Setfile(nn,Getfile(n));
+  Setline(nn,Getline(n));
+  for (k = First(n); k.key; k = Next(k)) {
+    String *ci;
+    String *key = k.key;
+    char *ckey = Char(key);
+    if ((strcmp(ckey,"nextSibling") == 0) ||
+   (strcmp(ckey,"previousSibling") == 0) ||
+   (strcmp(ckey,"parentNode") == 0) ||
+   (strcmp(ckey,"lastChild") == 0)) {
+      continue;
+    }
+    if (Strncmp(key,"csym:",5) == 0) continue;
+    /* We do copy sym:name.  For templates */
+    if ((strcmp(ckey,"sym:name") == 0) ||
+   (strcmp(ckey,"sym:weak") == 0) ||
+   (strcmp(ckey,"sym:typename") == 0)) {
+      String *ci = Copy(k.item);
+      Setattr(nn,key, ci);
+      Delete(ci);
+      continue;
+    }
+    if (strcmp(ckey,"sym:symtab") == 0) {
+      Setattr(nn,"sym:needs_symtab", "1");
+    }
+    /* We don't copy any other symbol table attributes */
+    if (strncmp(ckey,"sym:",4) == 0) {
+      continue;
+    }
+    /* If children.  We copy them recursively using this function */
+    if (strcmp(ckey,"firstChild") == 0) {
+      /* Copy children */
+      Node *cn = k.item;
+      while (cn) {
+   Node *copy = copy_node(cn);
+   appendChild(nn,copy);
+   Delete(copy);
+   cn = nextSibling(cn);
+      }
+      continue;
+    }
+    /* We don't copy the symbol table.  But we drop an attribute
+       requires_symtab so that functions know it needs to be built */
+
+    if (strcmp(ckey,"symtab") == 0) {
+      /* Node defined a symbol table. */
+      Setattr(nn,"requires_symtab","1");
+      continue;
+    }
+    /* Can't copy nodes */
+    if (strcmp(ckey,"node") == 0) {
+      continue;
+    }
+    if ((strcmp(ckey,"parms") == 0) || (strcmp(ckey,"pattern") == 0) || (strcmp(ckey,"throws") == 0)
+   || (strcmp(ckey,"kwargs") == 0)) {
+      ParmList *pl = CopyParmList(k.item);
+      Setattr(nn,key,pl);
+      Delete(pl);
+      continue;
+    }
+    if (strcmp(ckey,"nested:outer") == 0) { /* don't copy outer classes links, they will be updated later */
+      Setattr(nn, key, k.item);
+      continue;
+    }
+    /* defaultargs will be patched back in later in update_defaultargs() */
+    if (strcmp(ckey,"defaultargs") == 0) {
+      Setattr(nn, "needs_defaultargs", "1");
+      continue;
+    }
+    /* same for abstracts, which contains pointers to the source node children, and so will need to be patch too */
+    if (strcmp(ckey,"abstracts") == 0) {
+      SetFlag(nn, "needs_abstracts");
+      continue;
+    }
+    /* Looks okay.  Just copy the data using Copy */
+    ci = Copy(k.item);
+    Setattr(nn, key, ci);
+    Delete(ci);
+  }
+  return nn;
+}
+
+static void set_comment(Node *n, String *comment) {
+  String *name;
+  Parm *p;
+  if (!n || !comment)
+    return;
+
+  if (Getattr(n, "doxygen"))
+    Append(Getattr(n, "doxygen"), comment);
+  else {
+    Setattr(n, "doxygen", comment);
+    /* This is the first comment, populate it with @params, if any */
+    p = Getattr(n, "parms");
+    while (p) {
+      if (Getattr(p, "doxygen"))
+   Printv(comment, "\n@param ", Getattr(p, "name"), Getattr(p, "doxygen"), NIL);
+      p=nextSibling(p);
+    }
+  }
+
+  /* Append same comment to every generated overload */
+  name = Getattr(n, "name");
+  if (!name)
+    return;
+  n = nextSibling(n);
+  while (n && Getattr(n, "name") && Strcmp(Getattr(n, "name"), name) == 0) {
+    Setattr(n, "doxygen", comment);
+    n = nextSibling(n);
+  }
+}
+
+/* -----------------------------------------------------------------------------
+ *                              Variables
+ * ----------------------------------------------------------------------------- */
+
+static char  *typemap_lang = 0;    /* Current language setting */
+
+static int cplus_mode  = 0;
+
+/* C++ modes */
+
+#define  CPLUS_PUBLIC    1
+#define  CPLUS_PRIVATE   2
+#define  CPLUS_PROTECTED 3
+
+/* include types */
+static int   import_mode = 0;
+
+void SWIG_typemap_lang(const char *tm_lang) {
+  typemap_lang = Swig_copy_string(tm_lang);
+}
+
+void SWIG_cparse_set_compact_default_args(int defargs) {
+  compact_default_args = defargs;
+}
+
+int SWIG_cparse_template_reduce(int treduce) {
+  template_reduce = treduce;
+  return treduce;
+}
+
+/* -----------------------------------------------------------------------------
+ *                           Assist functions
+ * ----------------------------------------------------------------------------- */
+
+static int promote_type(int t) {
+  if (t <= T_UCHAR || t == T_CHAR || t == T_WCHAR) return T_INT;
+  return t;
+}
+
+/* Perform type-promotion for binary operators */
+static int promote(int t1, int t2) {
+  t1 = promote_type(t1);
+  t2 = promote_type(t2);
+  return t1 > t2 ? t1 : t2;
+}
+
+static String *yyrename = 0;
+
+/* Forward renaming operator */
+
+static String *resolve_create_node_scope(String *cname, int is_class_definition);
+
+
+Hash *Swig_cparse_features(void) {
+  static Hash   *features_hash = 0;
+  if (!features_hash) features_hash = NewHash();
+  return features_hash;
+}
+
+/* Fully qualify any template parameters */
+static String *feature_identifier_fix(String *s) {
+  String *tp = SwigType_istemplate_templateprefix(s);
+  if (tp) {
+    String *ts, *ta, *tq;
+    ts = SwigType_templatesuffix(s);
+    ta = SwigType_templateargs(s);
+    tq = Swig_symbol_type_qualify(ta,0);
+    Append(tp,tq);
+    Append(tp,ts);
+    Delete(ts);
+    Delete(ta);
+    Delete(tq);
+    return tp;
+  } else {
+    return NewString(s);
+  }
+}
+
+static void set_access_mode(Node *n) {
+  if (cplus_mode == CPLUS_PUBLIC)
+    Setattr(n, "access", "public");
+  else if (cplus_mode == CPLUS_PROTECTED)
+    Setattr(n, "access", "protected");
+  else
+    Setattr(n, "access", "private");
+}
+
+static void restore_access_mode(Node *n) {
+  String *mode = Getattr(n, "access");
+  if (Strcmp(mode, "private") == 0)
+    cplus_mode = CPLUS_PRIVATE;
+  else if (Strcmp(mode, "protected") == 0)
+    cplus_mode = CPLUS_PROTECTED;
+  else
+    cplus_mode = CPLUS_PUBLIC;
+}
+
+/* Generate the symbol table name for an object */
+/* This is a bit of a mess. Need to clean up */
+static String *add_oldname = 0;
+
+
+
+static String *make_name(Node *n, String *name,SwigType *decl) {
+  String *made_name = 0;
+  int destructor = name && (*(Char(name)) == '~');
+
+  if (yyrename) {
+    String *s = NewString(yyrename);
+    Delete(yyrename);
+    yyrename = 0;
+    if (destructor  && (*(Char(s)) != '~')) {
+      Insert(s,0,"~");
+    }
+    return s;
+  }
+
+  if (!name) return 0;
+
+  if (parsing_template_declaration)
+    SetFlag(n, "parsing_template_declaration");
+  made_name = Swig_name_make(n, Namespaceprefix, name, decl, add_oldname);
+  Delattr(n, "parsing_template_declaration");
+
+  return made_name;
+}
+
+/* Generate an unnamed identifier */
+static String *make_unnamed() {
+  unnamed++;
+  return NewStringf("$unnamed%d$",unnamed);
+}
+
+/* Return if the node is a friend declaration */
+static int is_friend(Node *n) {
+  return Cmp(Getattr(n,"storage"),"friend") == 0;
+}
+
+static int is_operator(String *name) {
+  return Strncmp(name,"operator ", 9) == 0;
+}
+
+
+/* Add declaration list to symbol table */
+static int  add_only_one = 0;
+
+static void add_symbols(Node *n) {
+  String *decl;
+  String *wrn = 0;
+
+  if (inclass && n) {
+    cparse_normalize_void(n);
+  }
+  while (n) {
+    String *symname = 0;
+    /* for friends, we need to pop the scope once */
+    String *old_prefix = 0;
+    Symtab *old_scope = 0;
+    int isfriend = inclass && is_friend(n);
+    int iscdecl = Cmp(nodeType(n),"cdecl") == 0;
+    int only_csymbol = 0;
+
+    if (inclass) {
+      String *name = Getattr(n, "name");
+      if (isfriend) {
+   /* for friends, we need to add the scopename if needed */
+   String *prefix = name ? Swig_scopename_prefix(name) : 0;
+   old_prefix = Namespaceprefix;
+   old_scope = Swig_symbol_popscope();
+   Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+   if (!prefix) {
+     if (name && !is_operator(name) && Namespaceprefix) {
+       String *nname = NewStringf("%s::%s", Namespaceprefix, name);
+       Setattr(n,"name",nname);
+       Delete(nname);
+     }
+   } else {
+     Symtab *st = Swig_symbol_getscope(prefix);
+     String *ns = st ? Getattr(st,"name") : prefix;
+     String *base  = Swig_scopename_last(name);
+     String *nname = NewStringf("%s::%s", ns, base);
+     Setattr(n,"name",nname);
+     Delete(nname);
+     Delete(base);
+     Delete(prefix);
+   }
+   Namespaceprefix = 0;
+      } else {
+   /* for member functions, we need to remove the redundant
+      class scope if provided, as in
+
+      struct Foo {
+      int Foo::method(int a);
+      };
+
+   */
+   String *prefix = name ? Swig_scopename_prefix(name) : 0;
+   if (prefix) {
+     if (Classprefix && (Equal(prefix,Classprefix))) {
+       String *base = Swig_scopename_last(name);
+       Setattr(n,"name",base);
+       Delete(base);
+     }
+     Delete(prefix);
+   }
+      }
+    }
+
+    if (!isfriend && (inclass || extendmode)) {
+      Setattr(n,"ismember","1");
+    }
+
+    if (extendmode) {
+      if (!Getattr(n, "template"))
+        SetFlag(n,"isextendmember");
+    }
+
+    if (!isfriend && inclass) {
+      if ((cplus_mode != CPLUS_PUBLIC)) {
+   only_csymbol = 1;
+   if (cplus_mode == CPLUS_PROTECTED) {
+     Setattr(n,"access", "protected");
+     only_csymbol = !Swig_need_protected(n);
+   } else {
+     Setattr(n,"access", "private");
+     /* private are needed only when they are pure virtuals - why? */
+     if ((Cmp(Getattr(n,"storage"),"virtual") == 0) && (Cmp(Getattr(n,"value"),"0") == 0)) {
+       only_csymbol = 0;
+     }
+     if (Cmp(nodeType(n),"destructor") == 0) {
+       /* Needed for "unref" feature */
+       only_csymbol = 0;
+     }
+   }
+      } else {
+     Setattr(n,"access", "public");
+      }
+    }
+    if (Getattr(n,"sym:name")) {
+      n = nextSibling(n);
+      continue;
+    }
+    decl = Getattr(n,"decl");
+    if (!SwigType_isfunction(decl)) {
+      String *name = Getattr(n,"name");
+      String *makename = Getattr(n,"parser:makename");
+      if (iscdecl) {
+   String *storage = Getattr(n, "storage");
+   if (Cmp(storage,"typedef") == 0) {
+     Setattr(n,"kind","typedef");
+   } else {
+     SwigType *type = Getattr(n,"type");
+     String *value = Getattr(n,"value");
+     Setattr(n,"kind","variable");
+     if (value && Len(value)) {
+       Setattr(n,"hasvalue","1");
+     }
+     if (type) {
+       SwigType *ty;
+       SwigType *tmp = 0;
+       if (decl) {
+         ty = tmp = Copy(type);
+         SwigType_push(ty,decl);
+       } else {
+         ty = type;
+       }
+       if (!SwigType_ismutable(ty) || (storage && Strstr(storage, "constexpr"))) {
+         SetFlag(n,"hasconsttype");
+         SetFlag(n,"feature:immutable");
+       }
+       if (tmp) Delete(tmp);
+     }
+     if (!type) {
+       Printf(stderr,"notype name %s\n", name);
+     }
+   }
+      }
+      Swig_features_get(Swig_cparse_features(), Namespaceprefix, name, 0, n);
+      if (makename) {
+   symname = make_name(n, makename,0);
+        Delattr(n,"parser:makename"); /* temporary information, don't leave it hanging around */
+      } else {
+        makename = name;
+   symname = make_name(n, makename,0);
+      }
+
+      if (!symname) {
+   symname = Copy(Getattr(n,"unnamed"));
+      }
+      if (symname) {
+   if (parsing_template_declaration)
+     SetFlag(n, "parsing_template_declaration");
+   wrn = Swig_name_warning(n, Namespaceprefix, symname,0);
+   Delattr(n, "parsing_template_declaration");
+      }
+    } else {
+      String *name = Getattr(n,"name");
+      SwigType *fdecl = Copy(decl);
+      SwigType *fun = SwigType_pop_function(fdecl);
+      if (iscdecl) {
+   Setattr(n,"kind","function");
+      }
+
+      Swig_features_get(Swig_cparse_features(),Namespaceprefix,name,fun,n);
+
+      symname = make_name(n, name,fun);
+      if (parsing_template_declaration)
+   SetFlag(n, "parsing_template_declaration");
+      wrn = Swig_name_warning(n, Namespaceprefix,symname,fun);
+      Delattr(n, "parsing_template_declaration");
+
+      Delete(fdecl);
+      Delete(fun);
+
+    }
+    if (!symname) {
+      n = nextSibling(n);
+      continue;
+    }
+    if (cparse_cplusplus) {
+      String *value = Getattr(n, "value");
+      if (value && Strcmp(value, "delete") == 0) {
+   /* C++11 deleted definition / deleted function */
+        SetFlag(n,"deleted");
+        SetFlag(n,"feature:ignore");
+      }
+      if (SwigType_isrvalue_reference(Getattr(n, "refqualifier"))) {
+   /* Ignore rvalue ref-qualifiers by default
+    * Use Getattr instead of GetFlag to handle explicit ignore and explicit not ignore */
+   if (!(Getattr(n, "feature:ignore") || Strncmp(symname, "$ignore", 7) == 0)) {
+     SWIG_WARN_NODE_BEGIN(n);
+     Swig_warning(WARN_TYPE_RVALUE_REF_QUALIFIER_IGNORED, Getfile(n), Getline(n),
+         "Method with rvalue ref-qualifier %s ignored.\n", Swig_name_decl(n));
+     SWIG_WARN_NODE_END(n);
+     SetFlag(n, "feature:ignore");
+   }
+      }
+    }
+    if (only_csymbol || GetFlag(n, "feature:ignore") || Strncmp(symname, "$ignore", 7) == 0) {
+      /* Only add to C symbol table and continue */
+      Swig_symbol_add(0, n);
+      if (!only_csymbol && !GetFlag(n, "feature:ignore")) {
+   /* Print the warning attached to $ignore name, if any */
+        char *c = Char(symname) + 7;
+   if (strlen(c)) {
+     SWIG_WARN_NODE_BEGIN(n);
+     Swig_warning(0,Getfile(n), Getline(n), "%s\n",c+1);
+     SWIG_WARN_NODE_END(n);
+   }
+   /* If the symbol was ignored via "rename" and is visible, set also feature:ignore*/
+   SetFlag(n, "feature:ignore");
+      }
+      if (!GetFlag(n, "feature:ignore") && Strcmp(symname,"$ignore") == 0) {
+   /* Add feature:ignore if the symbol was explicitly ignored, regardless of visibility */
+   SetFlag(n, "feature:ignore");
+      }
+    } else {
+      Node *c;
+      if ((wrn) && (Len(wrn))) {
+   String *metaname = symname;
+   if (!Getmeta(metaname,"already_warned")) {
+     SWIG_WARN_NODE_BEGIN(n);
+     Swig_warning(0,Getfile(n),Getline(n), "%s\n", wrn);
+     SWIG_WARN_NODE_END(n);
+     Setmeta(metaname,"already_warned","1");
+   }
+      }
+      c = Swig_symbol_add(symname,n);
+
+      if (c != n) {
+        /* symbol conflict attempting to add in the new symbol */
+        if (Getattr(n,"sym:weak")) {
+          Setattr(n,"sym:name",symname);
+        } else {
+          String *e = NewStringEmpty();
+          String *en = NewStringEmpty();
+          String *ec = NewStringEmpty();
+          int redefined = Swig_need_redefined_warn(n,c,inclass);
+          if (redefined) {
+            Printf(en,"Identifier '%s' redefined (ignored)",symname);
+            Printf(ec,"previous definition of '%s'",symname);
+          } else {
+            Printf(en,"Redundant redeclaration of '%s'",symname);
+            Printf(ec,"previous declaration of '%s'",symname);
+          }
+          if (Cmp(symname,Getattr(n,"name"))) {
+            Printf(en," (Renamed from '%s')", SwigType_namestr(Getattr(n,"name")));
+          }
+          Printf(en,",");
+          if (Cmp(symname,Getattr(c,"name"))) {
+            Printf(ec," (Renamed from '%s')", SwigType_namestr(Getattr(c,"name")));
+          }
+          Printf(ec,".");
+     SWIG_WARN_NODE_BEGIN(n);
+          if (redefined) {
+            Swig_warning(WARN_PARSE_REDEFINED,Getfile(n),Getline(n),"%s\n",en);
+            Swig_warning(WARN_PARSE_REDEFINED,Getfile(c),Getline(c),"%s\n",ec);
+          } else if (!is_friend(n) && !is_friend(c)) {
+            Swig_warning(WARN_PARSE_REDUNDANT,Getfile(n),Getline(n),"%s\n",en);
+            Swig_warning(WARN_PARSE_REDUNDANT,Getfile(c),Getline(c),"%s\n",ec);
+          }
+     SWIG_WARN_NODE_END(n);
+          Printf(e,"%s:%d:%s\n%s:%d:%s\n",Getfile(n),Getline(n),en,
+                 Getfile(c),Getline(c),ec);
+          Setattr(n,"error",e);
+     Delete(e);
+          Delete(en);
+          Delete(ec);
+        }
+      }
+    }
+    /* restore the class scope if needed */
+    if (isfriend) {
+      Swig_symbol_setscope(old_scope);
+      if (old_prefix) {
+   Delete(Namespaceprefix);
+   Namespaceprefix = old_prefix;
+      }
+    }
+    Delete(symname);
+
+    if (add_only_one) return;
+    n = nextSibling(n);
+  }
+}
+
+
+/* add symbols a parse tree node copy */
+
+static void add_symbols_copy(Node *n) {
+  String *name;
+  int    emode = 0;
+  while (n) {
+    char *cnodeType = Char(nodeType(n));
+
+    if (strcmp(cnodeType,"access") == 0) {
+      String *kind = Getattr(n,"kind");
+      if (Strcmp(kind,"public") == 0) {
+   cplus_mode = CPLUS_PUBLIC;
+      } else if (Strcmp(kind,"private") == 0) {
+   cplus_mode = CPLUS_PRIVATE;
+      } else if (Strcmp(kind,"protected") == 0) {
+   cplus_mode = CPLUS_PROTECTED;
+      }
+      n = nextSibling(n);
+      continue;
+    }
+
+    add_oldname = Getattr(n,"sym:name");
+    if ((add_oldname) || (Getattr(n,"sym:needs_symtab"))) {
+      int old_inclass = -1;
+      Node *old_current_class = 0;
+      if (add_oldname) {
+   DohIncref(add_oldname);
+   /*  Disable this, it prevents %rename to work with templates */
+   /* If already renamed, we used that name  */
+   /*
+   if (Strcmp(add_oldname, Getattr(n,"name")) != 0) {
+     Delete(yyrename);
+     yyrename = Copy(add_oldname);
+   }
+   */
+      }
+      Delattr(n,"sym:needs_symtab");
+      Delattr(n,"sym:name");
+
+      add_only_one = 1;
+      add_symbols(n);
+
+      if (Getattr(n,"partialargs")) {
+   Swig_symbol_cadd(Getattr(n,"partialargs"),n);
+      }
+      add_only_one = 0;
+      name = Getattr(n,"name");
+      if (Getattr(n,"requires_symtab")) {
+   Swig_symbol_newscope();
+   Swig_symbol_setscopename(name);
+   Delete(Namespaceprefix);
+   Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+      }
+      if (strcmp(cnodeType,"class") == 0) {
+   old_inclass = inclass;
+   inclass = 1;
+   old_current_class = current_class;
+   current_class = n;
+   if (Strcmp(Getattr(n,"kind"),"class") == 0) {
+     cplus_mode = CPLUS_PRIVATE;
+   } else {
+     cplus_mode = CPLUS_PUBLIC;
+   }
+      }
+      if (strcmp(cnodeType,"extend") == 0) {
+   emode = cplus_mode;
+   cplus_mode = CPLUS_PUBLIC;
+      }
+      add_symbols_copy(firstChild(n));
+      if (strcmp(cnodeType,"extend") == 0) {
+   cplus_mode = emode;
+      }
+      if (Getattr(n,"requires_symtab")) {
+   Setattr(n,"symtab", Swig_symbol_popscope());
+   Delattr(n,"requires_symtab");
+   Delete(Namespaceprefix);
+   Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+      }
+      if (add_oldname) {
+   Delete(add_oldname);
+   add_oldname = 0;
+      }
+      if (strcmp(cnodeType,"class") == 0) {
+   inclass = old_inclass;
+   current_class = old_current_class;
+      }
+    } else {
+      if (strcmp(cnodeType,"extend") == 0) {
+   emode = cplus_mode;
+   cplus_mode = CPLUS_PUBLIC;
+      }
+      add_symbols_copy(firstChild(n));
+      if (strcmp(cnodeType,"extend") == 0) {
+   cplus_mode = emode;
+      }
+    }
+    n = nextSibling(n);
+  }
+}
+
+/* Add in the "defaultargs" attribute for functions in instantiated templates.
+ * n should be any instantiated template (class or start of linked list of functions). */
+static void update_defaultargs(Node *n) {
+  if (n) {
+    Node *firstdefaultargs = n;
+    update_defaultargs(firstChild(n));
+    n = nextSibling(n);
+    /* recursively loop through nodes of all types, but all we really need are the overloaded functions */
+    while (n) {
+      update_defaultargs(firstChild(n));
+      if (!Getattr(n, "defaultargs")) {
+   if (Getattr(n, "needs_defaultargs")) {
+     Setattr(n, "defaultargs", firstdefaultargs);
+     Delattr(n, "needs_defaultargs");
+   } else {
+     firstdefaultargs = n;
+   }
+      } else {
+   /* Functions added in with %extend (for specialized template classes) will already have default args patched up */
+   assert(Getattr(n, "defaultargs") == firstdefaultargs);
+      }
+      n = nextSibling(n);
+    }
+  }
+}
+
+/* Check a set of declarations to see if any are pure-abstract */
+
+static List *pure_abstracts(Node *n) {
+  List *abstracts = 0;
+  while (n) {
+    if (Cmp(nodeType(n),"cdecl") == 0) {
+      String *decl = Getattr(n,"decl");
+      if (SwigType_isfunction(decl)) {
+   String *init = Getattr(n,"value");
+   if (Cmp(init,"0") == 0) {
+     if (!abstracts) {
+       abstracts = NewList();
+     }
+     Append(abstracts,n);
+     SetFlag(n,"abstract");
+   }
+      }
+    } else if (Cmp(nodeType(n),"destructor") == 0) {
+      if (Cmp(Getattr(n,"value"),"0") == 0) {
+   if (!abstracts) {
+     abstracts = NewList();
+   }
+   Append(abstracts,n);
+   SetFlag(n,"abstract");
+      }
+    }
+    n = nextSibling(n);
+  }
+  return abstracts;
+}
+
+/* Recompute the "abstracts" attribute for the classes in instantiated templates, similarly to update_defaultargs() above. */
+static void update_abstracts(Node *n) {
+  for (; n; n = nextSibling(n)) {
+    Node* const child = firstChild(n);
+    if (!child)
+      continue;
+
+    update_abstracts(child);
+
+    if (Getattr(n, "needs_abstracts")) {
+      Setattr(n, "abstracts", pure_abstracts(child));
+      Delattr(n, "needs_abstracts");
+    }
+  }
+}
+
+/* Make a classname */
+
+static String *make_class_name(String *name) {
+  String *nname = 0;
+  String *prefix;
+  if (Namespaceprefix) {
+    nname= NewStringf("%s::%s", Namespaceprefix, name);
+  } else {
+    nname = NewString(name);
+  }
+  prefix = SwigType_istemplate_templateprefix(nname);
+  if (prefix) {
+    String *args, *qargs;
+    args   = SwigType_templateargs(nname);
+    qargs  = Swig_symbol_type_qualify(args,0);
+    Append(prefix,qargs);
+    Delete(nname);
+    Delete(args);
+    Delete(qargs);
+    nname = prefix;
+  }
+  return nname;
+}
+
+/* Use typedef name as class name */
+
+static void add_typedef_name(Node *n, Node *declnode, String *oldName, Symtab *cscope, String *scpname) {
+  String *class_rename = 0;
+  SwigType *decl = Getattr(declnode, "decl");
+  if (!decl || !Len(decl)) {
+    String *cname;
+    String *tdscopename;
+    String *class_scope = Swig_symbol_qualifiedscopename(cscope);
+    String *name = Getattr(declnode, "name");
+    cname = Copy(name);
+    Setattr(n, "tdname", cname);
+    tdscopename = class_scope ? NewStringf("%s::%s", class_scope, name) : Copy(name);
+    class_rename = Getattr(n, "class_rename");
+    if (class_rename && (Strcmp(class_rename, oldName) == 0))
+      Setattr(n, "class_rename", NewString(name));
+    if (!classes_typedefs) classes_typedefs = NewHash();
+    if (!Equal(scpname, tdscopename) && !Getattr(classes_typedefs, tdscopename)) {
+      Setattr(classes_typedefs, tdscopename, n);
+    }
+    Setattr(n, "decl", decl);
+    Delete(class_scope);
+    Delete(cname);
+    Delete(tdscopename);
+  }
+}
+
+/* If the class name is qualified.  We need to create or lookup namespace entries */
+
+static Symtab *set_scope_to_global() {
+  Symtab *symtab = Swig_symbol_global_scope();
+  Swig_symbol_setscope(symtab);
+  return symtab;
+}
+
+/* Remove the block braces, { and }, if the 'noblock' attribute is set.
+ * Node *kw can be either a Hash or Parmlist. */
+static String *remove_block(Node *kw, const String *inputcode) {
+  String *modified_code = 0;
+  while (kw) {
+   String *name = Getattr(kw,"name");
+   if (name && (Cmp(name,"noblock") == 0)) {
+     char *cstr = Char(inputcode);
+     int len = Len(inputcode);
+     if (len && cstr[0] == '{') {
+       --len; ++cstr;
+       if (len && cstr[len - 1] == '}') { --len; }
+       /* we now remove the extra spaces */
+       while (len && isspace((int)cstr[0])) { --len; ++cstr; }
+       while (len && isspace((int)cstr[len - 1])) { --len; }
+       modified_code = NewStringWithSize(cstr, len);
+       break;
+     }
+   }
+   kw = nextSibling(kw);
+  }
+  return modified_code;
+}
+
+/*
+#define RESOLVE_DEBUG 1
+*/
+static Node *nscope = 0;
+static Node *nscope_inner = 0;
+
+/* Remove the scope prefix from cname and return the base name without the prefix.
+ * The scopes required for the symbol name are resolved and/or created, if required.
+ * For example AA::BB::CC as input returns CC and creates the namespace AA then inner
+ * namespace BB in the current scope. */
+static String *resolve_create_node_scope(String *cname, int is_class_definition) {
+  Symtab *gscope = 0;
+  Node *cname_node = 0;
+  String *last = Swig_scopename_last(cname);
+  nscope = 0;
+  nscope_inner = 0;
+
+  if (Strncmp(cname,"::" ,2) != 0) {
+    if (is_class_definition) {
+      /* Only lookup symbols which are in scope via a using declaration but not via a using directive.
+         For example find y via 'using x::y' but not y via a 'using namespace x'. */
+      cname_node = Swig_symbol_clookup_no_inherit(cname, 0);
+      if (!cname_node) {
+   Node *full_lookup_node = Swig_symbol_clookup(cname, 0);
+   if (full_lookup_node) {
+    /* This finds a symbol brought into scope via both a using directive and a using declaration. */
+     Node *last_node = Swig_symbol_clookup_no_inherit(last, 0);
+     if (last_node == full_lookup_node)
+       cname_node = last_node;
+   }
+      }
+    } else {
+      /* For %template, the template needs to be in scope via any means. */
+      cname_node = Swig_symbol_clookup(cname, 0);
+    }
+  }
+#if RESOLVE_DEBUG
+  if (!cname_node)
+    Printf(stdout, "symbol does not yet exist (%d): [%s]\n", is_class_definition, cname);
+  else
+    Printf(stdout, "symbol does exist (%d): [%s]\n", is_class_definition, cname);
+#endif
+
+  if (cname_node) {
+    /* The symbol has been defined already or is in another scope.
+       If it is a weak symbol, it needs replacing and if it was brought into the current scope,
+       the scope needs adjusting appropriately for the new symbol.
+       Similarly for defined templates. */
+    Symtab *symtab = Getattr(cname_node, "sym:symtab");
+    Node *sym_weak = Getattr(cname_node, "sym:weak");
+    if ((symtab && sym_weak) || Equal(nodeType(cname_node), "template")) {
+      /* Check if the scope is the current scope */
+      String *current_scopename = Swig_symbol_qualifiedscopename(0);
+      String *found_scopename = Swig_symbol_qualifiedscopename(symtab);
+      if (!current_scopename)
+   current_scopename = NewString("");
+      if (!found_scopename)
+   found_scopename = NewString("");
+
+      {
+   int fail = 1;
+   List *current_scopes = Swig_scopename_tolist(current_scopename);
+   List *found_scopes = Swig_scopename_tolist(found_scopename);
+        Iterator cit = First(current_scopes);
+   Iterator fit = First(found_scopes);
+#if RESOLVE_DEBUG
+Printf(stdout, "comparing current: [%s] found: [%s]\n", current_scopename, found_scopename);
+#endif
+   for (; fit.item && cit.item; fit = Next(fit), cit = Next(cit)) {
+     String *current = cit.item;
+     String *found = fit.item;
+#if RESOLVE_DEBUG
+     Printf(stdout, "  looping %s %s\n", current, found);
+#endif
+     if (Strcmp(current, found) != 0)
+       break;
+   }
+
+   if (!cit.item) {
+     String *subscope = NewString("");
+     for (; fit.item; fit = Next(fit)) {
+       if (Len(subscope) > 0)
+         Append(subscope, "::");
+       Append(subscope, fit.item);
+     }
+     if (Len(subscope) > 0)
+       cname = NewStringf("%s::%s", subscope, last);
+     else
+       cname = Copy(last);
+#if RESOLVE_DEBUG
+     Printf(stdout, "subscope to create: [%s] cname: [%s]\n", subscope, cname);
+#endif
+     fail = 0;
+     Delete(subscope);
+   } else {
+     if (is_class_definition) {
+       if (!fit.item) {
+         /* It is valid to define a new class with the same name as one forward declared in a parent scope */
+         fail = 0;
+       } else if (Swig_scopename_check(cname)) {
+         /* Classes defined with scope qualifiers must have a matching forward declaration in matching scope */
+         fail = 1;
+       } else {
+         /* This may let through some invalid cases */
+         fail = 0;
+       }
+#if RESOLVE_DEBUG
+       Printf(stdout, "scope for class definition, fail: %d\n", fail);
+#endif
+     } else {
+#if RESOLVE_DEBUG
+       Printf(stdout, "no matching base scope for template\n");
+#endif
+       fail = 1;
+     }
+   }
+
+   Delete(found_scopes);
+   Delete(current_scopes);
+
+   if (fail) {
+     String *cname_resolved = NewStringf("%s::%s", found_scopename, last);
+     Swig_error(cparse_file, cparse_line, "'%s' resolves to '%s' and was incorrectly instantiated in scope '%s' instead of within scope '%s'.\n", cname, cname_resolved, current_scopename, found_scopename);
+     cname = Copy(last);
+     Delete(cname_resolved);
+   }
+      }
+
+      Delete(current_scopename);
+      Delete(found_scopename);
+    }
+  } else if (!is_class_definition) {
+    /* A template instantiation requires a template to be found in scope... fail here too?
+    Swig_error(cparse_file, cparse_line, "No template found to instantiate '%s' with %%template.\n", cname);
+     */
+  }
+
+  if (Swig_scopename_check(cname)) {
+    Node   *ns;
+    String *prefix = Swig_scopename_prefix(cname);
+    if (prefix && (Strncmp(prefix,"::",2) == 0)) {
+/* I don't think we can use :: global scope to declare classes and hence neither %template. - consider reporting error instead - wsfulton. */
+      /* Use the global scope */
+      String *nprefix = NewString(Char(prefix)+2);
+      Delete(prefix);
+      prefix= nprefix;
+      gscope = set_scope_to_global();
+    }
+    if (Len(prefix) == 0) {
+      String *base = Copy(last);
+      /* Use the global scope, but we need to add a 'global' namespace.  */
+      if (!gscope) gscope = set_scope_to_global();
+      /* note that this namespace is not the "unnamed" one,
+    and we don't use Setattr(nscope,"name", ""),
+    because the unnamed namespace is private */
+      nscope = new_node("namespace");
+      Setattr(nscope,"symtab", gscope);;
+      nscope_inner = nscope;
+      Delete(last);
+      return base;
+    }
+    /* Try to locate the scope */
+    ns = Swig_symbol_clookup(prefix,0);
+    if (!ns) {
+      Swig_error(cparse_file,cparse_line,"Undefined scope '%s'\n", prefix);
+    } else {
+      Symtab *nstab = Getattr(ns,"symtab");
+      if (!nstab) {
+   Swig_error(cparse_file,cparse_line, "'%s' is not defined as a valid scope.\n", prefix);
+   ns = 0;
+      } else {
+   /* Check if the node scope is the current scope */
+   String *tname = Swig_symbol_qualifiedscopename(0);
+   String *nname = Swig_symbol_qualifiedscopename(nstab);
+   if (tname && (Strcmp(tname,nname) == 0)) {
+     ns = 0;
+     cname = Copy(last);
+   }
+   Delete(tname);
+   Delete(nname);
+      }
+      if (ns) {
+   /* we will try to create a new node using the namespaces we
+      can find in the scope name */
+   List *scopes = Swig_scopename_tolist(prefix);
+   String *sname;
+   Iterator si;
+
+   for (si = First(scopes); si.item; si = Next(si)) {
+     Node *ns1,*ns2;
+     sname = si.item;
+     ns1 = Swig_symbol_clookup(sname,0);
+     assert(ns1);
+     if (Strcmp(nodeType(ns1),"namespace") == 0) {
+       if (Getattr(ns1,"alias")) {
+         ns1 = Getattr(ns1,"namespace");
+       }
+     } else {
+       /* now this last part is a class */
+       si = Next(si);
+       /*  or a nested class tree, which is unrolled here */
+       for (; si.item; si = Next(si)) {
+         if (si.item) {
+       Printf(sname,"::%s",si.item);
+         }
+       }
+       /* we get the 'inner' class */
+       nscope_inner = Swig_symbol_clookup(sname,0);
+       /* set the scope to the inner class */
+       Swig_symbol_setscope(Getattr(nscope_inner,"symtab"));
+       /* save the last namespace prefix */
+       Delete(Namespaceprefix);
+       Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+       /* and return the node name, including the inner class prefix */
+       break;
+     }
+     /* here we just populate the namespace tree as usual */
+     ns2 = new_node("namespace");
+     Setattr(ns2,"name",sname);
+     Setattr(ns2,"symtab", Getattr(ns1,"symtab"));
+     add_symbols(ns2);
+     Swig_symbol_setscope(Getattr(ns1,"symtab"));
+     Delete(Namespaceprefix);
+     Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+     if (nscope_inner) {
+       if (Getattr(nscope_inner,"symtab") != Getattr(ns2,"symtab")) {
+         appendChild(nscope_inner,ns2);
+         Delete(ns2);
+       }
+     }
+     nscope_inner = ns2;
+     if (!nscope) nscope = ns2;
+   }
+   cname = Copy(last);
+   Delete(scopes);
+      }
+    }
+    Delete(prefix);
+  }
+  Delete(last);
+
+  return cname;
+}
+
+/* look for simple typedef name in typedef list */
+static String *try_to_find_a_name_for_unnamed_structure(const char *storage, Node *decls) {
+  String *name = 0;
+  Node *n = decls;
+  if (storage && (strcmp(storage, "typedef") == 0)) {
+    for (; n; n = nextSibling(n)) {
+      if (!Len(Getattr(n, "decl"))) {
+   name = Copy(Getattr(n, "name"));
+   break;
+      }
+    }
+  }
+  return name;
+}
+
+/* traverse copied tree segment, and update outer class links*/
+static void update_nested_classes(Node *n)
+{
+  Node *c = firstChild(n);
+  while (c) {
+    if (Getattr(c, "nested:outer"))
+      Setattr(c, "nested:outer", n);
+    update_nested_classes(c);
+    c = nextSibling(c);
+  }
+}
+
+/* -----------------------------------------------------------------------------
+ * nested_forward_declaration()
+ *
+ * Nested struct handling for C++ code if the nested classes are disabled.
+ * Create the nested class/struct/union as a forward declaration.
+ * ----------------------------------------------------------------------------- */
+
+static Node *nested_forward_declaration(const char *storage, const char *kind, String *sname, String *name, Node *cpp_opt_declarators) {
+  Node *nn = 0;
+
+  if (sname) {
+    /* Add forward declaration of the nested type */
+    Node *n = new_node("classforward");
+    Setattr(n, "kind", kind);
+    Setattr(n, "name", sname);
+    Setattr(n, "storage", storage);
+    Setattr(n, "sym:weak", "1");
+    add_symbols(n);
+    nn = n;
+  }
+
+  /* Add any variable instances. Also add in any further typedefs of the nested type.
+     Note that anonymous typedefs (eg typedef struct {...} a, b;) are treated as class forward declarations */
+  if (cpp_opt_declarators) {
+    int storage_typedef = (storage && (strcmp(storage, "typedef") == 0));
+    int variable_of_anonymous_type = !sname && !storage_typedef;
+    if (!variable_of_anonymous_type) {
+      int anonymous_typedef = !sname && (storage && (strcmp(storage, "typedef") == 0));
+      Node *n = cpp_opt_declarators;
+      SwigType *type = name;
+      while (n) {
+   Setattr(n, "type", type);
+   Setattr(n, "storage", storage);
+   if (anonymous_typedef) {
+     Setattr(n, "nodeType", "classforward");
+     Setattr(n, "sym:weak", "1");
+   }
+   n = nextSibling(n);
+      }
+      add_symbols(cpp_opt_declarators);
+
+      if (nn) {
+   set_nextSibling(nn, cpp_opt_declarators);
+      } else {
+   nn = cpp_opt_declarators;
+      }
+    }
+  }
+
+  if (!currentOuterClass || !GetFlag(currentOuterClass, "nested")) {
+    if (nn && Equal(nodeType(nn), "classforward")) {
+      Node *n = nn;
+      if (!GetFlag(n, "feature:ignore")) {
+   SWIG_WARN_NODE_BEGIN(n);
+   Swig_warning(WARN_PARSE_NAMED_NESTED_CLASS, cparse_file, cparse_line,"Nested %s not currently supported (%s ignored)\n", kind, sname ? sname : name);
+   SWIG_WARN_NODE_END(n);
+      }
+    } else {
+      Swig_warning(WARN_PARSE_UNNAMED_NESTED_CLASS, cparse_file, cparse_line, "Nested %s not currently supported (ignored).\n", kind);
+    }
+  }
+
+  return nn;
+}
+
+
+Node *Swig_cparse(File *f) {
+  scanner_file(f);
+  top = 0;
+  yyparse();
+  return top;
+}
+
+static void single_new_feature(const char *featurename, String *val, Hash *featureattribs, char *declaratorid, SwigType *type, ParmList *declaratorparms, String *qualifier) {
+  String *fname;
+  String *name;
+  String *fixname;
+  SwigType *t = Copy(type);
+
+  /* Printf(stdout, "single_new_feature: [%s] [%s] [%s] [%s] [%s] [%s]\n", featurename, val, declaratorid, t, ParmList_str_defaultargs(declaratorparms), qualifier); */
+
+  /* Warn about deprecated features */
+  if (strcmp(featurename, "nestedworkaround") == 0)
+    Swig_warning(WARN_DEPRECATED_NESTED_WORKAROUND, cparse_file, cparse_line, "The 'nestedworkaround' feature is deprecated.\n");
+
+  fname = NewStringf("feature:%s",featurename);
+  if (declaratorid) {
+    fixname = feature_identifier_fix(declaratorid);
+  } else {
+    fixname = NewStringEmpty();
+  }
+  if (Namespaceprefix) {
+    name = NewStringf("%s::%s",Namespaceprefix, fixname);
+  } else {
+    name = fixname;
+  }
+
+  if (declaratorparms) Setmeta(val,"parms",declaratorparms);
+  if (!Len(t)) t = 0;
+  if (t) {
+    if (qualifier) SwigType_push(t,qualifier);
+    if (SwigType_isfunction(t)) {
+      SwigType *decl = SwigType_pop_function(t);
+      if (SwigType_ispointer(t)) {
+   String *nname = NewStringf("*%s",name);
+   Swig_feature_set(Swig_cparse_features(), nname, decl, fname, val, featureattribs);
+   Delete(nname);
+      } else {
+   Swig_feature_set(Swig_cparse_features(), name, decl, fname, val, featureattribs);
+      }
+      Delete(decl);
+    } else if (SwigType_ispointer(t)) {
+      String *nname = NewStringf("*%s",name);
+      Swig_feature_set(Swig_cparse_features(),nname,0,fname,val, featureattribs);
+      Delete(nname);
+    }
+  } else {
+    /* Global feature, that is, feature not associated with any particular symbol */
+    Swig_feature_set(Swig_cparse_features(),name,0,fname,val, featureattribs);
+  }
+  Delete(fname);
+  Delete(name);
+}
+
+/* Add a new feature to the Hash. Additional features are added if the feature has a parameter list (declaratorparms)
+ * and one or more of the parameters have a default argument. An extra feature is added for each defaulted parameter,
+ * simulating the equivalent overloaded method. */
+static void new_feature(const char *featurename, String *val, Hash *featureattribs, char *declaratorid, SwigType *type, ParmList *declaratorparms, String *qualifier) {
+
+  ParmList *declparms = declaratorparms;
+
+  /* remove the { and } braces if the noblock attribute is set */
+  String *newval = remove_block(featureattribs, val);
+  val = newval ? newval : val;
+
+  /* Add the feature */
+  single_new_feature(featurename, val, featureattribs, declaratorid, type, declaratorparms, qualifier);
+
+  /* Add extra features if there are default parameters in the parameter list */
+  if (type) {
+    while (declparms) {
+      if (ParmList_has_defaultargs(declparms)) {
+
+        /* Create a parameter list for the new feature by copying all
+           but the last (defaulted) parameter */
+        ParmList* newparms = CopyParmListMax(declparms, ParmList_len(declparms)-1);
+
+        /* Create new declaration - with the last parameter removed */
+        SwigType *newtype = Copy(type);
+        Delete(SwigType_pop_function(newtype)); /* remove the old parameter list from newtype */
+        SwigType_add_function(newtype,newparms);
+
+        single_new_feature(featurename, Copy(val), featureattribs, declaratorid, newtype, newparms, qualifier);
+        declparms = newparms;
+      } else {
+        declparms = 0;
+      }
+    }
+  }
+}
+
+/* check if a function declaration is a plain C object */
+static int is_cfunction(Node *n) {
+  if (!cparse_cplusplus || cparse_externc)
+    return 1;
+  if (Swig_storage_isexternc(n)) {
+    return 1;
+  }
+  return 0;
+}
+
+/* If the Node is a function with parameters, check to see if any of the parameters
+ * have default arguments. If so create a new function for each defaulted argument.
+ * The additional functions form a linked list of nodes with the head being the original Node n. */
+static void default_arguments(Node *n) {
+  Node *function = n;
+
+  if (function) {
+    ParmList *varargs = Getattr(function,"feature:varargs");
+    if (varargs) {
+      /* Handles the %varargs directive by looking for "feature:varargs" and
+       * substituting ... with an alternative set of arguments.  */
+      Parm     *p = Getattr(function,"parms");
+      Parm     *pp = 0;
+      while (p) {
+   SwigType *t = Getattr(p,"type");
+   if (Strcmp(t,"v(...)") == 0) {
+     if (pp) {
+       ParmList *cv = Copy(varargs);
+       set_nextSibling(pp,cv);
+       Delete(cv);
+     } else {
+       ParmList *cv =  Copy(varargs);
+       Setattr(function,"parms", cv);
+       Delete(cv);
+     }
+     break;
+   }
+   pp = p;
+   p = nextSibling(p);
+      }
+    }
+
+    /* Do not add in functions if kwargs is being used or if user wants old default argument wrapping
+       (one wrapped method per function irrespective of number of default arguments) */
+    if (compact_default_args
+   || is_cfunction(function)
+   || GetFlag(function,"feature:compactdefaultargs")
+   || (GetFlag(function,"feature:kwargs") && kwargs_supported)) {
+      ParmList *p = Getattr(function,"parms");
+      if (p)
+        Setattr(p,"compactdefargs", "1"); /* mark parameters for special handling */
+      function = 0; /* don't add in extra methods */
+    }
+  }
+
+  while (function) {
+    ParmList *parms = Getattr(function,"parms");
+    if (ParmList_has_defaultargs(parms)) {
+
+      /* Create a parameter list for the new function by copying all
+         but the last (defaulted) parameter */
+      ParmList* newparms = CopyParmListMax(parms,ParmList_len(parms)-1);
+
+      /* Create new function and add to symbol table */
+      {
+   SwigType *ntype = Copy(nodeType(function));
+   char *cntype = Char(ntype);
+        Node *new_function = new_node(ntype);
+        SwigType *decl = Copy(Getattr(function,"decl"));
+        int constqualifier = SwigType_isconst(decl);
+   String *ccode = Copy(Getattr(function,"code"));
+   String *cstorage = Copy(Getattr(function,"storage"));
+   String *cvalue = Copy(Getattr(function,"value"));
+   SwigType *ctype = Copy(Getattr(function,"type"));
+   String *cthrow = Copy(Getattr(function,"throw"));
+
+        Delete(SwigType_pop_function(decl)); /* remove the old parameter list from decl */
+        SwigType_add_function(decl,newparms);
+        if (constqualifier)
+          SwigType_add_qualifier(decl,"const");
+
+        Setattr(new_function,"name", Getattr(function,"name"));
+        Setattr(new_function,"code", ccode);
+        Setattr(new_function,"decl", decl);
+        Setattr(new_function,"parms", newparms);
+        Setattr(new_function,"storage", cstorage);
+        Setattr(new_function,"value", cvalue);
+        Setattr(new_function,"type", ctype);
+        Setattr(new_function,"throw", cthrow);
+
+   Delete(ccode);
+   Delete(cstorage);
+   Delete(cvalue);
+   Delete(ctype);
+   Delete(cthrow);
+   Delete(decl);
+
+        {
+          Node *throws = Getattr(function,"throws");
+     ParmList *pl = CopyParmList(throws);
+          if (throws) Setattr(new_function,"throws",pl);
+     Delete(pl);
+        }
+
+        /* copy specific attributes for global (or in a namespace) template functions - these are not templated class methods */
+        if (strcmp(cntype,"template") == 0) {
+          Node *templatetype = Getattr(function,"templatetype");
+          Node *symtypename = Getattr(function,"sym:typename");
+          Parm *templateparms = Getattr(function,"templateparms");
+          if (templatetype) {
+       Node *tmp = Copy(templatetype);
+       Setattr(new_function,"templatetype",tmp);
+       Delete(tmp);
+     }
+          if (symtypename) {
+       Node *tmp = Copy(symtypename);
+       Setattr(new_function,"sym:typename",tmp);
+       Delete(tmp);
+     }
+          if (templateparms) {
+       Parm *tmp = CopyParmList(templateparms);
+       Setattr(new_function,"templateparms",tmp);
+       Delete(tmp);
+     }
+        } else if (strcmp(cntype,"constructor") == 0) {
+          /* only copied for constructors as this is not a user defined feature - it is hard coded in the parser */
+          if (GetFlag(function,"feature:new")) SetFlag(new_function,"feature:new");
+        }
+
+        add_symbols(new_function);
+        /* mark added functions as ones with overloaded parameters and point to the parsed method */
+        Setattr(new_function,"defaultargs", n);
+
+        /* Point to the new function, extending the linked list */
+        set_nextSibling(function, new_function);
+   Delete(new_function);
+        function = new_function;
+
+   Delete(ntype);
+      }
+    } else {
+      function = 0;
+    }
+  }
+}
+
+/* -----------------------------------------------------------------------------
+ * mark_nodes_as_extend()
+ *
+ * Used by the %extend to mark subtypes with "feature:extend".
+ * template instances declared within %extend are skipped
+ * ----------------------------------------------------------------------------- */
+
+static void mark_nodes_as_extend(Node *n) {
+  for (; n; n = nextSibling(n)) {
+    if (Getattr(n, "template") && Strcmp(nodeType(n), "class") == 0)
+      continue;
+    /* Fix me: extend is not a feature. Replace with isextendmember? */
+    Setattr(n, "feature:extend", "1");
+    mark_nodes_as_extend(firstChild(n));
+  }
+}
+
+/* -----------------------------------------------------------------------------
+ * add_qualifier_to_declarator()
+ *
+ * Normally the qualifier is pushed on to the front of the type.
+ * Adding a qualifier to a pointer to member function is a special case.
+ * For example       : typedef double (Cls::*pmf)(void) const;
+ * The qualifier is  : q(const).
+ * The declarator is : m(Cls).f(void).
+ * We need           : m(Cls).q(const).f(void).
+ * ----------------------------------------------------------------------------- */
+
+static String *add_qualifier_to_declarator(SwigType *type, SwigType *qualifier) {
+  int is_pointer_to_member_function = 0;
+  String *decl = Copy(type);
+  String *poppedtype = NewString("");
+  assert(qualifier);
+
+  while (decl) {
+    if (SwigType_ismemberpointer(decl)) {
+      String *memberptr = SwigType_pop(decl);
+      if (SwigType_isfunction(decl)) {
+   is_pointer_to_member_function = 1;
+   SwigType_push(decl, qualifier);
+   SwigType_push(decl, memberptr);
+   Insert(decl, 0, poppedtype);
+   Delete(memberptr);
+   break;
+      } else {
+   Append(poppedtype, memberptr);
+      }
+      Delete(memberptr);
+    } else {
+      String *popped = SwigType_pop(decl);
+      if (!popped)
+   break;
+      Append(poppedtype, popped);
+      Delete(popped);
+    }
+  }
+
+  if (!is_pointer_to_member_function) {
+    Delete(decl);
+    decl = Copy(type);
+    SwigType_push(decl, qualifier);
+  }
+
+  Delete(poppedtype);
+  return decl;
+}
+
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+#line 1542 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+{
+  const char  *id;
+  List  *bases;
+  struct Define {
+    String *val;
+    String *rawval;
+    int     type;
+    String *qualifier;
+    String *refqualifier;
+    String *bitfield;
+    Parm   *throws;
+    String *throwf;
+    String *nexcept;
+    String *final;
+  } dtype;
+  struct {
+    const char *type;
+    String *filename;
+    int   line;
+  } loc;
+  struct {
+    char      *id;
+    SwigType  *type;
+    String    *defarg;
+    ParmList  *parms;
+    short      have_parms;
+    ParmList  *throws;
+    String    *throwf;
+    String    *nexcept;
+    String    *final;
+  } decl;
+  Parm         *tparms;
+  struct {
+    String     *method;
+    Hash       *kwargs;
+  } tmap;
+  struct {
+    String     *type;
+    String     *us;
+  } ptype;
+  SwigType     *type;
+  String       *str;
+  Parm         *p;
+  ParmList     *pl;
+  int           intvalue;
+  Node         *node;
+}
+/* Line 193 of yacc.c.  */
+#line 1945 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig-build/Source/CParse/parser.c"
+   YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 216 of yacc.c.  */
+#line 1958 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig-build/Source/CParse/parser.c"
+
+#ifdef short
+# undef short
+#endif
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
+#endif
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
+#endif
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
+#endif
+
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
+#ifndef YY_
+# if defined YYENABLE_NLS && YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
+
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int i)
+#else
+static int
+YYID (i)
+    int i;
+#endif
+{
+  return i;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
+#  endif
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+        && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+# endif
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
+
+
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+    || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  yytype_int16 yyss;
+  YYSTYPE yyvs;
+  };
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined __GNUC__ && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)     \
+      do                   \
+   {                   \
+     YYSIZE_T yyi;             \
+     for (yyi = 0; yyi < (Count); yyi++)   \
+       (To)[yyi] = (From)[yyi];        \
+   }                   \
+      while (YYID (0))
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack)                   \
+    do                                 \
+      {                                    \
+   YYSIZE_T yynewbytes;                        \
+   YYCOPY (&yyptr->Stack, Stack, yysize);              \
+   Stack = &yyptr->Stack;                      \
+   yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+   yyptr += yynewbytes / sizeof (*yyptr);              \
+      }                                    \
+    while (YYID (0))
+
+#endif
+
+/* YYFINAL -- State number of the termination state.  */
+#define YYFINAL  62
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   5671
+
+/* YYNTOKENS -- Number of terminals.  */
+#define YYNTOKENS  143
+/* YYNNTS -- Number of nonterminals.  */
+#define YYNNTS  183
+/* YYNRULES -- Number of rules.  */
+#define YYNRULES  617
+/* YYNRULES -- Number of states.  */
+#define YYNSTATES  1200
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   397
+
+#define YYTRANSLATE(YYX)                       \
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const yytype_uint8 yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
+      45,    46,    47,    48,    49,    50,    51,    52,    53,    54,
+      55,    56,    57,    58,    59,    60,    61,    62,    63,    64,
+      65,    66,    67,    68,    69,    70,    71,    72,    73,    74,
+      75,    76,    77,    78,    79,    80,    81,    82,    83,    84,
+      85,    86,    87,    88,    89,    90,    91,    92,    93,    94,
+      95,    96,    97,    98,    99,   100,   101,   102,   103,   104,
+     105,   106,   107,   108,   109,   110,   111,   112,   113,   114,
+     115,   116,   117,   118,   119,   120,   121,   122,   123,   124,
+     125,   126,   127,   128,   129,   130,   131,   132,   133,   134,
+     135,   136,   137,   138,   139,   140,   141,   142
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const yytype_uint16 yyprhs[] =
+{
+       0,     0,     3,     5,     9,    12,    16,    19,    25,    29,
+      32,    35,    38,    40,    42,    44,    46,    48,    50,    52,
+      55,    57,    59,    61,    63,    65,    67,    69,    71,    73,
+      75,    77,    79,    81,    83,    85,    87,    89,    91,    93,
+      95,    97,    98,   107,   113,   117,   123,   129,   139,   143,
+     146,   149,   155,   158,   164,   167,   172,   174,   176,   184,
+     192,   198,   199,   207,   209,   211,   214,   217,   219,   225,
+     231,   237,   241,   246,   250,   258,   267,   273,   277,   279,
+     281,   285,   287,   292,   300,   307,   309,   311,   319,   329,
+     338,   349,   355,   363,   370,   379,   381,   383,   389,   394,
+     400,   408,   410,   414,   421,   428,   437,   439,   442,   446,
+     448,   451,   455,   462,   468,   478,   481,   483,   485,   487,
+     488,   495,   497,   504,   515,   517,   524,   534,   536,   542,
+     544,   546,   548,   550,   552,   554,   556,   558,   560,   572,
+     586,   594,   596,   598,   600,   601,   605,   607,   610,   613,
+     616,   618,   624,   633,   645,   652,   654,   656,   658,   660,
+     662,   664,   665,   675,   676,   685,   687,   692,   697,   698,
+     705,   709,   714,   716,   718,   720,   722,   724,   726,   728,
+     731,   733,   735,   737,   741,   743,   747,   752,   753,   760,
+     761,   767,   773,   776,   777,   778,   786,   788,   790,   791,
+     795,   797,   799,   801,   803,   805,   807,   809,   811,   815,
+     817,   819,   821,   823,   825,   827,   829,   831,   833,   835,
+     838,   841,   848,   855,   863,   872,   881,   890,   900,   908,
+     914,   917,   920,   923,   926,   928,   930,   932,   934,   936,
+     938,   940,   942,   944,   946,   948,   951,   956,   959,   962,
+     967,   970,   976,   978,   980,   982,   984,   986,   989,   991,
+     993,   996,   999,  1001,  1003,  1005,  1007,  1009,  1011,  1014,
+    1017,  1020,  1023,  1025,  1028,  1031,  1034,  1037,  1039,  1041,
+    1044,  1046,  1050,  1055,  1057,  1060,  1068,  1072,  1074,  1077,
+    1080,  1082,  1085,  1087,  1091,  1093,  1095,  1097,  1100,  1106,
+    1109,  1112,  1114,  1117,  1120,  1122,  1128,  1130,  1132,  1138,
+    1140,  1143,  1147,  1151,  1153,  1156,  1159,  1163,  1168,  1174,
+    1179,  1185,  1192,  1199,  1204,  1210,  1216,  1223,  1231,  1240,
+    1249,  1257,  1265,  1267,  1270,  1274,  1279,  1285,  1289,  1294,
+    1299,  1301,  1304,  1309,  1314,  1319,  1325,  1332,  1338,  1345,
+    1349,  1354,  1359,  1365,  1367,  1370,  1373,  1376,  1380,  1384,
+    1386,  1389,  1392,  1394,  1396,  1399,  1403,  1407,  1412,  1416,
+    1421,  1424,  1428,  1432,  1437,  1443,  1447,  1451,  1454,  1457,
+    1459,  1461,  1464,  1466,  1468,  1470,  1472,  1475,  1477,  1479,
+    1481,  1483,  1486,  1488,  1491,  1495,  1497,  1499,  1501,  1504,
+    1506,  1508,  1511,  1513,  1518,  1520,  1522,  1525,  1527,  1529,
+    1531,  1533,  1535,  1537,  1539,  1541,  1543,  1545,  1547,  1549,
+    1551,  1553,  1554,  1557,  1559,  1561,  1563,  1565,  1567,  1569,
+    1571,  1573,  1576,  1578,  1580,  1582,  1584,  1587,  1590,  1594,
+    1596,  1599,  1603,  1607,  1609,  1612,  1615,  1618,  1622,  1624,
+    1628,  1630,  1632,  1634,  1638,  1642,  1646,  1648,  1650,  1652,
+    1658,  1667,  1669,  1671,  1673,  1675,  1679,  1684,  1690,  1696,
+    1702,  1709,  1716,  1719,  1722,  1725,  1727,  1729,  1731,  1733,
+    1735,  1737,  1739,  1741,  1745,  1749,  1753,  1757,  1761,  1765,
+    1769,  1773,  1777,  1781,  1785,  1789,  1793,  1797,  1801,  1805,
+    1811,  1814,  1817,  1820,  1823,  1826,  1830,  1832,  1834,  1836,
+    1837,  1841,  1843,  1845,  1849,  1850,  1855,  1856,  1863,  1865,
+    1867,  1869,  1871,  1873,  1878,  1883,  1885,  1887,  1889,  1891,
+    1893,  1895,  1897,  1899,  1901,  1903,  1905,  1907,  1910,  1913,
+    1915,  1917,  1922,  1924,  1926,  1932,  1935,  1940,  1942,  1944,
+    1947,  1949,  1951,  1955,  1959,  1964,  1969,  1973,  1978,  1981,
+    1983,  1985,  1989,  1994,  2001,  2004,  2007,  2011,  2013,  2015,
+    2017,  2019,  2021,  2023,  2025,  2027,  2030,  2035,  2037,  2041,
+    2043,  2046,  2050,  2054,  2057,  2060,  2063,  2065,  2068,  2070,
+    2074,  2077,  2082,  2084,  2088,  2090,  2094,  2098,  2101,  2104,
+    2107,  2110,  2112,  2115,  2117,  2119,  2121,  2123,  2127,  2129,
+    2133,  2139,  2141,  2145,  2149,  2155,  2157,  2159
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int16 yyrhs[] =
+{
+     144,     0,    -1,   145,    -1,   121,   240,    43,    -1,   121,
+       1,    -1,   122,   240,    43,    -1,   122,     1,    -1,   123,
+      40,   236,    41,    43,    -1,   123,     1,    43,    -1,   145,
+     146,    -1,   145,   124,    -1,   145,   125,    -1,   325,    -1,
+     147,    -1,   184,    -1,   200,    -1,    43,    -1,     1,    -1,
+     199,    -1,     1,   120,    -1,   148,    -1,   150,    -1,   151,
+      -1,   152,    -1,   153,    -1,   154,    -1,   157,    -1,   158,
+      -1,   161,    -1,   162,    -1,   163,    -1,   164,    -1,   165,
+      -1,   166,    -1,   169,    -1,   171,    -1,   174,    -1,   176,
+      -1,   181,    -1,   182,    -1,   183,    -1,    -1,    66,   322,
+     298,   313,    46,   149,   217,    47,    -1,    98,   180,    46,
+     178,    47,    -1,    99,   178,    43,    -1,    62,   310,    54,
+     265,    43,    -1,    62,   258,   248,   245,    43,    -1,    62,
+     258,   250,    40,   236,    41,   254,   245,    43,    -1,    62,
+       1,    43,    -1,    97,     4,    -1,    97,   319,    -1,    96,
+      40,   310,    41,    46,    -1,    96,    46,    -1,    96,    40,
+     310,    41,    43,    -1,    96,    43,    -1,   319,    46,   240,
+      47,    -1,   319,    -1,   155,    -1,   101,    40,   156,    42,
+     323,    41,     4,    -1,   101,    40,   156,    42,   323,    41,
+      46,    -1,   101,    40,   156,    41,    43,    -1,    -1,   160,
+     322,   319,    59,   159,   145,    60,    -1,     8,    -1,     9,
+      -1,    94,     4,    -1,    94,    46,    -1,     4,    -1,    10,
+      40,   311,    41,   319,    -1,    10,    40,   311,    41,     4,
+      -1,    10,    40,   311,    41,    46,    -1,    56,   322,   311,
+      -1,    63,    40,   311,    41,    -1,    63,    40,    41,    -1,
+      93,    40,   310,    41,   235,   310,    43,    -1,    93,    40,
+     310,    41,   235,   258,   248,    43,    -1,    67,   168,   310,
+      54,   167,    -1,    67,   168,   310,    -1,   319,    -1,     4,
+      -1,    40,   310,    41,    -1,   325,    -1,   170,   248,   311,
+      43,    -1,   170,    40,   323,    41,   248,   304,    43,    -1,
+     170,    40,   323,    41,   319,    43,    -1,    64,    -1,    65,
+      -1,    68,    40,   311,    41,   248,   304,   172,    -1,    68,
+      40,   311,    42,   324,    41,   248,   304,    43,    -1,    68,
+      40,   311,   173,    41,   248,   304,   172,    -1,    68,    40,
+     311,    42,   324,   173,    41,   248,   304,    43,    -1,    68,
+      40,   311,    41,   172,    -1,    68,    40,   311,    42,   324,
+      41,    43,    -1,    68,    40,   311,   173,    41,   172,    -1,
+      68,    40,   311,    42,   324,   173,    41,    43,    -1,   321,
+      -1,    43,    -1,   114,    40,   236,    41,    43,    -1,    42,
+     311,    54,   324,    -1,    42,   311,    54,   324,   173,    -1,
+      69,    40,   175,    41,   248,   304,    43,    -1,   236,    -1,
+      13,    42,   240,    -1,    95,    40,   177,    41,   178,   321,
+      -1,    95,    40,   177,    41,   178,    43,    -1,    95,    40,
+     177,    41,   178,    54,   180,    43,    -1,   323,    -1,   180,
+     179,    -1,    42,   180,   179,    -1,   325,    -1,   258,   247,
+      -1,    40,   236,    41,    -1,    40,   236,    41,    40,   236,
+      41,    -1,   113,    40,   236,    41,   172,    -1,   100,    40,
+     312,    41,   317,   103,   241,   104,    43,    -1,   102,   319,
+      -1,   186,    -1,   198,    -1,   197,    -1,    -1,    44,   319,
+      46,   185,   145,    47,    -1,   190,    -1,    91,   313,    54,
+     258,   247,    43,    -1,   118,   103,   209,   104,    91,   313,
+      54,   258,   247,    43,    -1,   227,    -1,   235,   258,   248,
+     304,   188,   187,    -1,   235,    87,   248,   304,   111,   189,
+     301,   188,   187,    -1,    43,    -1,    42,   248,   304,   188,
+     187,    -1,    46,    -1,     1,    -1,   245,    -1,   262,    -1,
+      32,    -1,    30,    -1,    35,    -1,   313,    -1,   261,    -1,
+     235,    87,   313,    54,   191,    40,   236,    41,   304,   192,
+     193,    -1,   235,    87,   313,    54,   191,    40,   236,    41,
+     304,   111,   258,   192,   193,    -1,   235,    87,   313,    54,
+     191,   192,   193,    -1,    57,    -1,    46,    -1,    43,    -1,
+      -1,    40,   194,    43,    -1,    70,    -1,    70,    71,    -1,
+      70,    52,    -1,    76,   260,    -1,   325,    -1,   235,   195,
+     270,   196,    43,    -1,   235,   195,   270,   196,    46,   274,
+      47,    43,    -1,   235,   195,   270,   196,    46,   274,    47,
+     248,   304,   188,   187,    -1,   235,   258,    40,   236,    41,
+     305,    -1,   201,    -1,   205,    -1,   206,    -1,   213,    -1,
+     214,    -1,   226,    -1,    -1,   235,   296,   313,   287,    46,
+     202,   217,    47,   204,    -1,    -1,   235,   296,   287,    46,
+     203,   217,    47,   204,    -1,    43,    -1,   248,   304,   188,
+     187,    -1,   235,   296,   313,    43,    -1,    -1,   118,   103,
+     209,   104,   207,   208,    -1,   118,   296,   313,    -1,    44,
+     118,   296,   313,    -1,   186,    -1,   201,    -1,   223,    -1,
+     206,    -1,   205,    -1,   225,    -1,   210,    -1,   211,   212,
+      -1,   325,    -1,   295,    -1,   240,    -1,    42,   211,   212,
+      -1,   325,    -1,    91,   313,    43,    -1,    91,    92,   313,
+      43,    -1,    -1,    92,   313,    46,   215,   145,    47,    -1,
+      -1,    92,    46,   216,   145,    47,    -1,    92,   310,    54,
+     313,    43,    -1,   222,   217,    -1,    -1,    -1,    66,    46,
+     218,   217,    47,   219,   217,    -1,   158,    -1,   325,    -1,
+      -1,     1,   220,   217,    -1,   184,    -1,   223,    -1,   224,
+      -1,   228,    -1,   229,    -1,   225,    -1,   205,    -1,   201,
+      -1,   235,   313,    43,    -1,   213,    -1,   206,    -1,   226,
+      -1,   182,    -1,   183,    -1,   232,    -1,   157,    -1,   181,
+      -1,    43,    -1,   221,    -1,   124,   221,    -1,   221,   125,
+      -1,   235,   258,    40,   236,    41,   305,    -1,   140,   315,
+      40,   236,    41,   230,    -1,    78,   140,   315,    40,   236,
+      41,   231,    -1,   235,   120,   258,   253,    40,   236,    41,
+     231,    -1,   235,   120,   258,   131,    40,   236,    41,   231,
+      -1,   235,   120,   258,   128,    40,   236,    41,   231,    -1,
+     235,   120,   258,   253,   131,    40,   236,    41,   231,    -1,
+     235,   120,   258,    40,   236,    41,   231,    -1,    81,    40,
+     236,    41,    46,    -1,    83,    40,    -1,    74,    76,    -1,
+      73,    76,    -1,    75,    76,    -1,   166,    -1,   152,    -1,
+     164,    -1,   169,    -1,   171,    -1,   174,    -1,   162,    -1,
+     176,    -1,   150,    -1,   151,    -1,   153,    -1,   304,    43,
+      -1,   304,    54,   267,    43,    -1,   304,    46,    -1,   304,
+      43,    -1,   304,    54,   265,    43,    -1,   304,    46,    -1,
+     235,   233,    76,   280,    43,    -1,   262,    -1,    32,    -1,
+      30,    -1,    35,    -1,   313,    -1,    44,   319,    -1,    44,
+      -1,   234,    -1,   234,    85,    -1,   234,    21,    -1,    77,
+      -1,    21,    -1,    78,    -1,    79,    -1,    82,    -1,    84,
+      -1,    82,    84,    -1,    84,    82,    -1,    77,    84,    -1,
+      84,    77,    -1,    85,    -1,    85,    77,    -1,    77,    85,
+      -1,    44,    85,    -1,    85,    44,    -1,   325,    -1,   237,
+      -1,   240,   238,    -1,   325,    -1,    42,   240,   238,    -1,
+      42,   125,   240,   238,    -1,   325,    -1,   259,   246,    -1,
+     118,   103,   296,   104,   296,   313,   245,    -1,    48,    48,
+      48,    -1,   239,    -1,   124,   239,    -1,   239,   125,    -1,
+     242,    -1,   244,   243,    -1,   325,    -1,    42,   244,   243,
+      -1,   325,    -1,   240,    -1,   282,    -1,    54,   265,    -1,
+      54,   265,    57,   280,    58,    -1,    54,    46,    -1,    76,
+     280,    -1,   325,    -1,   248,   245,    -1,   251,   245,    -1,
+     245,    -1,   250,    40,   236,    41,   254,    -1,   248,    -1,
+     251,    -1,   250,    40,   236,    41,   254,    -1,   325,    -1,
+     253,   249,    -1,   253,   131,   249,    -1,   253,   128,   249,
+      -1,   250,    -1,   131,   249,    -1,   128,   249,    -1,   313,
+     116,   249,    -1,   253,   313,   116,   249,    -1,   253,   313,
+     116,   131,   249,    -1,   313,   116,   131,   249,    -1,   253,
+      48,    48,    48,   249,    -1,   253,   131,    48,    48,    48,
+     249,    -1,   253,   128,    48,    48,    48,   249,    -1,    48,
+      48,    48,   250,    -1,   131,    48,    48,    48,   249,    -1,
+     128,    48,    48,    48,   249,    -1,   313,   116,    48,    48,
+      48,   249,    -1,   253,   313,   116,    48,    48,    48,   249,
+      -1,   253,   313,   116,   131,    48,    48,    48,   249,    -1,
+     253,   313,   116,   128,    48,    48,    48,   249,    -1,   313,
+     116,   131,    48,    48,    48,   249,    -1,   313,   116,   128,
+      48,    48,    48,   249,    -1,   313,    -1,   140,   313,    -1,
+      40,   313,    41,    -1,    40,   253,   249,    41,    -1,    40,
+     313,   116,   249,    41,    -1,   249,    57,    58,    -1,   249,
+      57,   280,    58,    -1,   249,    40,   236,    41,    -1,   313,
+      -1,   140,   313,    -1,    40,   253,   250,    41,    -1,    40,
+     131,   250,    41,    -1,    40,   128,   250,    41,    -1,    40,
+     313,   116,   248,    41,    -1,    40,   313,   116,   256,   248,
+      41,    -1,    40,   313,   116,   251,    41,    -1,    40,   313,
+     116,   256,   251,    41,    -1,   250,    57,    58,    -1,   250,
+      57,   280,    58,    -1,   250,    40,   236,    41,    -1,   119,
+       3,    40,   236,    41,    -1,   253,    -1,   253,   252,    -1,
+     253,   131,    -1,   253,   128,    -1,   253,   131,   252,    -1,
+     253,   128,   252,    -1,   252,    -1,   131,   252,    -1,   128,
+     252,    -1,   131,    -1,   128,    -1,   313,   116,    -1,   313,
+     116,   256,    -1,   253,   313,   116,    -1,   253,   313,   116,
+     252,    -1,   252,    57,    58,    -1,   252,    57,   280,    58,
+      -1,    57,    58,    -1,    57,   280,    58,    -1,    40,   251,
+      41,    -1,   252,    40,   236,    41,    -1,   252,    40,   236,
+      41,   254,    -1,    40,   236,    41,    -1,   138,   256,   253,
+      -1,   138,   253,    -1,   138,   256,    -1,   138,    -1,   256,
+      -1,   256,   255,    -1,   255,    -1,   131,    -1,   128,    -1,
+     257,    -1,   257,   256,    -1,    49,    -1,    50,    -1,    51,
+      -1,   259,    -1,   256,   260,    -1,   260,    -1,   260,   256,
+      -1,   256,   260,   256,    -1,   262,    -1,    32,    -1,    30,
+      -1,   195,   313,    -1,    35,    -1,   313,    -1,   296,   313,
+      -1,   261,    -1,    86,    40,   313,    41,    -1,   263,    -1,
+     264,    -1,   264,   263,    -1,    22,    -1,    24,    -1,    25,
+      -1,    28,    -1,    29,    -1,    26,    -1,    27,    -1,    31,
+      -1,    23,    -1,    33,    -1,    36,    -1,    37,    -1,    38,
+      -1,    39,    -1,    -1,   266,   280,    -1,   267,    -1,   268,
+      -1,   269,    -1,   105,    -1,   106,    -1,   310,    -1,   325,
+      -1,   152,    -1,   152,   271,    -1,   271,    -1,   325,    -1,
+     325,    -1,    42,    -1,    42,   152,    -1,   276,   273,    -1,
+     276,   275,   273,    -1,   272,    -1,    42,   276,    -1,   275,
+      42,   276,    -1,   272,   277,   272,    -1,   278,    -1,   124,
+     278,    -1,   278,   125,    -1,   125,   278,    -1,   125,   278,
+     125,    -1,   310,    -1,   310,    54,   279,    -1,   280,    -1,
+     282,    -1,   258,    -1,     3,   111,     3,    -1,   281,   111,
+       3,    -1,   281,    48,     3,    -1,   283,    -1,   281,    -1,
+     319,    -1,    55,    40,   258,   246,    41,    -1,    55,    48,
+      48,    48,    40,   258,   246,    41,    -1,   284,    -1,   320,
+      -1,    11,    -1,    12,    -1,    40,   280,    41,    -1,    40,
+     280,    41,   280,    -1,    40,   280,   253,    41,   280,    -1,
+      40,   280,   131,    41,   280,    -1,    40,   280,   128,    41,
+     280,    -1,    40,   280,   253,   131,    41,   280,    -1,    40,
+     280,   253,   128,    41,   280,    -1,   131,   280,    -1,   128,
+     280,    -1,   138,   280,    -1,    13,    -1,    14,    -1,    15,
+      -1,    16,    -1,    17,    -1,    18,    -1,    19,    -1,    20,
+      -1,   280,   135,   280,    -1,   280,   134,   280,    -1,   280,
+     138,   280,    -1,   280,   137,   280,    -1,   280,   136,   280,
+      -1,   280,   131,   280,    -1,   280,   129,   280,    -1,   280,
+     130,   280,    -1,   280,   133,   280,    -1,   280,   132,   280,
+      -1,   280,   128,   280,    -1,   280,   127,   280,    -1,   280,
+     109,   280,    -1,   280,   110,   280,    -1,   280,   108,   280,
+      -1,   280,   107,   280,    -1,   280,   112,   280,    76,   280,
+      -1,   134,   280,    -1,   135,   280,    -1,   140,   280,    -1,
+     139,   280,    -1,   258,    40,    -1,    48,    48,    48,    -1,
+     285,    -1,   325,    -1,   288,    -1,    -1,    76,   289,   290,
+      -1,   325,    -1,   291,    -1,   290,    42,   291,    -1,    -1,
+     299,   292,   313,   286,    -1,    -1,   299,   294,   293,   299,
+     313,   286,    -1,    74,    -1,    73,    -1,    75,    -1,    71,
+      -1,    72,    -1,    71,    48,    48,    48,    -1,    72,    48,
+      48,    48,    -1,   295,    -1,    52,    -1,    53,    -1,    71,
+      -1,    52,    -1,    53,    -1,   297,    -1,   325,    -1,    78,
+      -1,   325,    -1,    89,    -1,    90,    -1,    90,    89,    -1,
+      89,    90,    -1,   300,    -1,   325,    -1,    80,    40,   236,
+      41,    -1,    88,    -1,   300,    -1,    80,    40,   236,    41,
+     300,    -1,    88,   300,    -1,    88,    40,   280,    41,    -1,
+     254,    -1,   302,    -1,   254,   302,    -1,   303,    -1,   325,
+      -1,   304,   306,    43,    -1,   304,   306,    46,    -1,    40,
+     236,    41,    43,    -1,    40,   236,    41,    46,    -1,    54,
+     265,    43,    -1,   302,    54,   267,    43,    -1,    76,   307,
+      -1,   325,    -1,   308,    -1,   307,    42,   308,    -1,   308,
+      48,    48,    48,    -1,   307,    42,   308,    48,    48,    48,
+      -1,   313,    40,    -1,   313,    46,    -1,   103,   241,   104,
+      -1,     3,    -1,    89,    -1,    90,    -1,   310,    -1,   267,
+      -1,   319,    -1,   311,    -1,   325,    -1,   315,   314,    -1,
+     115,   142,   316,   314,    -1,   315,    -1,   115,   142,   316,
+      -1,   119,    -1,   119,   309,    -1,   115,   142,   119,    -1,
+     142,   316,   314,    -1,   142,   316,    -1,   142,   119,    -1,
+     117,   315,    -1,   310,    -1,   310,   309,    -1,   315,    -1,
+     118,   310,   309,    -1,   310,   318,    -1,   115,   142,   310,
+     318,    -1,   310,    -1,   115,   142,   310,    -1,   119,    -1,
+     115,   142,   119,    -1,   142,   310,   318,    -1,   142,   310,
+      -1,   142,   119,    -1,   117,   310,    -1,   319,     6,    -1,
+       6,    -1,   320,     7,    -1,     7,    -1,   319,    -1,    46,
+      -1,     4,    -1,    40,   323,    41,    -1,   325,    -1,   311,
+      54,   324,    -1,   311,    54,   324,    42,   323,    -1,   311,
+      -1,   311,    42,   323,    -1,   311,    54,   155,    -1,   311,
+      54,   155,    42,   323,    -1,   319,    -1,   283,    -1,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const yytype_uint16 yyrline[] =
+{
+       0,  1713,  1713,  1725,  1729,  1732,  1735,  1738,  1741,  1746,
+    1755,  1759,  1766,  1771,  1772,  1773,  1774,  1775,  1785,  1801,
+    1811,  1812,  1813,  1814,  1815,  1816,  1817,  1818,  1819,  1820,
+    1821,  1822,  1823,  1824,  1825,  1826,  1827,  1828,  1829,  1830,
+    1831,  1838,  1838,  1920,  1930,  1941,  1961,  1985,  2009,  2020,
+    2029,  2048,  2054,  2060,  2065,  2072,  2079,  2083,  2096,  2105,
+    2120,  2133,  2133,  2189,  2190,  2197,  2216,  2247,  2251,  2261,
+    2266,  2284,  2327,  2333,  2346,  2352,  2378,  2384,  2391,  2392,
+    2395,  2396,  2403,  2449,  2495,  2506,  2509,  2536,  2542,  2548,
+    2554,  2562,  2568,  2574,  2580,  2588,  2589,  2590,  2593,  2598,
+    2608,  2644,  2645,  2680,  2697,  2705,  2718,  2743,  2749,  2753,
+    2756,  2767,  2772,  2785,  2797,  3095,  3105,  3112,  3113,  3117,
+    3117,  3142,  3148,  3158,  3170,  3179,  3259,  3322,  3326,  3351,
+    3355,  3366,  3371,  3372,  3373,  3377,  3378,  3379,  3390,  3395,
+    3400,  3407,  3413,  3418,  3421,  3421,  3434,  3437,  3440,  3449,
+    3452,  3459,  3481,  3510,  3608,  3661,  3662,  3663,  3664,  3665,
+    3666,  3671,  3671,  3920,  3920,  4067,  4068,  4080,  4098,  4098,
+    4359,  4365,  4371,  4374,  4377,  4380,  4383,  4386,  4391,  4427,
+    4431,  4434,  4437,  4442,  4446,  4451,  4461,  4492,  4492,  4550,
+    4550,  4572,  4599,  4616,  4621,  4616,  4629,  4630,  4631,  4631,
+    4647,  4648,  4665,  4666,  4667,  4668,  4669,  4670,  4671,  4672,
+    4673,  4674,  4675,  4676,  4677,  4678,  4679,  4680,  4682,  4685,
+    4689,  4701,  4730,  4760,  4793,  4809,  4827,  4846,  4866,  4886,
+    4894,  4901,  4908,  4916,  4924,  4927,  4931,  4934,  4935,  4936,
+    4937,  4938,  4939,  4940,  4941,  4944,  4955,  4966,  4979,  4990,
+    5001,  5015,  5018,  5021,  5022,  5026,  5028,  5036,  5048,  5049,
+    5050,  5051,  5052,  5053,  5054,  5055,  5056,  5057,  5058,  5059,
+    5060,  5061,  5062,  5063,  5064,  5065,  5066,  5067,  5074,  5085,
+    5089,  5096,  5100,  5105,  5109,  5121,  5131,  5141,  5144,  5148,
+    5154,  5167,  5171,  5174,  5178,  5182,  5210,  5218,  5231,  5247,
+    5258,  5268,  5280,  5284,  5288,  5295,  5317,  5334,  5353,  5372,
+    5379,  5387,  5396,  5405,  5409,  5418,  5429,  5440,  5452,  5462,
+    5476,  5484,  5493,  5502,  5506,  5515,  5526,  5537,  5549,  5559,
+    5569,  5580,  5593,  5600,  5608,  5624,  5632,  5643,  5654,  5665,
+    5684,  5692,  5709,  5717,  5724,  5731,  5742,  5754,  5765,  5777,
+    5788,  5799,  5819,  5840,  5846,  5852,  5859,  5866,  5875,  5884,
+    5887,  5896,  5905,  5912,  5919,  5926,  5934,  5944,  5955,  5966,
+    5977,  5984,  5991,  5994,  6011,  6029,  6039,  6046,  6052,  6057,
+    6064,  6068,  6073,  6080,  6084,  6090,  6094,  6100,  6101,  6102,
+    6108,  6114,  6118,  6119,  6123,  6130,  6133,  6134,  6138,  6139,
+    6141,  6144,  6147,  6152,  6163,  6188,  6191,  6245,  6249,  6253,
+    6257,  6261,  6265,  6269,  6273,  6277,  6281,  6285,  6289,  6293,
+    6297,  6303,  6303,  6319,  6324,  6327,  6333,  6348,  6364,  6365,
+    6368,  6369,  6373,  6374,  6378,  6379,  6380,  6384,  6388,  6394,
+    6399,  6403,  6410,  6415,  6418,  6422,  6426,  6430,  6437,  6445,
+    6457,  6472,  6473,  6493,  6497,  6507,  6513,  6516,  6519,  6523,
+    6528,  6533,  6534,  6539,  6553,  6569,  6579,  6597,  6604,  6611,
+    6618,  6626,  6634,  6638,  6642,  6648,  6649,  6650,  6651,  6652,
+    6653,  6654,  6655,  6658,  6662,  6666,  6670,  6674,  6678,  6682,
+    6686,  6690,  6694,  6698,  6702,  6706,  6710,  6724,  6728,  6732,
+    6738,  6742,  6746,  6750,  6754,  6770,  6775,  6778,  6783,  6788,
+    6788,  6789,  6792,  6809,  6818,  6818,  6836,  6836,  6854,  6855,
+    6856,  6859,  6863,  6867,  6871,  6877,  6880,  6884,  6890,  6894,
+    6898,  6904,  6907,  6912,  6913,  6916,  6919,  6922,  6925,  6930,
+    6933,  6938,  6944,  6950,  6956,  6962,  6968,  6976,  6984,  6989,
+    6996,  6999,  7009,  7020,  7031,  7041,  7051,  7059,  7071,  7072,
+    7075,  7076,  7077,  7078,  7081,  7093,  7099,  7108,  7109,  7110,
+    7113,  7114,  7115,  7118,  7119,  7122,  7127,  7131,  7134,  7137,
+    7140,  7143,  7148,  7152,  7155,  7162,  7168,  7171,  7176,  7179,
+    7185,  7190,  7194,  7197,  7200,  7203,  7208,  7212,  7215,  7218,
+    7224,  7227,  7230,  7238,  7241,  7244,  7248,  7253,  7266,  7270,
+    7275,  7281,  7285,  7290,  7294,  7301,  7304,  7309
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "ID", "HBLOCK", "POUND", "STRING",
+  "WSTRING", "INCLUDE", "IMPORT", "INSERT", "CHARCONST", "WCHARCONST",
+  "NUM_INT", "NUM_FLOAT", "NUM_UNSIGNED", "NUM_LONG", "NUM_ULONG",
+  "NUM_LONGLONG", "NUM_ULONGLONG", "NUM_BOOL", "TYPEDEF", "TYPE_INT",
+  "TYPE_UNSIGNED", "TYPE_SHORT", "TYPE_LONG", "TYPE_FLOAT", "TYPE_DOUBLE",
+  "TYPE_CHAR", "TYPE_WCHAR", "TYPE_VOID", "TYPE_SIGNED", "TYPE_BOOL",
+  "TYPE_COMPLEX", "TYPE_TYPEDEF", "TYPE_RAW", "TYPE_NON_ISO_INT8",
+  "TYPE_NON_ISO_INT16", "TYPE_NON_ISO_INT32", "TYPE_NON_ISO_INT64",
+  "LPAREN", "RPAREN", "COMMA", "SEMI", "EXTERN", "INIT", "LBRACE",
+  "RBRACE", "PERIOD", "CONST_QUAL", "VOLATILE", "REGISTER", "STRUCT",
+  "UNION", "EQUAL", "SIZEOF", "MODULE", "LBRACKET", "RBRACKET",
+  "BEGINFILE", "ENDOFFILE", "ILLEGAL", "CONSTANT", "NAME", "RENAME",
+  "NAMEWARN", "EXTEND", "PRAGMA", "FEATURE", "VARARGS", "ENUM", "CLASS",
+  "TYPENAME", "PRIVATE", "PUBLIC", "PROTECTED", "COLON", "STATIC",
+  "VIRTUAL", "FRIEND", "THROW", "CATCH", "EXPLICIT", "STATIC_ASSERT",
+  "CONSTEXPR", "THREAD_LOCAL", "DECLTYPE", "AUTO", "NOEXCEPT", "OVERRIDE",
+  "FINAL", "USING", "NAMESPACE", "NATIVE", "INLINE", "TYPEMAP", "EXCEPT",
+  "ECHO", "APPLY", "CLEAR", "SWIGTEMPLATE", "FRAGMENT", "WARN", "LESSTHAN",
+  "GREATERTHAN", "DELETE_KW", "DEFAULT", "LESSTHANOREQUALTO",
+  "GREATERTHANOREQUALTO", "EQUALTO", "NOTEQUALTO", "ARROW", "QUESTIONMARK",
+  "TYPES", "PARMS", "NONID", "DSTAR", "DCNOT", "TEMPLATE", "OPERATOR",
+  "CONVERSIONOPERATOR", "PARSETYPE", "PARSEPARM", "PARSEPARMS",
+  "DOXYGENSTRING", "DOXYGENPOSTSTRING", "CAST", "LOR", "LAND", "OR", "XOR",
+  "AND", "RSHIFT", "LSHIFT", "MINUS", "PLUS", "MODULO", "SLASH", "STAR",
+  "LNOT", "NOT", "UMINUS", "DCOLON", "$accept", "program", "interface",
+  "declaration", "swig_directive", "extend_directive", "@1",
+  "apply_directive", "clear_directive", "constant_directive",
+  "echo_directive", "except_directive", "stringtype", "fname",
+  "fragment_directive", "include_directive", "@2", "includetype",
+  "inline_directive", "insert_directive", "module_directive",
+  "name_directive", "native_directive", "pragma_directive", "pragma_arg",
+  "pragma_lang", "rename_directive", "rename_namewarn",
+  "feature_directive", "stringbracesemi", "featattr", "varargs_directive",
+  "varargs_parms", "typemap_directive", "typemap_type", "tm_list",
+  "tm_tail", "typemap_parm", "types_directive", "template_directive",
+  "warn_directive", "c_declaration", "@3", "c_decl", "c_decl_tail",
+  "initializer", "cpp_alternate_rettype", "cpp_lambda_decl",
+  "lambda_introducer", "lambda_body", "lambda_tail", "@4", "c_enum_key",
+  "c_enum_inherit", "c_enum_forward_decl", "c_enum_decl",
+  "c_constructor_decl", "cpp_declaration", "cpp_class_decl", "@5", "@6",
+  "cpp_opt_declarators", "cpp_forward_class_decl", "cpp_template_decl",
+  "@7", "cpp_template_possible", "template_parms", "templateparameters",
+  "templateparameter", "templateparameterstail", "cpp_using_decl",
+  "cpp_namespace_decl", "@8", "@9", "cpp_members", "@10", "@11", "@12",
+  "cpp_member_no_dox", "cpp_member", "cpp_constructor_decl",
+  "cpp_destructor_decl", "cpp_conversion_operator", "cpp_catch_decl",
+  "cpp_static_assert", "cpp_protection_decl", "cpp_swig_directive",
+  "cpp_end", "cpp_vend", "anonymous_bitfield", "anon_bitfield_type",
+  "extern_string", "storage_class", "parms", "rawparms", "ptail",
+  "parm_no_dox", "parm", "valparms", "rawvalparms", "valptail", "valparm",
+  "def_args", "parameter_declarator", "plain_declarator", "declarator",
+  "notso_direct_declarator", "direct_declarator", "abstract_declarator",
+  "direct_abstract_declarator", "pointer", "cv_ref_qualifier",
+  "ref_qualifier", "type_qualifier", "type_qualifier_raw", "type",
+  "rawtype", "type_right", "decltype", "primitive_type",
+  "primitive_type_list", "type_specifier", "definetype", "@13",
+  "default_delete", "deleted_definition", "explicit_default", "ename",
+  "constant_directives", "optional_ignored_defines",
+  "optional_ignored_define_after_comma", "enumlist", "enumlist_tail",
+  "enumlist_item", "edecl_with_dox", "edecl", "etype", "expr", "exprmem",
+  "valexpr", "exprnum", "exprcompound", "ellipsis", "variadic", "inherit",
+  "raw_inherit", "@14", "base_list", "base_specifier", "@15", "@16",
+  "access_specifier", "templcpptype", "cpptype", "classkey", "classkeyopt",
+  "opt_virtual", "virt_specifier_seq", "virt_specifier_seq_opt",
+  "exception_specification", "qualifiers_exception_specification",
+  "cpp_const", "ctor_end", "ctor_initializer", "mem_initializer_list",
+  "mem_initializer", "less_valparms_greater", "identifier", "idstring",
+  "idstringopt", "idcolon", "idcolontail", "idtemplate",
+  "idtemplatetemplate", "idcolonnt", "idcolontailnt", "string", "wstring",
+  "stringbrace", "options", "kwargs", "stringnum", "empty", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const yytype_uint16 yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
+     295,   296,   297,   298,   299,   300,   301,   302,   303,   304,
+     305,   306,   307,   308,   309,   310,   311,   312,   313,   314,
+     315,   316,   317,   318,   319,   320,   321,   322,   323,   324,
+     325,   326,   327,   328,   329,   330,   331,   332,   333,   334,
+     335,   336,   337,   338,   339,   340,   341,   342,   343,   344,
+     345,   346,   347,   348,   349,   350,   351,   352,   353,   354,
+     355,   356,   357,   358,   359,   360,   361,   362,   363,   364,
+     365,   366,   367,   368,   369,   370,   371,   372,   373,   374,
+     375,   376,   377,   378,   379,   380,   381,   382,   383,   384,
+     385,   386,   387,   388,   389,   390,   391,   392,   393,   394,
+     395,   396,   397
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const yytype_uint16 yyr1[] =
+{
+       0,   143,   144,   144,   144,   144,   144,   144,   144,   145,
+     145,   145,   145,   146,   146,   146,   146,   146,   146,   146,
+     147,   147,   147,   147,   147,   147,   147,   147,   147,   147,
+     147,   147,   147,   147,   147,   147,   147,   147,   147,   147,
+     147,   149,   148,   150,   151,   152,   152,   152,   152,   153,
+     153,   154,   154,   154,   154,   155,   156,   156,   157,   157,
+     157,   159,   158,   160,   160,   161,   161,   162,   162,   162,
+     162,   163,   164,   164,   165,   165,   166,   166,   167,   167,
+     168,   168,   169,   169,   169,   170,   170,   171,   171,   171,
+     171,   171,   171,   171,   171,   172,   172,   172,   173,   173,
+     174,   175,   175,   176,   176,   176,   177,   178,   179,   179,
+     180,   180,   180,   181,   182,   183,   184,   184,   184,   185,
+     184,   184,   184,   184,   184,   186,   186,   187,   187,   187,
+     187,   188,   189,   189,   189,   189,   189,   189,   190,   190,
+     190,   191,   192,   193,   194,   193,   195,   195,   195,   196,
+     196,   197,   198,   198,   199,   200,   200,   200,   200,   200,
+     200,   202,   201,   203,   201,   204,   204,   205,   207,   206,
+     206,   206,   208,   208,   208,   208,   208,   208,   209,   210,
+     210,   211,   211,   212,   212,   213,   213,   215,   214,   216,
+     214,   214,   217,   218,   219,   217,   217,   217,   220,   217,
+     221,   221,   221,   221,   221,   221,   221,   221,   221,   221,
+     221,   221,   221,   221,   221,   221,   221,   221,   222,   222,
+     222,   223,   224,   224,   225,   225,   225,   225,   225,   226,
+     227,   228,   228,   228,   229,   229,   229,   229,   229,   229,
+     229,   229,   229,   229,   229,   230,   230,   230,   231,   231,
+     231,   232,   233,   233,   233,   233,   233,   234,   235,   235,
+     235,   235,   235,   235,   235,   235,   235,   235,   235,   235,
+     235,   235,   235,   235,   235,   235,   235,   235,   236,   237,
+     237,   238,   238,   238,   239,   239,   239,   240,   240,   240,
+     241,   242,   242,   243,   243,   244,   244,   245,   245,   245,
+     245,   245,   246,   246,   246,   246,   247,   247,   247,   247,
+     248,   248,   248,   248,   248,   248,   248,   248,   248,   248,
+     248,   248,   248,   248,   248,   248,   248,   248,   248,   248,
+     248,   248,   249,   249,   249,   249,   249,   249,   249,   249,
+     250,   250,   250,   250,   250,   250,   250,   250,   250,   250,
+     250,   250,   250,   251,   251,   251,   251,   251,   251,   251,
+     251,   251,   251,   251,   251,   251,   251,   251,   252,   252,
+     252,   252,   252,   252,   252,   252,   253,   253,   253,   253,
+     254,   254,   254,   255,   255,   256,   256,   257,   257,   257,
+     258,   259,   259,   259,   259,   260,   260,   260,   260,   260,
+     260,   260,   260,   261,   262,   263,   263,   264,   264,   264,
+     264,   264,   264,   264,   264,   264,   264,   264,   264,   264,
+     264,   266,   265,   265,   267,   267,   268,   269,   270,   270,
+     271,   271,   272,   272,   273,   273,   273,   274,   274,   274,
+     275,   275,   276,   277,   277,   277,   277,   277,   278,   278,
+     279,   280,   280,   281,   281,   281,   282,   282,   282,   282,
+     282,   282,   282,   282,   282,   282,   282,   282,   282,   282,
+     282,   282,   282,   282,   282,   283,   283,   283,   283,   283,
+     283,   283,   283,   284,   284,   284,   284,   284,   284,   284,
+     284,   284,   284,   284,   284,   284,   284,   284,   284,   284,
+     284,   284,   284,   284,   284,   285,   286,   286,   287,   289,
+     288,   288,   290,   290,   292,   291,   293,   291,   294,   294,
+     294,   295,   295,   295,   295,   296,   296,   296,   297,   297,
+     297,   298,   298,   299,   299,   300,   300,   300,   300,   301,
+     301,   302,   302,   302,   302,   302,   302,   303,   303,   303,
+     304,   304,   305,   305,   305,   305,   305,   305,   306,   306,
+     307,   307,   307,   307,   308,   308,   309,   310,   310,   310,
+     311,   311,   311,   312,   312,   313,   313,   313,   313,   313,
+     313,   313,   314,   314,   314,   314,   315,   315,   316,   316,
+     317,   317,   317,   317,   317,   317,   318,   318,   318,   318,
+     319,   319,   320,   320,   321,   321,   321,   322,   322,   323,
+     323,   323,   323,   323,   323,   324,   324,   325
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const yytype_uint8 yyr2[] =
+{
+       0,     2,     1,     3,     2,     3,     2,     5,     3,     2,
+       2,     2,     1,     1,     1,     1,     1,     1,     1,     2,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     0,     8,     5,     3,     5,     5,     9,     3,     2,
+       2,     5,     2,     5,     2,     4,     1,     1,     7,     7,
+       5,     0,     7,     1,     1,     2,     2,     1,     5,     5,
+       5,     3,     4,     3,     7,     8,     5,     3,     1,     1,
+       3,     1,     4,     7,     6,     1,     1,     7,     9,     8,
+      10,     5,     7,     6,     8,     1,     1,     5,     4,     5,
+       7,     1,     3,     6,     6,     8,     1,     2,     3,     1,
+       2,     3,     6,     5,     9,     2,     1,     1,     1,     0,
+       6,     1,     6,    10,     1,     6,     9,     1,     5,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,    11,    13,
+       7,     1,     1,     1,     0,     3,     1,     2,     2,     2,
+       1,     5,     8,    11,     6,     1,     1,     1,     1,     1,
+       1,     0,     9,     0,     8,     1,     4,     4,     0,     6,
+       3,     4,     1,     1,     1,     1,     1,     1,     1,     2,
+       1,     1,     1,     3,     1,     3,     4,     0,     6,     0,
+       5,     5,     2,     0,     0,     7,     1,     1,     0,     3,
+       1,     1,     1,     1,     1,     1,     1,     1,     3,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     2,
+       2,     6,     6,     7,     8,     8,     8,     9,     7,     5,
+       2,     2,     2,     2,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     2,     4,     2,     2,     4,
+       2,     5,     1,     1,     1,     1,     1,     2,     1,     1,
+       2,     2,     1,     1,     1,     1,     1,     1,     2,     2,
+       2,     2,     1,     2,     2,     2,     2,     1,     1,     2,
+       1,     3,     4,     1,     2,     7,     3,     1,     2,     2,
+       1,     2,     1,     3,     1,     1,     1,     2,     5,     2,
+       2,     1,     2,     2,     1,     5,     1,     1,     5,     1,
+       2,     3,     3,     1,     2,     2,     3,     4,     5,     4,
+       5,     6,     6,     4,     5,     5,     6,     7,     8,     8,
+       7,     7,     1,     2,     3,     4,     5,     3,     4,     4,
+       1,     2,     4,     4,     4,     5,     6,     5,     6,     3,
+       4,     4,     5,     1,     2,     2,     2,     3,     3,     1,
+       2,     2,     1,     1,     2,     3,     3,     4,     3,     4,
+       2,     3,     3,     4,     5,     3,     3,     2,     2,     1,
+       1,     2,     1,     1,     1,     1,     2,     1,     1,     1,
+       1,     2,     1,     2,     3,     1,     1,     1,     2,     1,
+       1,     2,     1,     4,     1,     1,     2,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     0,     2,     1,     1,     1,     1,     1,     1,     1,
+       1,     2,     1,     1,     1,     1,     2,     2,     3,     1,
+       2,     3,     3,     1,     2,     2,     2,     3,     1,     3,
+       1,     1,     1,     3,     3,     3,     1,     1,     1,     5,
+       8,     1,     1,     1,     1,     3,     4,     5,     5,     5,
+       6,     6,     2,     2,     2,     1,     1,     1,     1,     1,
+       1,     1,     1,     3,     3,     3,     3,     3,     3,     3,
+       3,     3,     3,     3,     3,     3,     3,     3,     3,     5,
+       2,     2,     2,     2,     2,     3,     1,     1,     1,     0,
+       3,     1,     1,     3,     0,     4,     0,     6,     1,     1,
+       1,     1,     1,     4,     4,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     1,     1,     2,     2,     1,
+       1,     4,     1,     1,     5,     2,     4,     1,     1,     2,
+       1,     1,     3,     3,     4,     4,     3,     4,     2,     1,
+       1,     3,     4,     6,     2,     2,     3,     1,     1,     1,
+       1,     1,     1,     1,     1,     2,     4,     1,     3,     1,
+       2,     3,     3,     2,     2,     2,     1,     2,     1,     3,
+       2,     4,     1,     3,     1,     3,     3,     2,     2,     2,
+       2,     1,     2,     1,     1,     1,     1,     3,     1,     3,
+       5,     1,     3,     3,     5,     1,     1,     0
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const yytype_uint16 yydefact[] =
+{
+     617,     0,     0,     0,     0,     0,    12,     4,   567,   407,
+     415,   408,   409,   412,   413,   410,   411,   397,   414,   396,
+     416,   399,   417,   418,   419,   420,     0,   387,   388,   389,
+     526,   527,   146,   521,   522,     0,   568,   569,     0,     0,
+     579,     0,     0,   287,     0,     0,   385,   617,   392,   402,
+     395,   404,   405,   525,     0,   586,   400,   577,     6,     0,
+       0,   617,     1,    17,    67,    63,    64,     0,   263,    16,
+     258,   617,     0,     0,    85,    86,   617,   617,     0,     0,
+     262,   264,   265,     0,   266,     0,   267,   272,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,    10,    11,     9,    13,    20,    21,    22,    23,
+      24,    25,    26,    27,   617,    28,    29,    30,    31,    32,
+      33,    34,     0,    35,    36,    37,    38,    39,    40,    14,
+     116,   121,   118,   117,    18,    15,   155,   156,   157,   158,
+     159,   160,   124,   259,     0,   277,     0,   148,   147,     0,
+       0,     0,     0,     0,   617,   580,   288,   398,   289,     3,
+     391,   386,   617,     0,   421,     0,     0,   579,   363,   362,
+     379,     0,   304,   284,   617,   313,   617,   359,   353,   340,
+     301,   393,   406,   401,   587,     0,     0,   575,     5,     8,
+       0,   278,   617,   280,    19,     0,   601,   275,     0,   257,
+       0,     0,   608,     0,     0,   390,   586,     0,   617,     0,
+       0,    81,     0,   617,   270,   274,   617,   268,   230,   271,
+     269,   276,   273,     0,     0,   189,   586,     0,     0,    65,
+      66,     0,     0,    54,    52,    49,    50,   617,     0,   617,
+       0,   617,   617,     0,   115,   617,   617,     0,     0,     0,
+       0,     0,     0,   313,     0,   340,   261,   260,     0,   617,
+       0,   617,   286,     0,     0,     0,     0,   581,   588,   578,
+       0,   567,   603,   463,   464,   475,   476,   477,   478,   479,
+     480,   481,   482,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,   295,     0,   290,   617,   452,   390,     0,   457,
+     451,   456,   461,   458,   462,   292,   394,   617,   363,   362,
+       0,     0,   353,   400,     0,   299,   426,   427,   297,     0,
+     423,   424,   425,   370,     0,   451,   300,     0,   617,     0,
+       0,   315,   361,   332,     0,   314,   360,   377,   378,   341,
+     302,   617,     0,   303,   617,     0,     0,   356,   355,   310,
+     354,   332,   364,   585,   584,   583,     0,     0,   279,   283,
+     571,   570,     0,   572,     0,   600,   119,   611,     0,    71,
+      48,     0,   617,   313,   421,    73,     0,   529,   530,   528,
+     531,     0,   532,     0,    77,     0,     0,     0,   101,     0,
+       0,   185,     0,   617,     0,   187,     0,     0,   106,     0,
+       0,     0,   110,   306,   313,   307,   309,    44,     0,   107,
+     109,   573,     0,   574,    57,     0,    56,     0,     0,   178,
+     617,   182,   525,   180,   170,     0,     0,     0,     0,   570,
+       0,     0,     0,     0,   617,     0,     0,   332,     0,   617,
+     340,   617,   586,   429,   617,   617,   509,     0,   508,   401,
+     511,   523,   524,   403,     0,   576,     0,     0,     0,     0,
+       0,   473,   472,   500,   501,   474,   503,   502,   566,     0,
+     291,   294,   504,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,   602,   363,   362,   353,   400,     0,   340,     0,
+     375,   372,   356,   355,     0,   340,   364,     0,     0,   422,
+     371,   617,   353,   400,     0,   333,   617,     0,     0,   376,
+       0,   349,     0,     0,   368,     0,     0,     0,   312,   358,
+       0,   311,   357,   366,     0,     0,     0,   316,   365,   582,
+       7,     0,   617,     0,   171,   617,     0,     0,   607,     0,
+     617,     0,    72,     0,    80,     0,     0,     0,     0,     0,
+       0,     0,   186,   617,     0,     0,   617,   617,     0,     0,
+     111,     0,   617,   617,     0,     0,     0,     0,     0,   168,
+       0,   179,   184,    61,     0,     0,     0,     0,    82,     0,
+       0,     0,   542,   535,   536,   384,   383,   547,   382,   380,
+     543,   548,   550,     0,   551,     0,     0,     0,   150,     0,
+     400,   617,   617,   163,   167,     0,   589,     0,   453,   465,
+       0,     0,   379,     0,   617,     0,   617,   498,   497,   495,
+     496,     0,   494,   493,   489,   490,   488,   492,   491,   484,
+     483,   487,   486,   485,   455,   454,     0,   364,   344,   343,
+     342,   366,     0,     0,   365,   323,     0,     0,     0,   332,
+     334,   364,     0,     0,   337,     0,     0,   351,   350,   373,
+     369,     0,     0,     0,     0,     0,     0,   317,   367,     0,
+       0,     0,   319,   617,   281,    69,    70,    68,     0,   612,
+     613,   616,   615,   609,    46,     0,    45,    41,    79,    76,
+      78,   606,    96,   605,     0,    91,   617,   604,    95,     0,
+     615,     0,     0,   102,   617,   229,     0,   190,   191,     0,
+     258,     0,     0,    53,    51,   617,    43,     0,   108,     0,
+     594,   592,     0,    60,     0,     0,   113,     0,   617,   617,
+     617,     0,   617,     0,     0,   351,   617,     0,   545,   538,
+     537,   549,   381,     0,   141,     0,   149,   151,   617,   617,
+       0,   131,   533,   510,   512,   514,   534,     0,   161,   617,
+     466,     0,     0,   379,   378,     0,     0,     0,     0,     0,
+     293,     0,   345,   347,     0,     0,   298,   352,   335,     0,
+     325,   339,   338,   324,   305,   374,   320,     0,     0,     0,
+       0,     0,   318,     0,     0,     0,   282,   120,     0,     0,
+     351,     0,   617,     0,     0,     0,     0,     0,    93,   617,
+       0,   122,   188,   257,     0,   586,   104,     0,   103,     0,
+     351,     0,     0,     0,   590,   617,     0,    55,     0,   258,
+       0,   172,   173,   176,   175,   169,   174,   177,     0,   183,
+       0,     0,    84,     0,     0,   134,   133,   135,   617,   137,
+     132,   136,   617,   142,     0,   430,   432,   439,     0,   617,
+     433,   617,   421,   548,   617,   154,   130,     0,   127,   129,
+     125,   617,   519,   518,   520,     0,   516,   198,   217,     0,
+       0,     0,     0,   264,   617,     0,   242,   243,   235,   244,
+     215,   196,   240,   236,   234,   237,   238,   239,   241,   216,
+     212,   213,   200,   207,   206,   210,   209,     0,   218,     0,
+     201,   202,   205,   211,   203,   204,   214,     0,   277,     0,
+     285,   469,   468,   467,     0,     0,   459,     0,   499,   346,
+     348,   336,   322,   321,     0,     0,     0,   326,     0,     0,
+     614,   610,   617,     0,     0,    87,   615,    98,    92,   617,
+       0,     0,   100,     0,    74,     0,   112,   308,   595,   593,
+     599,   598,   597,     0,    58,    59,     0,   617,     0,     0,
+       0,    62,    83,   541,   546,   539,   617,   540,     0,   144,
+     143,   140,   431,     0,     0,   617,   443,   448,     0,   617,
+     437,   617,   434,     0,     0,     0,     0,     0,   559,   617,
+     513,   617,   617,     0,   193,   232,   231,   233,     0,   219,
+       0,     0,   220,   192,   397,   396,   399,     0,   395,   400,
+       0,   471,   470,   617,   327,     0,     0,   331,   330,     0,
+      42,     0,    99,     0,    94,   617,    89,    75,   105,   591,
+     596,     0,   617,     0,     0,   617,   544,     0,   617,     0,
+     444,   446,   442,   445,     0,   152,   617,   430,     0,   440,
+     617,   438,     0,   556,     0,   558,   560,     0,   552,   553,
+     617,     0,   506,   515,   507,     0,   199,     0,     0,   617,
+     165,   164,   617,     0,   208,     0,     0,   329,   328,    47,
+      97,    88,     0,   114,     0,   168,   617,     0,     0,     0,
+       0,   126,     0,   145,   447,   449,   450,   617,   441,   554,
+     555,   557,     0,     0,   564,   565,     0,     0,   617,     0,
+     617,     0,   617,     0,   162,   460,    90,   123,     0,   617,
+     617,   617,     0,   617,     0,     0,     0,   561,     0,   128,
+     505,   517,   194,     0,   617,     0,   251,   617,     0,     0,
+       0,   617,   221,     0,   138,   153,     0,   562,     0,   617,
+     222,     0,   166,   228,     0,   617,   617,   617,     0,     0,
+       0,   195,   223,   245,   247,     0,   248,   250,   421,   226,
+     225,   224,   617,   139,   563,     0,     0,   227,   246,   249
+};
+
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
+{
+      -1,     4,     5,   104,   105,   106,   811,   896,   897,   898,
+     899,   111,   414,   415,   900,   901,   740,   114,   115,   902,
+     117,   903,   119,   904,   699,   210,   905,   122,   906,   705,
+     558,   907,   387,   908,   397,   240,   409,   241,   909,   910,
+     911,   912,   545,   130,   880,   760,   858,   131,   755,   864,
+     991,  1059,    42,   607,   132,   133,   134,   135,   913,   929,
+     767,  1091,   914,   915,   738,   845,   418,   419,   420,   581,
+     916,   140,   566,   393,   917,  1087,  1168,  1013,   918,   919,
+     920,   921,   922,   923,   142,   924,   925,  1170,  1173,   926,
+    1027,   143,   927,   310,   191,   358,    43,   192,   293,   294,
+     470,   295,   761,   173,   402,   174,   331,   253,   176,   177,
+     254,   597,   598,    45,    46,   296,   205,    48,    49,    50,
+      51,    52,   318,   319,   360,   321,   322,   441,   866,  1068,
+    1000,   868,  1001,   869,   995,   996,  1115,   298,   299,   325,
+     301,   302,  1082,  1083,   447,   448,   612,   763,   764,   885,
+    1012,   886,    53,    54,   380,   381,   765,   600,   986,   601,
+     602,  1174,   875,  1007,  1075,  1076,   184,    55,   367,   412,
+      56,   187,    57,   269,   732,   834,   303,   304,   708,   201,
+     368,   693,   193
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -1040
+static const yytype_int16 yypact[] =
+{
+     542,  4525,  4628,   331,   113,  3969, -1040, -1040, -1040, -1040,
+   -1040, -1040, -1040, -1040, -1040, -1040, -1040, -1040, -1040, -1040,
+   -1040, -1040, -1040, -1040, -1040, -1040,   151, -1040, -1040, -1040,
+   -1040, -1040,   373,   210,   214,    79, -1040, -1040,   -14,   106,
+     237,  5257,   179,   157,   351,  5540,   627,  1462,   627, -1040,
+   -1040, -1040,  3038, -1040,   179,   237, -1040,   163, -1040,   361,
+     397,  4938, -1040,   339, -1040, -1040, -1040,   443, -1040, -1040,
+      68,   452,  5041,   464, -1040, -1040,   452,   480,   499,   506,
+      14, -1040, -1040,   525,   424,   530,   281,    48,   136,   613,
+     543,    71,   549,   387,   386,  5328,  5328,   574,   577,   623,
+     601,   267, -1040, -1040, -1040, -1040, -1040, -1040, -1040, -1040,
+   -1040, -1040, -1040, -1040,   452, -1040, -1040, -1040, -1040, -1040,
+   -1040, -1040,  1878, -1040, -1040, -1040, -1040, -1040, -1040, -1040,
+   -1040, -1040, -1040, -1040, -1040, -1040, -1040, -1040, -1040, -1040,
+   -1040, -1040, -1040,    70,  5399, -1040,   603, -1040, -1040,   606,
+     609,   179,   181,   655,  2315, -1040, -1040, -1040, -1040, -1040,
+     627, -1040,  3561,   618,   202,  2445,  3225,    53,   413,   941,
+      39,   179, -1040, -1040,    51,   311,    51,   346,  1935,   545,
+   -1040, -1040, -1040, -1040, -1040,   155,   234, -1040, -1040, -1040,
+     632, -1040,   638, -1040, -1040,   101, -1040, -1040,   655,    90,
+     101,   101, -1040,   642,  1950, -1040,   150,   416,   294,   155,
+     155, -1040,   101,  4835, -1040, -1040,  4938, -1040, -1040, -1040,
+   -1040, -1040, -1040,   179,   435, -1040,   162,   641,   155, -1040,
+   -1040,   101,   155, -1040, -1040, -1040,   692,  4938,   659,   226,
+     658,   668,   101,   623,   692,  4938,  4938,   179,   623,  1207,
+    1001,  1403,   101,   440,  2039,   599, -1040, -1040,  1950,   179,
+    1983,   353, -1040,   670,   681,   696,   155, -1040, -1040,   163,
+     639,   637, -1040, -1040, -1040, -1040, -1040, -1040, -1040, -1040,
+   -1040, -1040, -1040,  3225,   434,  3225,  3225,  3225,  3225,  3225,
+    3225,  3225, -1040,   650, -1040,   713,   717,   410,  2287,    22,
+      58, -1040, -1040,   692,   753, -1040, -1040,  3678,  1844,  1844,
+     724,   730,  1422,   663,   726, -1040, -1040, -1040,   723,  3225,
+   -1040, -1040, -1040, -1040,  4472, -1040,  2287,   745,  3678,   738,
+     179,   444,   346, -1040,   748,   444,   346, -1040,   666, -1040,
+   -1040,  4938,  2575, -1040,  4938,  2705,   749,  1139,  3395,   444,
+     346,   693,  1743, -1040, -1040,   163,   769,  4731, -1040, -1040,
+   -1040, -1040,   773,   692,   179, -1040, -1040,   341,   775, -1040,
+   -1040,  1213,    51,   473,   198, -1040,   776, -1040, -1040, -1040,
+   -1040,   179, -1040,   779,   771,   593,   781,   791, -1040,   792,
+     786, -1040,  5470, -1040,   179, -1040,   797,   798, -1040,   802,
+     805,  5328, -1040, -1040,   476, -1040, -1040, -1040,  5328, -1040,
+   -1040, -1040,   810, -1040, -1040,   671,   279,   815,   756, -1040,
+     822, -1040,    69, -1040, -1040,   116,   555,   555,   555,   516,
+     741,   829,   358,   832,  4938,  1776,  2789,   763,  2529,  1274,
+     161,   804,   188, -1040,  3795,  1274, -1040,   839, -1040,   338,
+   -1040, -1040, -1040, -1040,   237, -1040,   655,   883,  3528,  5470,
+     849,  2802,  2274, -1040, -1040, -1040, -1040, -1040, -1040,  2315,
+   -1040, -1040, -1040,  3225,  3225,  3225,  3225,  3225,  3225,  3225,
+    3225,  3225,  3225,  3225,  3225,  3225,  3225,  3225,  3225,  3225,
+     896,   898, -1040,   504,   504,  3563,   794,   454, -1040,   483,
+   -1040, -1040,   504,   504,   486,   795,   553,   555,  3225,  2287,
+   -1040,  4938,  3373,    24,   854, -1040,  4938,  2835,   856, -1040,
+     867, -1040,  4782,   875, -1040,  4885,   870,   873,   444,   346,
+     879,   444,   346,  2005,   880,   882,  2919,   444, -1040, -1040,
+   -1040,  4938,   638,   356, -1040, -1040,   101,  1723, -1040,   872,
+    4938,   888, -1040,   887, -1040,   484,  1667,  2286,   893,  4938,
+    1950,   890, -1040,   226,  4082,   894, -1040,   571,  5328,   184,
+     899,   903,  4938,   668,   240,   897,   101,  4938,    91,   851,
+    4938, -1040, -1040, -1040,   553,  1119,   895,    25, -1040,   904,
+    2659,   914,   232,   866,   869, -1040, -1040,   550, -1040,   403,
+   -1040, -1040, -1040,   852, -1040,   905,  5540,   285, -1040,   923,
+     741,    51,   889, -1040, -1040,   924, -1040,   179, -1040,  3225,
+    2965,  3095,  3355,    40,  1462,   921,   713,  1002,  1002,  1339,
+    1339,  2411,  2672,  2802,  2420,  2810,  2274,   754,   754,   788,
+     788, -1040, -1040, -1040, -1040, -1040,   795,   627, -1040, -1040,
+   -1040,   504,   931,   932,   226,   440,  5417,   933,   519,   795,
+   -1040,   286,   895,   935, -1040,  5533,   895,   468, -1040,   468,
+   -1040,   895,   934,   942,   943,   946,  3049,   444,   346,   948,
+     952,   955,   444,   638, -1040, -1040, -1040,   692,  4195, -1040,
+     937, -1040,   279,   963, -1040,   965, -1040, -1040, -1040, -1040,
+     692, -1040, -1040, -1040,   967, -1040,  1274,   692, -1040,   954,
+      78,   679,  1667, -1040,  1274, -1040,   972, -1040, -1040,  4308,
+      80,  5470,   417, -1040, -1040,  4938, -1040,   975, -1040,   877,
+   -1040,   171,   918, -1040,   982,   977, -1040,   179,  1209,   822,
+   -1040,   226,  1274,   100,   895, -1040,  4938,  3225, -1040, -1040,
+   -1040, -1040, -1040,  4700, -1040,    75, -1040, -1040,   964,  2122,
+     423, -1040, -1040,   985, -1040,   874, -1040,  2196, -1040,    51,
+    2287,  3225,  3225,  3355,  3865,  3225,   987,   988,   991,   994,
+   -1040,  3225, -1040, -1040,   997,   998, -1040, -1040, -1040,   531,
+     444, -1040, -1040,   444, -1040, -1040,   444,   895,   895,   995,
+     996,   999,   444,   895,  1000,  1003, -1040, -1040,   101,   101,
+     468,  2196,  4938,    91,  1723,  1034,   101,  1005, -1040,  1274,
+    1007, -1040, -1040,   692,  1950,    66, -1040,  5328, -1040,  1012,
+     468,    77,   155,   160, -1040,  2315,   217, -1040,  1008,    68,
+     384, -1040, -1040, -1040, -1040, -1040, -1040, -1040,  5112, -1040,
+    4421,  1014, -1040,  1018,  3645, -1040, -1040, -1040,   645, -1040,
+   -1040, -1040,  4938, -1040,   554,   964, -1040,    55,  1016,  1013,
+   -1040,  4938,   198,  1019,   966, -1040, -1040,  1950, -1040, -1040,
+   -1040,   889, -1040, -1040, -1040,   179, -1040, -1040, -1040,  1015,
+    1010,  1017,  1023,   927,  3455,   155, -1040, -1040, -1040, -1040,
+   -1040, -1040, -1040, -1040, -1040, -1040, -1040, -1040, -1040, -1040,
+   -1040, -1040, -1040, -1040, -1040, -1040, -1040,  1028,   958,  2196,
+   -1040, -1040, -1040, -1040, -1040, -1040, -1040,  5184,  1032,  2196,
+   -1040,  2287,  2287,  2287,  3225,  3225, -1040,  5470,  2543, -1040,
+   -1040, -1040,   444,   444,   895,  1036,  1040,   444,   895,   895,
+   -1040, -1040,    51,  1042,  1053, -1040,   692,  1056, -1040,  1274,
+    1456,    91, -1040,  1058, -1040,  1059, -1040, -1040, -1040,   171,
+   -1040, -1040,   171,  1004, -1040, -1040,  5470,  4938,  1950,  5470,
+    2019, -1040, -1040,   645, -1040, -1040,    51, -1040,  1062, -1040,
+   -1040, -1040, -1040,   155,   155,   964,   984,  1060,  1774,   327,
+   -1040,  1065, -1040,  1071,  1070,   198,   179,   579, -1040,  1274,
+   -1040,  1067,   889,  2196, -1040, -1040, -1040, -1040,   155, -1040,
+    1079,  1808, -1040, -1040,  1045,  1051,  1055,  1057,  1069,   197,
+    1082,  2287,  2287,  1462,   444,   895,   895,   444,   444,  1103,
+   -1040,  1105, -1040,  1108, -1040,  1274, -1040, -1040, -1040, -1040,
+   -1040,  1109,   226,  1066,    86,  3795, -1040,   423,  1274,  1112,
+   -1040,  1035, -1040, -1040,  3225, -1040,  1274,   370,    55, -1040,
+     327, -1040,   585, -1040,  1118,  1121,  1116,   509, -1040, -1040,
+      51,  1130, -1040, -1040, -1040,   179, -1040,  2196,  1126,  4938,
+   -1040, -1040,  1274,  3225, -1040,  1808,  1142,   444,   444, -1040,
+   -1040, -1040,  1151, -1040,  1152, -1040,  4938,  1145,  1157,    29,
+    1160, -1040,    72, -1040, -1040, -1040,  2287,    51, -1040, -1040,
+   -1040, -1040,   179,  1150, -1040, -1040,   423,  1155,  1067,  1158,
+    4938,  1163,    51,  3742, -1040, -1040, -1040, -1040,  1165,  4938,
+    4938,  4938,  1171,  2122,  5470,   554,   423,  1164,  1166, -1040,
+   -1040, -1040, -1040,  1174,  1274,   423, -1040,  1274,  1176,  1177,
+    1178,  4938, -1040,  1175, -1040, -1040,  1179, -1040,  2196,  1274,
+   -1040,   392, -1040, -1040,   408,  1274,  1274,  1274,  1181,   554,
+    1183, -1040, -1040, -1040, -1040,   198, -1040, -1040,   198, -1040,
+   -1040, -1040,  1274, -1040, -1040,  1180,  1182, -1040, -1040, -1040
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const yytype_int16 yypgoto[] =
+{
+   -1040, -1040,  -344, -1040, -1040, -1040, -1040,     4,    45,    -2,
+      59, -1040,   677, -1040,    63,    73, -1040, -1040, -1040,    82,
+   -1040,    88, -1040,    96, -1040, -1040,   103, -1040,   105,  -553,
+    -682,   107, -1040,   111, -1040,  -349,   662,   -91,   115,   118,
+     125,   130, -1040,   494,  -908,  -919, -1040, -1040, -1040, -1039,
+    -861, -1040,  -127, -1040, -1040, -1040, -1040, -1040,    34, -1040,
+   -1040,   145,    43,    56, -1040, -1040,   259, -1040,   661,   503,
+     133, -1040, -1040, -1040,  -777, -1040, -1040, -1040,   350, -1040,
+     510, -1040,   511,   152, -1040, -1040, -1040, -1040,  -310, -1040,
+   -1040, -1040,    11,   -35, -1040,  -498,  1210,    10,   420, -1040,
+     626,   787,   -45,  -602,  -545,   683,  1216,   -16,  -156,  -115,
+     534,  -610,   664,   141, -1040,   -59,    41,   -22,   507,  -715,
+    1212, -1040,  -360, -1040,  -163, -1040, -1040, -1040,  -832,  -728,
+     261, -1040, -1040,  -920, -1040,  -248, -1040,  1149, -1040,  -135,
+    -512, -1040, -1040,   137,   817, -1040, -1040, -1040,   389, -1040,
+   -1040, -1040,  -236,   -50, -1040, -1040,   262,  -568, -1040,  -589,
+   -1040,   633,   134, -1040, -1040,   156,   -20,  1148,  -180, -1040,
+    1022,  -209,  -145,  1099, -1040,  -395,  1283, -1040,   567,   200,
+    -203,  -502,     0
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -618
+static const yytype_int16 yytable[] =
+{
+       6,   320,   172,   109,   238,   145,   311,   268,   751,   107,
+     422,    44,    59,   204,   551,   362,   144,   259,   716,   300,
+     155,   369,   778,   160,   748,   736,   190,   376,   398,   817,
+     867,   175,   385,   992,   953,   691,   239,   239,   860,   136,
+     353,   268,    47,    47,   684,   691,   431,   180,   137,   564,
+     108,   247,   571,   332,   336,   711,   327,   794,     8,   795,
+     455,   138,   411,   350,   110,   660,   660,  1057,   112,  1141,
+     490,   202,   433,  1145,   196,   229,   202,   211,   113,  1069,
+       8,   775,    47,   405,   365,   260,   196,   116,    27,    28,
+      29,   256,   221,   118,   261,   701,   365,   196,   214,   215,
+    -296,   120,    47,   270,     8,   164,   365,   196,   121,   964,
+     123,  -181,   124,    62,   202,   862,   125,   230,   863,   151,
+     126,   863,   365,   127,  1179,   222,  1106,   166,   152,   340,
+     128,   343,  -572,   491,   702,   129,   366,   703,   139,     8,
+     661,   744,  1023,   852,    36,    37,   539,   155,   364,  1111,
+    1118,   311,  1030,   197,   305,   257,   154,   141,     8,   818,
+    1142,  1126,  -296,     8,   292,   197,    36,    37,   776,   154,
+     873,   777,   311,  -181,   180,   583,   180,   170,   388,   993,
+     994,   389,     8,  1144,     8,   806,   198,   161,   373,   181,
+      36,    37,   359,   332,   336,   297,   968,   350,  1146,   146,
+     952,   688,   400,    47,   374,   704,   316,   317,   382,   153,
+     417,   320,  1028,  1155,  1107,   605,   394,  1108,  1149,   722,
+     967,   974,   719,   404,   170,    36,    37,   723,   223,     8,
+     724,  -428,   529,   532,  -428,   992,  1086,     8,  1165,   406,
+    1094,   410,   413,     8,    36,    37,   423,  1172,   315,    36,
+      37,    38,   172,   154,    47,    40,   421,    47,   149,   443,
+     955,   450,   150,   975,  -428,   154,   162,  1062,    36,    37,
+      36,    37,   747,  -256,   163,  1042,   208,   438,    47,   971,
+     185,   175,   158,   165,  1164,   365,    47,    47,   832,     8,
+     985,   154,   497,   499,    38,   471,   504,   180,    40,   266,
+     267,   306,   691,   316,   317,   186,   520,   316,   317,   523,
+    1129,   338,   957,   833,   248,    36,    37,   573,  1193,    30,
+      31,   593,   594,    36,    37,   577,   432,   549,   757,    36,
+      37,   758,    60,   563,   300,    27,    28,    29,    33,    34,
+     154,    38,   239,   689,   422,   167,   377,   378,    47,   239,
+     653,   341,   266,   354,   168,   729,     8,   169,   219,   730,
+     685,     8,   196,   220,   170,   379,   171,   542,   342,    47,
+     246,    61,   180,   734,  -435,    36,    37,   709,   332,   336,
+     350,   614,    47,   546,  -617,    47,   344,   529,   532,    72,
+     235,  1181,   196,     6,   159,   547,   850,   350,    47,   589,
+     624,    38,   686,   345,   188,    40,   617,   405,  1046,   609,
+     497,   499,   504,     8,   446,  1056,     8,  -436,   678,     8,
+     582,   701,   196,   196,   876,   147,   330,   232,   653,   446,
+     233,  1096,    72,   234,   616,  1183,    30,    31,  1184,   604,
+     189,   608,    36,    37,   148,   604,  1185,    36,    37,   450,
+     162,  1186,  -617,   328,  1187,    33,    34,   375,   163,   194,
+     826,   329,  1188,   703,   164,   877,   878,   165,    38,   879,
+     165,   827,    40,    38,   459,    47,   657,    40,   391,   292,
+     434,   663,   460,   195,   516,    47,   166,   977,   698,   392,
+     196,   655,   200,   538,   434,   648,   170,   342,   785,    36,
+      37,   517,    36,    37,   207,    36,    37,  1104,   217,   239,
+     297,   342,  1004,   550,  -617,   695,   572,    27,    28,    29,
+     209,   316,   317,   434,   649,    38,   434,   650,    38,   167,
+     342,   595,    40,   342,   596,  -617,   678,   727,   168,   212,
+     342,   169,   359,   342,   307,     6,   213,   404,   170,  1124,
+     171,   683,    47,   330,   873,  1125,     8,    47,     8,   516,
+     788,   165,   109,   406,   145,   216,     6,   145,   107,   713,
+     218,   516,   941,   410,  1049,   144,   517,  1050,   721,   172,
+     599,   178,    47,   228,   756,   785,   599,   735,   517,   231,
+     421,    47,    68,   162,   989,   371,   595,   990,   136,   596,
+      47,   163,    27,    28,    29,   950,   951,   137,   175,   108,
+     165,   180,   766,    47,   242,   720,     8,   243,    47,   154,
+     138,    47,  1078,   110,   180,  1079,   471,   112,  1119,   196,
+     591,  1120,  -586,  -586,   556,   557,   709,   113,   592,   593,
+     594,   245,    36,    37,    36,    37,   116,   654,    80,    81,
+      82,   262,   118,    84,   263,    86,    87,   264,  -586,   225,
+     120,   352,   824,     1,     2,     3,   314,   121,    38,   123,
+      38,   124,   167,   356,   167,   125,    27,    28,    29,   126,
+     357,   168,   127,   359,   169,   370,   109,   395,   145,   128,
+     829,   170,   107,   171,   129,   171,   312,   139,   365,   144,
+     300,   407,    36,    37,   337,   401,   604,    30,    31,   320,
+     408,   853,   575,   576,   604,   438,   141,   109,   451,   145,
+     815,   816,   136,   107,   930,   741,    33,    34,    38,   452,
+     144,   137,    40,   108,   593,   594,   965,   453,   145,   582,
+       6,   422,   604,   456,   138,  1060,  1061,   110,   457,   848,
+    1020,   112,   160,   136,   468,   469,   865,   472,   870,   604,
+     492,   113,   137,   774,   108,   500,    47,   928,   239,   180,
+     116,   501,   842,   178,   507,   138,   118,   954,   110,   506,
+     508,   843,   112,   428,   120,   511,   514,    47,   538,   980,
+     247,   121,   113,   123,   844,   124,   518,   526,   261,   125,
+     259,   116,   538,   126,   170,   252,   127,   118,   599,   533,
+     599,   928,   540,   128,   543,   120,   548,   552,   129,   604,
+     554,   139,   121,   559,   123,   555,   124,   988,  1196,   562,
+     125,   178,   560,   561,   126,   305,  1003,   127,   567,   568,
+     141,   495,  1074,   569,   128,   292,   570,   599,   109,   129,
+     145,   574,   139,    47,   107,   599,   578,   584,   987,  1182,
+     579,   144,   512,   865,   580,  1189,  1190,  1191,   980,  1002,
+     585,   141,   519,  1088,  1008,   588,   297,   261,  1033,   590,
+     606,   766,  1197,   599,   136,   613,   618,   372,   485,   486,
+     487,   488,   489,   137,   145,   108,   405,   625,     8,   644,
+     599,   645,   662,    47,   666,   428,   138,  1039,   667,   110,
+     647,   651,    47,   112,   774,   694,   669,  1052,   671,   928,
+    1054,   672,   403,   113,   487,   488,   489,   673,   679,   928,
+     680,   696,   116,   697,   712,   432,   715,   718,   118,   725,
+     733,   439,   737,   445,     8,   745,   120,   882,   883,   884,
+     726,   599,   180,   121,   746,   123,   749,   124,   750,   604,
+     599,   125,   754,   753,   759,   126,   586,   762,   127,   779,
+     768,   599,   782,   783,   787,   128,   791,   423,   428,   808,
+     129,   328,   797,   139,    36,    37,   180,   421,   172,   334,
+     798,   799,   623,   865,   800,   870,   803,  1067,   165,   870,
+     804,  1002,   141,   805,     8,   809,   810,   812,   814,   604,
+      38,  1084,   766,   928,    40,   821,   830,   175,    47,   831,
+    1110,   835,  1195,   836,   837,   320,    72,   881,   934,   935,
+      36,    37,   936,   180,   937,   330,   404,     8,   939,   940,
+     178,   432,  1006,   944,   945,   604,   960,   946,   948,   329,
+     962,   949,   406,   966,  1131,   999,    38,   982,   604,   983,
+      40,  1014,   976,   998,   157,   865,   604,  1018,  1067,   179,
+     870,  1138,   603,  1005,   371,  1021,   183,   958,   611,  -197,
+     180,   330,   163,  1022,  1035,  1163,  1015,   928,  1036,  1040,
+      36,    37,   604,  1016,  1041,  1153,    47,   178,   816,  1017,
+     599,  1047,  1048,  1058,  1158,  1159,  1160,  1070,  1051,  1063,
+     224,   227,  1072,  1073,  1064,  1081,    38,   180,   178,  1089,
+      40,  -254,     8,    36,    37,   196,  1178,  -253,  1084,  1095,
+      47,  -255,   180,  1093,   483,   484,   485,   486,   487,   488,
+     489,   330,     8,   604,   255,  -252,  1099,    47,  1100,    38,
+     599,  1101,  1103,   167,   604,  1113,   337,   604,   178,   371,
+    1114,  1121,   250,  1122,  1123,   251,  1130,   163,   928,   604,
+    1105,    47,   170,   265,   171,   604,   604,   604,  1127,   328,
+      47,    47,    47,  1135,   313,  1139,   599,   527,   178,   652,
+     333,   333,   604,   339,  1136,  1137,   165,  1140,  1148,   599,
+     351,  1143,    47,  1150,  1154,  1152,  1157,   599,    36,    37,
+       8,  1161,  1166,   196,  1167,  1169,     8,  1175,  1176,  1177,
+     206,   863,  1192,  1198,   690,  1199,   255,  1180,    36,    37,
+      68,  1194,   841,   599,    38,   728,  1053,   226,   167,   706,
+    1134,   739,   849,   714,  1019,   390,   403,   250,   846,   847,
+     251,   156,   780,   839,    38,   973,   626,   170,    40,   171,
+     859,   179,  1071,   752,   182,  1151,   615,   652,   742,   424,
+    1010,   430,   333,   333,  1085,   178,   437,  1162,  1147,   330,
+     440,   157,   255,   449,   599,   355,    80,    81,    82,   828,
+       0,    84,     0,    86,    87,   599,    36,    37,   599,     0,
+       0,     0,    36,    37,     0,     0,     0,   337,   519,     0,
+     599,     0,   316,   317,   324,   326,   599,   599,   599,   179,
+       0,     0,    38,    27,    28,    29,    40,   840,    38,   496,
+     498,   498,    40,   599,   505,   426,     0,   784,   427,   813,
+       0,   426,     0,   361,   427,   170,     0,   820,   361,   361,
+     513,   170,   515,   199,   591,   361,     0,   383,   384,     0,
+     361,     0,   592,   593,   594,     0,     0,     0,     0,   333,
+     333,     0,     0,     0,   333,   851,   396,   236,     0,   361,
+     399,     0,   244,     0,     0,   335,   544,     0,     0,     0,
+     361,     0,   874,   430,   349,   819,     0,   429,     0,     0,
+     361,     0,   595,   553,     0,   596,     8,   442,     0,     0,
+       0,     0,     0,     0,   454,     0,   565,     0,     0,     0,
+       0,     0,     0,     0,   784,     8,     0,     0,     0,     0,
+       0,     0,   458,     0,   461,   462,   463,   464,   465,   466,
+     467,     0,     0,   432,     0,     0,   473,   474,   498,   498,
+     498,   334,   961,     0,   587,     0,     0,   333,   333,     8,
+     333,     0,   162,     0,     0,     8,   610,   335,   509,     0,
+     349,   483,   484,   485,   486,   487,   488,   489,   363,   165,
+       0,     0,     0,   363,   363,     0,     0,     0,     0,     0,
+     363,   522,    36,    37,   525,   363,   371,     0,   959,  1044,
+       0,     0,   162,     0,   163,     0,     0,   963,     0,     0,
+     163,    36,    37,     0,   363,     0,   164,   646,    38,   165,
+       0,     0,    40,     0,     0,   363,   416,     0,   179,   498,
+       0,   425,   363,     0,   659,   363,     0,    38,   166,     0,
+       0,   167,     0,   330,     0,    36,    37,     0,     0,     0,
+     502,    36,    37,   503,     0,   333,     0,     0,   333,     0,
+    1009,     0,   171,   528,   531,     0,     0,   178,   537,     0,
+       0,    38,     0,     0,     0,   167,     0,    38,   255,     0,
+       0,   167,   255,     0,   250,   179,   178,   251,  1109,   428,
+     168,     0,  1043,   169,   170,     0,   171,     0,     0,     0,
+     170,     0,   171,     0,     0,     0,   179,   255,   333,     0,
+       0,     0,   333,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,   627,   628,   629,   630,   631,   632,   633,   634,
+     635,   636,   637,   638,   639,   640,   641,   642,   643,   769,
+       0,     0,  1080,  1045,     0,     0,   179,     0,     0,     0,
+       0,   528,   531,     0,   537,     0,     0,   656,     0,     0,
+       0,   439,     0,   445,     0,     0,   665,     0,     0,     0,
+       8,   701,     0,   196,     0,     0,   179,     0,  1102,     0,
+       0,  1066,     0,   333,   333,     0,     0,     0,   333,     0,
+       0,  1112,     0,   333,   361,     0,     0,     0,   333,  1117,
+       0,     0,     0,     0,  1092,   361,     0,   371,     0,     0,
+     702,     0,     0,   703,     0,   163,     0,     0,     0,     0,
+       0,     0,   731,     0,   361,  1132,     0,     0,   658,   196,
+       0,     0,     0,     0,   255,   403,   275,   276,   277,   278,
+     279,   280,   281,   282,     0,     0,     8,     0,     0,   677,
+       0,     0,   682,     0,     0,     0,    36,    37,     0,   838,
+       0,     0,     0,   179,     0,     0,   333,     0,   770,   633,
+     636,   643,     0,     0,     0,   861,   874,     8,  1092,     8,
+       0,   704,    38,   432,     0,     0,   167,  1171,     0,     0,
+       0,   534,    27,    28,    29,   250,     0,     0,   251,     0,
+       0,     0,   658,     0,     0,   170,   677,   171,     0,     0,
+       0,     8,     0,     0,   371,     0,   432,  1065,     0,   333,
+     333,     0,   163,     0,   527,   333,   687,     0,     0,   363,
+     692,     0,    36,    37,     0,     0,     0,   255,   700,   707,
+     710,     0,     0,     0,     0,     0,   255,     8,   371,     0,
+       0,  1090,     0,     0,     0,     0,   163,     0,    38,   363,
+       0,   707,    40,    36,    37,    36,    37,     0,   743,   825,
+       0,   535,     0,     0,   536,     0,     0,   789,   790,     0,
+       0,     8,   793,   330,   162,     0,     0,   796,     0,    38,
+       0,    38,   802,   167,     0,    40,   854,    36,    37,   255,
+       0,   165,   250,     0,     0,   251,     0,  1011,     0,     0,
+       0,     0,   170,     0,   171,     0,   330,     0,   249,     0,
+     931,   932,   465,    38,   933,     0,   163,   167,     0,     0,
+     938,     0,     0,    36,    37,     0,   250,     0,     8,   251,
+       0,     0,     0,     0,     0,     0,   170,     0,   171,  1029,
+       0,     0,     0,     8,     0,     0,   361,   361,     0,    38,
+     789,     0,     0,   167,   361,     0,   333,    36,    37,     0,
+     333,   333,     0,     0,     0,   328,     0,     0,     0,   969,
+     970,   972,   255,   346,   171,     0,     8,     0,     0,     0,
+     371,     0,   165,    38,     0,   707,     0,   167,   163,     0,
+     255,     0,   255,   823,     0,   707,   250,     0,     8,   251,
+       0,     0,     0,   942,   943,   997,   170,     0,   171,   947,
+     255,     0,     8,   444,    36,    37,     0,     0,  1077,     0,
+       0,   163,     0,     0,     0,     0,     0,     0,     0,    36,
+      37,     0,     8,   255,     0,   328,     0,     0,     0,     0,
+      38,     0,     0,   674,    40,   179,     0,   333,   333,  1055,
+       0,     0,   165,   347,     0,    38,   348,   163,     0,   167,
+       0,     0,    36,    37,   179,   330,     0,   610,   250,   432,
+       0,   251,     0,  1031,  1032,     0,     0,   346,   170,     0,
+     171,   363,   363,     0,    36,    37,   707,   956,    38,   363,
+       0,     0,   167,     0,     0,     0,     0,  1128,    36,    37,
+       0,   250,     0,     0,   251,     0,     0,   255,     0,     0,
+      38,   170,   823,   171,    40,     0,     0,     0,    36,    37,
+       0,     0,     0,   675,    38,     0,   676,     0,   167,     0,
+       0,   997,   997,     0,  1077,   330,     0,   250,     0,     0,
+     251,     0,     0,     0,    38,     0,     0,   170,    40,   171,
+    1034,     0,   871,     0,  1037,  1038,     0,   435,     0,     0,
+     436,    27,    28,    29,     0,     0,   872,     0,     0,   330,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,   887,     0,  -617,
+      64,     0,   591,     0,    65,    66,    67,     0,     0,     0,
+     592,   593,   594,  1116,     0,     0,   997,    68,  -617,  -617,
+    -617,  -617,  -617,  -617,  -617,  -617,  -617,  -617,  -617,  -617,
+       0,  -617,  -617,  -617,  -617,  -617,     0,     0,     0,   888,
+      70,     0,  1133,  -617,   707,  -617,  -617,  -617,  -617,  -617,
+     595,  1097,  1098,   596,     0,     0,     0,     0,    72,    73,
+      74,    75,   889,    77,    78,    79,  -617,  -617,  -617,   890,
+     891,   892,     0,    80,   893,    82,     0,    83,    84,    85,
+      86,    87,  -617,  -617,     0,  -617,  -617,    88,     0,     8,
+       0,    92,   196,    94,    95,    96,    97,    98,    99,   275,
+     276,   277,   278,   279,   280,   281,   282,     0,     0,   100,
+       0,  -617,     0,     0,   101,  -617,  -617,     0,   271,     0,
+     894,   196,   272,     0,     0,     0,   273,   274,   275,   276,
+     277,   278,   279,   280,   281,   282,   895,     9,    10,    11,
+      12,    13,    14,    15,    16,    17,    18,    19,    20,     0,
+      21,    22,    23,    24,    25,   283,     0,     0,     0,     0,
+       0,     0,     0,    26,    27,    28,    29,    30,    31,     0,
+     284,     0,     0,     0,     0,    36,    37,     0,     0,     0,
+       0,   473,   474,   475,   476,    32,    33,    34,     0,     0,
+       0,   316,   317,     0,   473,   474,   475,   476,     0,   477,
+       0,    35,     0,     0,    36,    37,   483,   484,   485,   486,
+     487,   488,   489,     0,   478,   479,   480,   481,   482,   483,
+     484,   485,   486,   487,   488,   489,     0,     0,     0,     0,
+      38,     0,     0,    39,    40,     0,     0,     0,     0,    41,
+       0,     0,     0,   285,     0,     0,   286,     0,   271,   287,
+     288,   196,   272,   289,   290,   291,   273,   274,   275,   276,
+     277,   278,   279,   280,   281,   282,     0,     9,    10,    11,
+      12,    13,    14,    15,    16,    17,    18,    19,    20,     0,
+      21,    22,    23,    24,    25,   283,     0,   781,     0,     0,
+       0,     0,     0,     0,    27,    28,    29,    30,    31,     0,
+     284,     0,     0,   323,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    32,    33,    34,   473,   474,
+     475,   476,     0,   477,     0,     0,     0,   473,   474,   475,
+     476,    35,     8,     0,    36,    37,     0,     0,   478,   479,
+     480,   481,   482,   483,   484,   485,   486,   487,   488,   489,
+     481,   482,   483,   484,   485,   486,   487,   488,   489,     0,
+      38,     0,     0,     0,    40,     0,     0,     0,     0,   432,
+       0,     0,     0,   285,     0,     0,   286,   534,   271,   287,
+     288,   196,   272,   289,   290,   291,   273,   274,   275,   276,
+     277,   278,   279,   280,   281,   282,     0,     9,    10,    11,
+      12,    13,    14,    15,    16,    17,    18,    19,    20,     0,
+      21,    22,    23,    24,    25,   283,     0,     0,    36,    37,
+       0,     0,     0,     0,    27,    28,    29,    30,    31,     0,
+     284,     0,     0,   521,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    38,    32,    33,    34,    40,     0,
+     473,   474,   475,   476,     0,     0,     0,   535,     0,     0,
+     536,    35,     8,     0,    36,    37,     0,     0,     0,   330,
+     478,   479,   480,   481,   482,   483,   484,   485,   486,   487,
+     488,   489,     0,     0,     0,     0,     0,     0,     0,     0,
+      38,     0,     0,     0,    40,     0,     0,     0,     0,   432,
+       0,     0,     0,   285,     0,     0,   286,   674,   271,   287,
+     288,   196,   272,   289,   290,   291,   273,   274,   275,   276,
+     277,   278,   279,   280,   281,   282,     0,     9,    10,    11,
+      12,    13,    14,    15,    16,    17,    18,    19,    20,     0,
+      21,    22,    23,    24,    25,   283,     0,     0,    36,    37,
+       0,     0,     0,     0,    27,    28,    29,    30,    31,     0,
+     284,     0,     0,   524,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    38,    32,    33,    34,    40,   473,
+     474,   475,   476,     0,     0,     0,     0,   675,     0,     0,
+     676,    35,     8,     0,    36,    37,     0,     0,     0,   330,
+     479,   480,   481,   482,   483,   484,   485,   486,   487,   488,
+     489,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+      38,     0,     0,     0,    40,     0,     0,     0,     0,   432,
+       0,     0,     0,   285,     0,     0,   286,   530,   271,   287,
+     288,   196,   272,   289,   290,   291,   273,   274,   275,   276,
+     277,   278,   279,   280,   281,   282,     0,     9,    10,    11,
+      12,    13,    14,    15,    16,    17,    18,    19,    20,     0,
+      21,    22,    23,    24,    25,   283,     0,     0,    36,    37,
+       0,     0,     0,     0,    27,    28,    29,    30,    31,     0,
+     284,     0,     0,   664,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    38,    32,    33,    34,    40,   473,
+     474,   475,   476,     0,     0,     0,     0,   473,   474,   475,
+     476,    35,     8,     0,    36,    37,     0,     0,     0,   330,
+       0,   480,   481,   482,   483,   484,   485,   486,   487,   488,
+     489,   482,   483,   484,   485,   486,   487,   488,   489,     0,
+      38,     0,     0,     0,    40,     0,     0,     0,     0,   432,
+       0,     0,     0,   285,     0,     0,   286,   681,   271,   287,
+     288,   196,   272,   289,   290,   291,   273,   274,   275,   276,
+     277,   278,   279,   280,   281,   282,     0,     9,    10,    11,
+      12,    13,    14,    15,    16,    17,    18,    19,    20,     0,
+      21,    22,    23,    24,    25,   283,   771,     0,    36,    37,
+       0,     0,     0,     0,    27,    28,    29,    30,    31,     0,
+     284,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    38,    32,    33,    34,    40,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,    35,     8,     0,    36,    37,     0,     0,     0,   330,
+       9,    10,    11,    12,    13,    14,    15,    16,     0,    18,
+       0,    20,     0,     0,    22,    23,    24,    25,     0,     0,
+      38,     0,     0,     0,    40,     0,     0,     0,     0,   432,
+       0,     0,     0,   285,     0,     0,   286,   801,   271,   287,
+     288,   196,   272,   289,   290,   291,   273,   274,   275,   276,
+     277,   278,   279,   280,   281,   282,     0,     9,    10,    11,
+      12,    13,    14,    15,    16,    17,    18,    19,    20,     0,
+      21,    22,    23,    24,    25,   283,   772,     0,    36,    37,
+       0,     0,     0,     0,    27,    28,    29,    30,    31,     0,
+     284,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    38,    32,    33,    34,    40,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,    35,     0,     0,    36,    37,     0,     0,     0,   330,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+      38,     0,     0,     0,    40,     0,     0,     0,     0,     0,
+       0,     0,     0,   285,     0,     0,   286,     0,   271,   287,
+     288,   196,   272,   289,   290,   291,   273,   274,   275,   276,
+     277,   278,   279,   280,   281,   282,     0,     9,    10,    11,
+      12,    13,    14,    15,    16,    17,    18,    19,    20,     0,
+      21,    22,    23,    24,    25,   283,     0,     0,     0,     0,
+       0,     0,     0,     0,    27,    28,    29,    30,    31,     0,
+     284,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    32,    33,    34,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,    35,     0,     0,    36,    37,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+      38,     0,     0,     0,    40,     0,     0,     0,     0,     0,
+       0,     0,     0,   285,     0,     0,   286,     0,   271,   287,
+     288,   196,   272,   289,   290,   291,   273,   274,   275,   276,
+     277,   278,   279,   280,   281,   282,     8,     9,    10,    11,
+      12,    13,    14,    15,    16,    17,    18,    19,    20,     0,
+      21,    22,    23,    24,    25,   283,     0,     0,     8,     0,
+       0,     0,     0,     0,    27,    28,    29,    30,    31,     0,
+     284,     0,     0,   328,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    32,    33,    34,     0,     0,
+     165,     0,     0,     0,     0,   328,     0,     0,     0,     0,
+       0,    35,     0,   530,    36,    37,     0,     0,     0,     0,
+       0,     0,   165,     0,     0,     0,     0,     0,     0,    64,
+       0,     0,    36,    37,     0,    67,     0,     0,     0,     0,
+      38,     0,     0,     0,    40,     0,    68,     0,     0,     0,
+       0,     0,     0,     0,    36,    37,     0,     0,    38,   287,
+     288,     0,    40,   773,   290,   291,     0,     0,   888,    70,
+       0,   502,     0,     0,   503,     0,     0,     0,     0,     0,
+      38,     0,     0,   330,    40,     0,     0,    72,    73,    74,
+      75,     0,    77,    78,    79,     0,     0,     0,   890,   891,
+     892,     0,    80,   893,    82,   330,    83,    84,    85,    86,
+      87,     0,     0,     0,     0,     0,    88,     0,     0,     0,
+      92,     0,    94,    95,    96,    97,    98,    99,     0,     0,
+       0,     0,     0,     0,     8,     0,     8,     0,   100,   619,
+       0,     0,     0,   101,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     9,    10,    11,    12,    13,    14,    15,
+      16,    17,    18,    19,    20,   895,    21,    22,    23,    24,
+      25,   307,     0,   307,     0,     0,     0,     0,     0,    26,
+      27,    28,    29,    30,    31,     0,     0,     0,   165,     0,
+     165,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,    32,    33,    34,     0,   473,   474,   475,   476,     0,
+     477,     0,     0,     0,     0,     0,     0,    35,     0,     0,
+      36,    37,    36,    37,     0,   478,   620,   480,   481,   621,
+     483,   484,   485,   486,   487,   488,   622,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    38,     0,    38,    39,
+      40,     8,    40,     0,     0,    41,   984,     0,     0,   308,
+       0,   502,   309,     0,   503,     0,     0,     0,     0,   170,
+       9,    10,    11,    12,    13,    14,    15,    16,    17,    18,
+      19,    20,     0,    21,    22,    23,    24,    25,   307,     0,
+       0,     0,     0,     0,     0,     0,    26,    27,    28,    29,
+      30,    31,     0,     0,     0,   165,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,    32,    33,
+      34,     0,   473,   474,   475,   476,     0,   477,     0,     0,
+       0,     0,     0,     0,    35,     0,     0,    36,    37,     0,
+       0,     0,   478,   479,   480,   481,   482,   483,   484,   485,
+     486,   487,   488,   489,     0,  1156,     0,     0,     0,     0,
+       0,     0,     0,    38,     0,     0,    39,    40,     8,     0,
+       0,     0,    41,     0,     0,     0,   493,     0,     0,   494,
+       0,     0,     0,     0,     0,     0,   170,     9,    10,    11,
+      12,    13,    14,    15,    16,    17,    18,    19,    20,     0,
+      21,    22,    23,    24,    25,     0,     0,     0,     0,     0,
+       0,     0,     0,    26,    27,    28,    29,    30,    31,   473,
+     474,   475,   476,     0,   477,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    32,    33,    34,     8,   478,
+     479,   480,   481,   482,   483,   484,   485,   486,   487,   488,
+     489,    35,     0,     0,    36,    37,     0,     9,    10,    11,
+      12,    13,    14,    15,    16,    17,    18,    19,    20,     0,
+      21,    22,    23,    24,    25,     0,     0,     0,     0,     0,
+      38,     0,     0,    39,    40,     0,     0,    30,    31,    41,
+       0,     0,     0,   426,     0,     0,   427,     0,     0,     0,
+       0,     0,     0,   170,     0,    32,    33,    34,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,    35,     0,     0,    36,    37,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,    -2,
+      63,     0,  -617,    64,     0,     0,     0,    65,    66,    67,
+      38,     0,     0,     0,    40,     0,     0,     0,     0,     0,
+      68,  -617,  -617,  -617,  -617,  -617,  -617,  -617,  -617,  -617,
+    -617,  -617,  -617,   170,  -617,  -617,  -617,  -617,  -617,     0,
+       0,     0,    69,    70,     0,     0,     0,     0,  -617,  -617,
+    -617,  -617,  -617,     0,     0,    71,     0,     0,     0,     0,
+       0,    72,    73,    74,    75,    76,    77,    78,    79,  -617,
+    -617,  -617,     0,     0,     0,     0,    80,    81,    82,     0,
+      83,    84,    85,    86,    87,  -617,  -617,     0,  -617,  -617,
+      88,    89,    90,    91,    92,    93,    94,    95,    96,    97,
+      98,    99,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,   100,    63,  -617,  -617,    64,   101,  -617,     0,
+      65,    66,    67,   102,   103,     0,     0,     0,     0,     0,
+       0,     0,     0,    68,  -617,  -617,  -617,  -617,  -617,  -617,
+    -617,  -617,  -617,  -617,  -617,  -617,     0,  -617,  -617,  -617,
+    -617,  -617,     0,     0,     0,    69,    70,     0,     0,   717,
+       0,  -617,  -617,  -617,  -617,  -617,     0,     0,    71,     0,
+       0,     0,     0,     0,    72,    73,    74,    75,    76,    77,
+      78,    79,  -617,  -617,  -617,     0,     0,     0,     0,    80,
+      81,    82,     0,    83,    84,    85,    86,    87,  -617,  -617,
+       0,  -617,  -617,    88,    89,    90,    91,    92,    93,    94,
+      95,    96,    97,    98,    99,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,   100,    63,  -617,  -617,    64,
+     101,  -617,     0,    65,    66,    67,   102,   103,     0,     0,
+       0,     0,     0,     0,     0,     0,    68,  -617,  -617,  -617,
+    -617,  -617,  -617,  -617,  -617,  -617,  -617,  -617,  -617,     0,
+    -617,  -617,  -617,  -617,  -617,     0,     0,     0,    69,    70,
+       0,     0,   807,     0,  -617,  -617,  -617,  -617,  -617,     0,
+       0,    71,     0,     0,     0,     0,     0,    72,    73,    74,
+      75,    76,    77,    78,    79,  -617,  -617,  -617,     0,     0,
+       0,     0,    80,    81,    82,     0,    83,    84,    85,    86,
+      87,  -617,  -617,     0,  -617,  -617,    88,    89,    90,    91,
+      92,    93,    94,    95,    96,    97,    98,    99,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,   100,    63,
+    -617,  -617,    64,   101,  -617,     0,    65,    66,    67,   102,
+     103,     0,     0,     0,     0,     0,     0,     0,     0,    68,
+    -617,  -617,  -617,  -617,  -617,  -617,  -617,  -617,  -617,  -617,
+    -617,  -617,     0,  -617,  -617,  -617,  -617,  -617,     0,     0,
+       0,    69,    70,     0,     0,   822,     0,  -617,  -617,  -617,
+    -617,  -617,     0,     0,    71,     0,     0,     0,     0,     0,
+      72,    73,    74,    75,    76,    77,    78,    79,  -617,  -617,
+    -617,     0,     0,     0,     0,    80,    81,    82,     0,    83,
+      84,    85,    86,    87,  -617,  -617,     0,  -617,  -617,    88,
+      89,    90,    91,    92,    93,    94,    95,    96,    97,    98,
+      99,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,   100,    63,  -617,  -617,    64,   101,  -617,     0,    65,
+      66,    67,   102,   103,     0,     0,     0,     0,     0,     0,
+       0,     0,    68,  -617,  -617,  -617,  -617,  -617,  -617,  -617,
+    -617,  -617,  -617,  -617,  -617,     0,  -617,  -617,  -617,  -617,
+    -617,     0,     0,     0,    69,    70,     0,     0,     0,     0,
+    -617,  -617,  -617,  -617,  -617,     0,     0,    71,     0,     0,
+       0,   981,     0,    72,    73,    74,    75,    76,    77,    78,
+      79,  -617,  -617,  -617,     0,     0,     0,     0,    80,    81,
+      82,     0,    83,    84,    85,    86,    87,  -617,  -617,     0,
+    -617,  -617,    88,    89,    90,    91,    92,    93,    94,    95,
+      96,    97,    98,    99,     0,     0,     7,     0,     8,     0,
+     510,     0,     0,     0,   100,     0,  -617,     0,     0,   101,
+    -617,     0,     0,     0,     0,   102,   103,     9,    10,    11,
+      12,    13,    14,    15,    16,    17,    18,    19,    20,     0,
+      21,    22,    23,    24,    25,     0,     0,     0,     0,     0,
+       0,     0,     0,    26,    27,    28,    29,    30,    31,   473,
+     474,   475,   476,     0,   477,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    32,    33,    34,     0,   478,
+     479,   480,   481,   482,   483,   484,   485,   486,   487,   488,
+     489,    35,     0,     0,    36,    37,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,    58,
+       0,     8,     0,     0,     0,     0,     0,     0,     0,     0,
+      38,     0,     0,    39,    40,     0,     0,     0,     0,    41,
+       9,    10,    11,    12,    13,    14,    15,    16,    17,    18,
+      19,    20,     0,    21,    22,    23,    24,    25,     0,     0,
+       0,     0,     0,     0,     0,     0,    26,    27,    28,    29,
+      30,    31,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,    32,    33,
+      34,     0,     0,     8,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    35,     0,     0,    36,    37,     0,
+       0,     0,     9,    10,    11,    12,    13,    14,    15,    16,
+     855,    18,   856,    20,     8,   857,    22,    23,    24,    25,
+       0,     0,     0,    38,     0,     0,    39,    40,     0,     0,
+       0,     0,    41,     9,    10,    11,    12,    13,    14,    15,
+      16,    17,    18,    19,    20,     0,    21,    22,    23,    24,
+      25,     0,     0,     0,     0,     0,     0,     0,     0,    26,
+      27,    28,    29,    30,    31,     0,    35,     0,     0,    36,
+      37,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,    32,    33,    34,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    38,     0,    35,     0,    40,
+      36,    37,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     8,     0,
+     668,     0,     0,     0,     0,     0,    38,     0,   386,    39,
+      40,     0,     0,     0,     0,    41,   541,     9,    10,    11,
+      12,    13,    14,    15,    16,    17,    18,    19,    20,     0,
+      21,    22,    23,    24,    25,     0,     0,     0,     0,     0,
+       0,     0,     0,    26,    27,    28,    29,    30,    31,   473,
+     474,   475,   476,     0,   477,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    32,    33,    34,     0,   478,
+     479,   480,   481,   482,   483,   484,   485,   486,   487,   488,
+     489,    35,     0,     0,    36,    37,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     8,     0,   670,     0,     0,     0,     0,     0,     0,
+      38,     0,     0,    39,    40,     0,     0,     0,     0,    41,
+       9,    10,    11,    12,    13,    14,    15,    16,    17,    18,
+      19,    20,     0,    21,    22,    23,    24,    25,     0,     0,
+       0,     0,     0,     0,     0,     0,    26,    27,    28,    29,
+      30,    31,   473,   474,   475,   476,     0,   477,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,    32,    33,
+      34,     0,   478,   479,   480,   481,   482,   483,   484,   485,
+     486,   487,   488,   489,    35,     0,     0,    36,    37,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,   203,     0,     8,     0,     0,     0,     0,     0,
+       0,     0,     0,    38,     0,     0,    39,    40,     0,     0,
+       0,     0,    41,     9,    10,    11,    12,    13,    14,    15,
+      16,    17,    18,    19,    20,     0,    21,    22,    23,    24,
+      25,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+      27,    28,    29,    30,    31,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,    32,    33,    34,     0,     8,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,    35,     0,     0,
+      36,    37,     0,     0,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,     0,    21,    22,    23,
+      24,    25,     0,     0,     0,     0,    38,     0,     0,     0,
+      40,    27,    28,    29,    30,    31,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,    32,    33,    34,     0,     0,     8,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,    35,   978,
+       0,    36,    37,     0,     0,     0,     9,    10,    11,    12,
+      13,    14,    15,    16,  1024,    18,  1025,    20,     0,  1026,
+      22,    23,    24,    25,     0,     0,     0,    38,     0,     0,
+       0,    40,   979,    27,    28,    29,    30,    31,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    32,    33,    34,     0,     0,     0,
+       8,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+      35,   258,     0,    36,    37,     0,     0,     0,     0,     9,
+      10,    11,    12,    13,    14,    15,    16,    17,    18,    19,
+      20,     0,    21,    22,    23,    24,    25,     0,     0,    38,
+       0,     0,     0,    40,   979,    26,    27,    28,    29,    30,
+      31,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,    32,    33,    34,
+       0,     8,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,    35,     0,     0,    36,    37,     0,     0,
+       9,    10,    11,    12,    13,    14,    15,    16,    17,    18,
+      19,    20,     0,    21,    22,    23,    24,    25,   237,     0,
+       0,     0,    38,     0,     0,    39,    40,    27,    28,    29,
+      30,    31,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,    32,    33,
+      34,     0,     8,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,    35,     0,     0,    36,    37,     0,
+       0,     9,    10,    11,    12,    13,    14,    15,    16,    17,
+      18,    19,    20,     0,    21,    22,    23,    24,    25,     0,
+       0,     0,     0,    38,     0,     0,     0,    40,    27,    28,
+      29,    30,    31,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,    32,
+      33,    34,     0,     8,     0,   786,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    35,   258,     0,    36,    37,
+       0,     0,     9,    10,    11,    12,    13,    14,    15,    16,
+      17,    18,    19,    20,     0,    21,    22,    23,    24,    25,
+       0,     0,     0,     0,    38,     0,     0,     0,    40,    27,
+      28,    29,    30,    31,   473,   474,   475,   476,     0,   477,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+      32,    33,    34,     8,   478,   479,   480,   481,   482,   483,
+     484,   485,   486,   487,   488,   489,    35,     0,     0,    36,
+      37,     0,     9,    10,    11,    12,    13,    14,    15,    16,
+      17,    18,    19,    20,     0,    21,    22,    23,    24,    25,
+       0,     0,     0,     0,     0,    38,     0,     0,     0,    40,
+       0,   792,    30,    31,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+      32,    33,    34,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    35,     0,     0,    36,
+      37,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+     473,   474,   475,   476,     0,   477,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    38,     0,     0,     0,    40,
+     478,   479,   480,   481,   482,   483,   484,   485,   486,   487,
+     488,   489
+};
+
+static const yytype_int16 yycheck[] =
+{
+       0,   164,    47,     5,    95,     5,   162,   152,   597,     5,
+     246,     1,     2,    72,   374,   195,     5,   144,   563,   154,
+      40,   201,   624,    45,   592,   578,    61,   207,   231,   711,
+     758,    47,   212,   865,   811,   547,    95,    96,   753,     5,
+     185,   186,     1,     2,   542,   557,   249,    47,     5,   393,
+       5,   101,   401,   168,   169,   557,     3,   667,     3,   669,
+     269,     5,   242,   178,     5,    41,    41,   986,     5,    40,
+      48,    71,   252,  1112,     6,     4,    76,    77,     5,   999,
+       3,    41,    41,   239,     6,   144,     6,     5,    49,    50,
+      51,    21,    44,     5,   144,     4,     6,     6,    84,    85,
+      42,     5,    61,   153,     3,    54,     6,     6,     5,    43,
+       5,    42,     5,     0,   114,    40,     5,    46,    46,    40,
+       5,    46,     6,     5,  1163,    77,    40,    76,   142,   174,
+       5,   176,    54,   111,    43,     5,    46,    46,     5,     3,
+     116,   116,   919,    43,    89,    90,   355,   167,   198,  1057,
+    1070,   307,   929,    85,   154,    85,   103,     5,     3,   712,
+     131,  1080,   104,     3,   154,    85,    89,    90,   128,   103,
+     759,   131,   328,   104,   174,    59,   176,   138,   213,   124,
+     125,   216,     3,   111,     3,   683,   118,    46,   204,    48,
+      89,    90,   192,   308,   309,   154,   119,   312,  1117,    48,
+     810,   545,   237,   162,    54,   114,   105,   106,   208,   103,
+     245,   374,   927,  1132,   128,    54,    54,   131,  1126,   568,
+     830,     4,   566,   239,   138,    89,    90,    43,    92,     3,
+      46,    43,   347,   348,    46,  1067,  1013,     3,  1146,   239,
+      43,   241,   242,     3,    89,    90,   246,  1155,    46,    89,
+      90,   115,   297,   103,   213,   119,   246,   216,    48,   259,
+     813,   261,    48,    46,    76,   103,    40,   995,    89,    90,
+      89,    90,    40,    76,    48,   957,    76,   116,   237,   119,
+     117,   297,   125,    57,  1145,     6,   245,   246,   117,     3,
+     858,   103,   308,   309,   115,   295,   312,   297,   119,   118,
+     119,   160,   814,   105,   106,   142,   341,   105,   106,   344,
+    1087,   170,   814,   142,   114,    89,    90,   408,  1179,    52,
+      53,    89,    90,    89,    90,    46,    40,   372,    43,    89,
+      90,    46,     1,   392,   469,    49,    50,    51,    71,    72,
+     103,   115,   401,   546,   580,   119,    52,    53,   307,   408,
+     506,    40,   118,   119,   128,   115,     3,   131,    77,   119,
+       4,     3,     6,    82,   138,    71,   140,   357,    57,   328,
+     103,    40,   372,   576,    47,    89,    90,   557,   493,   494,
+     495,    43,   341,    42,    46,   344,    40,   502,   503,    62,
+       4,  1168,     6,   393,    43,    54,   740,   512,   357,   434,
+     459,   115,    46,    57,    43,   119,   456,   563,   961,   444,
+     426,   427,   428,     3,    76,   983,     3,    47,   533,     3,
+     420,     4,     6,     6,     1,    52,   140,    40,   584,    76,
+      43,  1033,    62,    46,   454,    43,    52,    53,    46,   439,
+      43,   441,    89,    90,    71,   445,    54,    89,    90,   449,
+      40,    43,    42,    40,    46,    71,    72,    41,    48,   120,
+      43,    48,    54,    46,    54,    42,    43,    57,   115,    46,
+      57,    54,   119,   115,    40,   434,   511,   119,    43,   469,
+      40,   516,    48,    40,    40,   444,    76,   103,     4,    54,
+       6,   507,    40,   352,    40,    41,   138,    57,   654,    89,
+      90,    57,    89,    90,    40,    89,    90,  1052,    84,   568,
+     469,    57,   872,    40,   104,   550,    40,    49,    50,    51,
+      40,   105,   106,    40,    41,   115,    40,    41,   115,   119,
+      57,   128,   119,    57,   131,   125,   651,   572,   128,    40,
+      57,   131,   542,    57,    40,   545,    40,   563,   138,    40,
+     140,   541,   511,   140,  1143,    46,     3,   516,     3,    40,
+      41,    57,   564,   563,   564,    40,   566,   567,   564,   559,
+      40,    40,    41,   573,   969,   564,    57,   972,   567,   624,
+     439,    47,   541,    40,   606,   741,   445,   577,    57,    40,
+     580,   550,    21,    40,    40,    40,   128,    43,   564,   131,
+     559,    48,    49,    50,    51,   808,   809,   564,   624,   564,
+      57,   611,   612,   572,    40,    44,     3,    40,   577,   103,
+     564,   580,    43,   564,   624,    46,   626,   564,    43,     6,
+      80,    46,   116,   117,    41,    42,   816,   564,    88,    89,
+      90,    40,    89,    90,    89,    90,   564,   506,    77,    78,
+      79,    48,   564,    82,    48,    84,    85,    48,   142,    46,
+     564,   116,   721,   121,   122,   123,    48,   564,   115,   564,
+     115,   564,   119,    41,   119,   564,    49,    50,    51,   564,
+      42,   128,   564,   683,   131,    43,   688,    46,   688,   564,
+     725,   138,   688,   140,   564,   140,   162,   564,     6,   688,
+     835,    43,    89,    90,   170,    46,   706,    52,    53,   872,
+      42,   746,    41,    42,   714,   116,   564,   719,    48,   719,
+      41,    42,   688,   719,   769,   584,    71,    72,   115,    48,
+     719,   688,   119,   688,    89,    90,   827,    41,   738,   739,
+     740,   977,   742,   104,   688,   993,   994,   688,   111,   738,
+     895,   688,   774,   719,   104,    42,   758,    40,   758,   759,
+       7,   688,   719,   622,   719,    41,   725,   767,   827,   769,
+     688,    41,   738,   239,    48,   719,   688,   812,   719,   116,
+      57,   738,   719,   249,   688,    40,    48,   746,   647,   848,
+     840,   688,   719,   688,   738,   688,    48,    48,   848,   688,
+     927,   719,   661,   688,   138,   122,   688,   719,   667,   116,
+     669,   811,    43,   688,    41,   719,    41,    41,   688,   819,
+      41,   688,   719,    42,   719,    54,   719,   862,  1188,    43,
+     719,   297,    41,    41,   719,   835,   871,   719,    41,    41,
+     688,   307,  1005,    41,   719,   835,    41,   706,   850,   719,
+     850,    41,   719,   812,   850,   714,    41,   116,   858,  1169,
+     104,   850,   328,   865,    42,  1175,  1176,  1177,   927,   869,
+      41,   719,   338,  1018,   874,    43,   835,   927,   937,   116,
+      76,   881,  1192,   742,   850,    46,     3,   204,   134,   135,
+     136,   137,   138,   850,   894,   850,  1052,    48,     3,     3,
+     759,     3,    48,   862,    48,   371,   850,   952,    41,   850,
+     116,   116,   871,   850,   773,    43,    41,   976,    48,   919,
+     979,    48,   239,   850,   136,   137,   138,    48,    48,   929,
+      48,    43,   850,    46,    41,    40,    46,    43,   850,    40,
+      43,   258,    91,   260,     3,    41,   850,    73,    74,    75,
+      47,   810,   952,   850,    40,   850,    90,   850,    89,   959,
+     819,   850,    57,   111,    41,   850,   432,    78,   850,    48,
+      46,   830,    41,    41,    41,   850,    41,   977,   444,    42,
+     850,    40,    48,   850,    89,    90,   986,   977,  1033,    48,
+      48,    48,   458,   995,    48,   995,    48,   999,    57,   999,
+      48,  1001,   850,    48,     3,    42,    41,    40,    54,  1009,
+     115,  1011,  1012,  1013,   119,    43,    41,  1033,   977,   142,
+    1055,   103,  1185,    41,    47,  1188,    62,    42,    41,    41,
+      89,    90,    41,  1033,    40,   140,  1052,     3,    41,    41,
+     506,    40,    76,    48,    48,  1045,    41,    48,    48,    48,
+      43,    48,  1052,    41,  1089,    42,   115,    43,  1058,    41,
+     119,    46,    54,    47,    42,  1067,  1066,   140,  1070,    47,
+    1070,  1106,   439,    54,    40,    47,    54,    43,   445,    47,
+    1080,   140,    48,   125,    48,  1144,    76,  1087,    48,    47,
+      89,    90,  1092,    76,    41,  1130,  1055,   563,    42,    76,
+     959,    43,    43,    41,  1139,  1140,  1141,    42,   104,   125,
+      88,    89,    41,    43,    54,    48,   115,  1117,   584,    40,
+     119,    76,     3,    89,    90,     6,  1161,    76,  1128,    47,
+    1089,    76,  1132,    76,   132,   133,   134,   135,   136,   137,
+     138,   140,     3,  1143,   122,    76,    43,  1106,    43,   115,
+    1009,    43,    43,   119,  1154,    43,   622,  1157,   624,    40,
+     125,    43,   128,    42,    48,   131,    40,    48,  1168,  1169,
+     104,  1130,   138,   151,   140,  1175,  1176,  1177,    48,    40,
+    1139,  1140,  1141,    41,   162,    40,  1045,    48,   654,   506,
+     168,   169,  1192,   171,    43,    43,    57,    40,    48,  1058,
+     178,    41,  1161,    48,    41,    47,    41,  1066,    89,    90,
+       3,    40,    48,     6,    48,    41,     3,    41,    41,    41,
+      72,    46,    41,    43,   547,    43,   204,    48,    89,    90,
+      21,    48,   738,  1092,   115,   573,   977,    89,   119,   556,
+    1095,   580,   739,   560,   894,   223,   563,   128,   738,   738,
+     131,    41,   626,    44,   115,   835,   469,   138,   119,   140,
+     753,   239,  1001,   599,    52,  1128,   449,   584,   585,   247,
+     881,   249,   250,   251,  1012,   741,   254,  1143,  1122,   140,
+     258,   259,   260,   261,  1143,   186,    77,    78,    79,   722,
+      -1,    82,    -1,    84,    85,  1154,    89,    90,  1157,    -1,
+      -1,    -1,    89,    90,    -1,    -1,    -1,   773,   774,    -1,
+    1169,    -1,   105,   106,   165,   166,  1175,  1176,  1177,   297,
+      -1,    -1,   115,    49,    50,    51,   119,   118,   115,   307,
+     308,   309,   119,  1192,   312,   128,    -1,   654,   131,   706,
+      -1,   128,    -1,   195,   131,   138,    -1,   714,   200,   201,
+     328,   138,   330,    70,    80,   207,    -1,   209,   210,    -1,
+     212,    -1,    88,    89,    90,    -1,    -1,    -1,    -1,   347,
+     348,    -1,    -1,    -1,   352,   742,   228,    94,    -1,   231,
+     232,    -1,    99,    -1,    -1,   169,   364,    -1,    -1,    -1,
+     242,    -1,   759,   371,   178,   712,    -1,   249,    -1,    -1,
+     252,    -1,   128,   381,    -1,   131,     3,   259,    -1,    -1,
+      -1,    -1,    -1,    -1,   266,    -1,   394,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,   741,     3,    -1,    -1,    -1,    -1,
+      -1,    -1,   283,    -1,   285,   286,   287,   288,   289,   290,
+     291,    -1,    -1,    40,    -1,    -1,   107,   108,   426,   427,
+     428,    48,   819,    -1,   432,    -1,    -1,   435,   436,     3,
+     438,    -1,    40,    -1,    -1,     3,   444,   251,   319,    -1,
+     254,   132,   133,   134,   135,   136,   137,   138,   195,    57,
+      -1,    -1,    -1,   200,   201,    -1,    -1,    -1,    -1,    -1,
+     207,   342,    89,    90,   345,   212,    40,    -1,   815,    43,
+      -1,    -1,    40,    -1,    48,    -1,    -1,   824,    -1,    -1,
+      48,    89,    90,    -1,   231,    -1,    54,   495,   115,    57,
+      -1,    -1,   119,    -1,    -1,   242,   243,    -1,   506,   507,
+      -1,   248,   249,    -1,   512,   252,    -1,   115,    76,    -1,
+      -1,   119,    -1,   140,    -1,    89,    90,    -1,    -1,    -1,
+     128,    89,    90,   131,    -1,   533,    -1,    -1,   536,    -1,
+     877,    -1,   140,   347,   348,    -1,    -1,  1033,   352,    -1,
+      -1,   115,    -1,    -1,    -1,   119,    -1,   115,   556,    -1,
+      -1,   119,   560,    -1,   128,   563,  1052,   131,  1054,  1055,
+     128,    -1,   959,   131,   138,    -1,   140,    -1,    -1,    -1,
+     138,    -1,   140,    -1,    -1,    -1,   584,   585,   586,    -1,
+      -1,    -1,   590,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,   473,   474,   475,   476,   477,   478,   479,   480,
+     481,   482,   483,   484,   485,   486,   487,   488,   489,   617,
+      -1,    -1,  1009,   960,    -1,    -1,   624,    -1,    -1,    -1,
+      -1,   435,   436,    -1,   438,    -1,    -1,   508,    -1,    -1,
+      -1,   978,    -1,   980,    -1,    -1,   517,    -1,    -1,    -1,
+       3,     4,    -1,     6,    -1,    -1,   654,    -1,  1045,    -1,
+      -1,   998,    -1,   661,   662,    -1,    -1,    -1,   666,    -1,
+      -1,  1058,    -1,   671,   546,    -1,    -1,    -1,   676,  1066,
+      -1,    -1,    -1,    -1,  1021,   557,    -1,    40,    -1,    -1,
+      43,    -1,    -1,    46,    -1,    48,    -1,    -1,    -1,    -1,
+      -1,    -1,   574,    -1,   576,  1092,    -1,    -1,   512,     6,
+      -1,    -1,    -1,    -1,   712,  1052,    13,    14,    15,    16,
+      17,    18,    19,    20,    -1,    -1,     3,    -1,    -1,   533,
+      -1,    -1,   536,    -1,    -1,    -1,    89,    90,    -1,   737,
+      -1,    -1,    -1,   741,    -1,    -1,   744,    -1,   619,   620,
+     621,   622,    -1,    -1,    -1,   753,  1143,     3,  1095,     3,
+      -1,   114,   115,    40,    -1,    -1,   119,  1154,    -1,    -1,
+      -1,    48,    49,    50,    51,   128,    -1,    -1,   131,    -1,
+      -1,    -1,   586,    -1,    -1,   138,   590,   140,    -1,    -1,
+      -1,     3,    -1,    -1,    40,    -1,    40,    43,    -1,   797,
+     798,    -1,    48,    -1,    48,   803,   543,    -1,    -1,   546,
+     547,    -1,    89,    90,    -1,    -1,    -1,   815,   555,   556,
+     557,    -1,    -1,    -1,    -1,    -1,   824,     3,    40,    -1,
+      -1,    43,    -1,    -1,    -1,    -1,    48,    -1,   115,   576,
+      -1,   578,   119,    89,    90,    89,    90,    -1,   585,   721,
+      -1,   128,    -1,    -1,   131,    -1,    -1,   661,   662,    -1,
+      -1,     3,   666,   140,    40,    -1,    -1,   671,    -1,   115,
+      -1,   115,   676,   119,    -1,   119,   747,    89,    90,   877,
+      -1,    57,   128,    -1,    -1,   131,    -1,   885,    -1,    -1,
+      -1,    -1,   138,    -1,   140,    -1,   140,    -1,    40,    -1,
+     771,   772,   773,   115,   775,    -1,    48,   119,    -1,    -1,
+     781,    -1,    -1,    89,    90,    -1,   128,    -1,     3,   131,
+      -1,    -1,    -1,    -1,    -1,    -1,   138,    -1,   140,   927,
+      -1,    -1,    -1,     3,    -1,    -1,   808,   809,    -1,   115,
+     744,    -1,    -1,   119,   816,    -1,   944,    89,    90,    -1,
+     948,   949,    -1,    -1,    -1,    40,    -1,    -1,    -1,   831,
+     832,   833,   960,    48,   140,    -1,     3,    -1,    -1,    -1,
+      40,    -1,    57,   115,    -1,   712,    -1,   119,    48,    -1,
+     978,    -1,   980,   720,    -1,   722,   128,    -1,     3,   131,
+      -1,    -1,    -1,   797,   798,   867,   138,    -1,   140,   803,
+     998,    -1,     3,    40,    89,    90,    -1,    -1,  1006,    -1,
+      -1,    48,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    89,
+      90,    -1,     3,  1021,    -1,    40,    -1,    -1,    -1,    -1,
+     115,    -1,    -1,    48,   119,  1033,    -1,  1035,  1036,    40,
+      -1,    -1,    57,   128,    -1,   115,   131,    48,    -1,   119,
+      -1,    -1,    89,    90,  1052,   140,    -1,  1055,   128,    40,
+      -1,   131,    -1,   934,   935,    -1,    -1,    48,   138,    -1,
+     140,   808,   809,    -1,    89,    90,   813,   814,   115,   816,
+      -1,    -1,   119,    -1,    -1,    -1,    -1,  1085,    89,    90,
+      -1,   128,    -1,    -1,   131,    -1,    -1,  1095,    -1,    -1,
+     115,   138,   839,   140,   119,    -1,    -1,    -1,    89,    90,
+      -1,    -1,    -1,   128,   115,    -1,   131,    -1,   119,    -1,
+      -1,   993,   994,    -1,  1122,   140,    -1,   128,    -1,    -1,
+     131,    -1,    -1,    -1,   115,    -1,    -1,   138,   119,   140,
+     944,    -1,    40,    -1,   948,   949,    -1,   128,    -1,    -1,
+     131,    49,    50,    51,    -1,    -1,    54,    -1,    -1,   140,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,     1,    -1,     3,
+       4,    -1,    80,    -1,     8,     9,    10,    -1,    -1,    -1,
+      88,    89,    90,  1064,    -1,    -1,  1068,    21,    22,    23,
+      24,    25,    26,    27,    28,    29,    30,    31,    32,    33,
+      -1,    35,    36,    37,    38,    39,    -1,    -1,    -1,    43,
+      44,    -1,  1093,    47,   961,    49,    50,    51,    52,    53,
+     128,  1035,  1036,   131,    -1,    -1,    -1,    -1,    62,    63,
+      64,    65,    66,    67,    68,    69,    70,    71,    72,    73,
+      74,    75,    -1,    77,    78,    79,    -1,    81,    82,    83,
+      84,    85,    86,    87,    -1,    89,    90,    91,    -1,     3,
+      -1,    95,     6,    97,    98,    99,   100,   101,   102,    13,
+      14,    15,    16,    17,    18,    19,    20,    -1,    -1,   113,
+      -1,   115,    -1,    -1,   118,   119,   120,    -1,     3,    -1,
+     124,     6,     7,    -1,    -1,    -1,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,   140,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    -1,
+      35,    36,    37,    38,    39,    40,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    48,    49,    50,    51,    52,    53,    -1,
+      55,    -1,    -1,    -1,    -1,    89,    90,    -1,    -1,    -1,
+      -1,   107,   108,   109,   110,    70,    71,    72,    -1,    -1,
+      -1,   105,   106,    -1,   107,   108,   109,   110,    -1,   112,
+      -1,    86,    -1,    -1,    89,    90,   132,   133,   134,   135,
+     136,   137,   138,    -1,   127,   128,   129,   130,   131,   132,
+     133,   134,   135,   136,   137,   138,    -1,    -1,    -1,    -1,
+     115,    -1,    -1,   118,   119,    -1,    -1,    -1,    -1,   124,
+      -1,    -1,    -1,   128,    -1,    -1,   131,    -1,     3,   134,
+     135,     6,     7,   138,   139,   140,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    -1,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    -1,
+      35,    36,    37,    38,    39,    40,    -1,    76,    -1,    -1,
+      -1,    -1,    -1,    -1,    49,    50,    51,    52,    53,    -1,
+      55,    -1,    -1,    58,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    70,    71,    72,   107,   108,
+     109,   110,    -1,   112,    -1,    -1,    -1,   107,   108,   109,
+     110,    86,     3,    -1,    89,    90,    -1,    -1,   127,   128,
+     129,   130,   131,   132,   133,   134,   135,   136,   137,   138,
+     130,   131,   132,   133,   134,   135,   136,   137,   138,    -1,
+     115,    -1,    -1,    -1,   119,    -1,    -1,    -1,    -1,    40,
+      -1,    -1,    -1,   128,    -1,    -1,   131,    48,     3,   134,
+     135,     6,     7,   138,   139,   140,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    -1,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    -1,
+      35,    36,    37,    38,    39,    40,    -1,    -1,    89,    90,
+      -1,    -1,    -1,    -1,    49,    50,    51,    52,    53,    -1,
+      55,    -1,    -1,    58,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,   115,    70,    71,    72,   119,    -1,
+     107,   108,   109,   110,    -1,    -1,    -1,   128,    -1,    -1,
+     131,    86,     3,    -1,    89,    90,    -1,    -1,    -1,   140,
+     127,   128,   129,   130,   131,   132,   133,   134,   135,   136,
+     137,   138,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+     115,    -1,    -1,    -1,   119,    -1,    -1,    -1,    -1,    40,
+      -1,    -1,    -1,   128,    -1,    -1,   131,    48,     3,   134,
+     135,     6,     7,   138,   139,   140,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    -1,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    -1,
+      35,    36,    37,    38,    39,    40,    -1,    -1,    89,    90,
+      -1,    -1,    -1,    -1,    49,    50,    51,    52,    53,    -1,
+      55,    -1,    -1,    58,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,   115,    70,    71,    72,   119,   107,
+     108,   109,   110,    -1,    -1,    -1,    -1,   128,    -1,    -1,
+     131,    86,     3,    -1,    89,    90,    -1,    -1,    -1,   140,
+     128,   129,   130,   131,   132,   133,   134,   135,   136,   137,
+     138,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+     115,    -1,    -1,    -1,   119,    -1,    -1,    -1,    -1,    40,
+      -1,    -1,    -1,   128,    -1,    -1,   131,    48,     3,   134,
+     135,     6,     7,   138,   139,   140,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    -1,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    -1,
+      35,    36,    37,    38,    39,    40,    -1,    -1,    89,    90,
+      -1,    -1,    -1,    -1,    49,    50,    51,    52,    53,    -1,
+      55,    -1,    -1,    58,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,   115,    70,    71,    72,   119,   107,
+     108,   109,   110,    -1,    -1,    -1,    -1,   107,   108,   109,
+     110,    86,     3,    -1,    89,    90,    -1,    -1,    -1,   140,
+      -1,   129,   130,   131,   132,   133,   134,   135,   136,   137,
+     138,   131,   132,   133,   134,   135,   136,   137,   138,    -1,
+     115,    -1,    -1,    -1,   119,    -1,    -1,    -1,    -1,    40,
+      -1,    -1,    -1,   128,    -1,    -1,   131,    48,     3,   134,
+     135,     6,     7,   138,   139,   140,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    -1,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    -1,
+      35,    36,    37,    38,    39,    40,    41,    -1,    89,    90,
+      -1,    -1,    -1,    -1,    49,    50,    51,    52,    53,    -1,
+      55,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,   115,    70,    71,    72,   119,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    86,     3,    -1,    89,    90,    -1,    -1,    -1,   140,
+      22,    23,    24,    25,    26,    27,    28,    29,    -1,    31,
+      -1,    33,    -1,    -1,    36,    37,    38,    39,    -1,    -1,
+     115,    -1,    -1,    -1,   119,    -1,    -1,    -1,    -1,    40,
+      -1,    -1,    -1,   128,    -1,    -1,   131,    48,     3,   134,
+     135,     6,     7,   138,   139,   140,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    -1,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    -1,
+      35,    36,    37,    38,    39,    40,    41,    -1,    89,    90,
+      -1,    -1,    -1,    -1,    49,    50,    51,    52,    53,    -1,
+      55,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,   115,    70,    71,    72,   119,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    86,    -1,    -1,    89,    90,    -1,    -1,    -1,   140,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+     115,    -1,    -1,    -1,   119,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,   128,    -1,    -1,   131,    -1,     3,   134,
+     135,     6,     7,   138,   139,   140,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    -1,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    -1,
+      35,    36,    37,    38,    39,    40,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    49,    50,    51,    52,    53,    -1,
+      55,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    70,    71,    72,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    86,    -1,    -1,    89,    90,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+     115,    -1,    -1,    -1,   119,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,   128,    -1,    -1,   131,    -1,     3,   134,
+     135,     6,     7,   138,   139,   140,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,     3,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    -1,
+      35,    36,    37,    38,    39,    40,    -1,    -1,     3,    -1,
+      -1,    -1,    -1,    -1,    49,    50,    51,    52,    53,    -1,
+      55,    -1,    -1,    40,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    70,    71,    72,    -1,    -1,
+      57,    -1,    -1,    -1,    -1,    40,    -1,    -1,    -1,    -1,
+      -1,    86,    -1,    48,    89,    90,    -1,    -1,    -1,    -1,
+      -1,    -1,    57,    -1,    -1,    -1,    -1,    -1,    -1,     4,
+      -1,    -1,    89,    90,    -1,    10,    -1,    -1,    -1,    -1,
+     115,    -1,    -1,    -1,   119,    -1,    21,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    89,    90,    -1,    -1,   115,   134,
+     135,    -1,   119,   138,   139,   140,    -1,    -1,    43,    44,
+      -1,   128,    -1,    -1,   131,    -1,    -1,    -1,    -1,    -1,
+     115,    -1,    -1,   140,   119,    -1,    -1,    62,    63,    64,
+      65,    -1,    67,    68,    69,    -1,    -1,    -1,    73,    74,
+      75,    -1,    77,    78,    79,   140,    81,    82,    83,    84,
+      85,    -1,    -1,    -1,    -1,    -1,    91,    -1,    -1,    -1,
+      95,    -1,    97,    98,    99,   100,   101,   102,    -1,    -1,
+      -1,    -1,    -1,    -1,     3,    -1,     3,    -1,   113,    41,
+      -1,    -1,    -1,   118,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    22,    23,    24,    25,    26,    27,    28,
+      29,    30,    31,    32,    33,   140,    35,    36,    37,    38,
+      39,    40,    -1,    40,    -1,    -1,    -1,    -1,    -1,    48,
+      49,    50,    51,    52,    53,    -1,    -1,    -1,    57,    -1,
+      57,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    70,    71,    72,    -1,   107,   108,   109,   110,    -1,
+     112,    -1,    -1,    -1,    -1,    -1,    -1,    86,    -1,    -1,
+      89,    90,    89,    90,    -1,   127,   128,   129,   130,   131,
+     132,   133,   134,   135,   136,   137,   138,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,   115,    -1,   115,   118,
+     119,     3,   119,    -1,    -1,   124,    41,    -1,    -1,   128,
+      -1,   128,   131,    -1,   131,    -1,    -1,    -1,    -1,   138,
+      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
+      32,    33,    -1,    35,    36,    37,    38,    39,    40,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    48,    49,    50,    51,
+      52,    53,    -1,    -1,    -1,    57,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    70,    71,
+      72,    -1,   107,   108,   109,   110,    -1,   112,    -1,    -1,
+      -1,    -1,    -1,    -1,    86,    -1,    -1,    89,    90,    -1,
+      -1,    -1,   127,   128,   129,   130,   131,   132,   133,   134,
+     135,   136,   137,   138,    -1,    43,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,   115,    -1,    -1,   118,   119,     3,    -1,
+      -1,    -1,   124,    -1,    -1,    -1,   128,    -1,    -1,   131,
+      -1,    -1,    -1,    -1,    -1,    -1,   138,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    -1,
+      35,    36,    37,    38,    39,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    48,    49,    50,    51,    52,    53,   107,
+     108,   109,   110,    -1,   112,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    70,    71,    72,     3,   127,
+     128,   129,   130,   131,   132,   133,   134,   135,   136,   137,
+     138,    86,    -1,    -1,    89,    90,    -1,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    -1,
+      35,    36,    37,    38,    39,    -1,    -1,    -1,    -1,    -1,
+     115,    -1,    -1,   118,   119,    -1,    -1,    52,    53,   124,
+      -1,    -1,    -1,   128,    -1,    -1,   131,    -1,    -1,    -1,
+      -1,    -1,    -1,   138,    -1,    70,    71,    72,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    86,    -1,    -1,    89,    90,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     0,
+       1,    -1,     3,     4,    -1,    -1,    -1,     8,     9,    10,
+     115,    -1,    -1,    -1,   119,    -1,    -1,    -1,    -1,    -1,
+      21,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,   138,    35,    36,    37,    38,    39,    -1,
+      -1,    -1,    43,    44,    -1,    -1,    -1,    -1,    49,    50,
+      51,    52,    53,    -1,    -1,    56,    -1,    -1,    -1,    -1,
+      -1,    62,    63,    64,    65,    66,    67,    68,    69,    70,
+      71,    72,    -1,    -1,    -1,    -1,    77,    78,    79,    -1,
+      81,    82,    83,    84,    85,    86,    87,    -1,    89,    90,
+      91,    92,    93,    94,    95,    96,    97,    98,    99,   100,
+     101,   102,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,   113,     1,   115,     3,     4,   118,   119,    -1,
+       8,     9,    10,   124,   125,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    21,    22,    23,    24,    25,    26,    27,
+      28,    29,    30,    31,    32,    33,    -1,    35,    36,    37,
+      38,    39,    -1,    -1,    -1,    43,    44,    -1,    -1,    47,
+      -1,    49,    50,    51,    52,    53,    -1,    -1,    56,    -1,
+      -1,    -1,    -1,    -1,    62,    63,    64,    65,    66,    67,
+      68,    69,    70,    71,    72,    -1,    -1,    -1,    -1,    77,
+      78,    79,    -1,    81,    82,    83,    84,    85,    86,    87,
+      -1,    89,    90,    91,    92,    93,    94,    95,    96,    97,
+      98,    99,   100,   101,   102,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,   113,     1,   115,     3,     4,
+     118,   119,    -1,     8,     9,    10,   124,   125,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    -1,
+      35,    36,    37,    38,    39,    -1,    -1,    -1,    43,    44,
+      -1,    -1,    47,    -1,    49,    50,    51,    52,    53,    -1,
+      -1,    56,    -1,    -1,    -1,    -1,    -1,    62,    63,    64,
+      65,    66,    67,    68,    69,    70,    71,    72,    -1,    -1,
+      -1,    -1,    77,    78,    79,    -1,    81,    82,    83,    84,
+      85,    86,    87,    -1,    89,    90,    91,    92,    93,    94,
+      95,    96,    97,    98,    99,   100,   101,   102,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,   113,     1,
+     115,     3,     4,   118,   119,    -1,     8,     9,    10,   124,
+     125,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    21,
+      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
+      32,    33,    -1,    35,    36,    37,    38,    39,    -1,    -1,
+      -1,    43,    44,    -1,    -1,    47,    -1,    49,    50,    51,
+      52,    53,    -1,    -1,    56,    -1,    -1,    -1,    -1,    -1,
+      62,    63,    64,    65,    66,    67,    68,    69,    70,    71,
+      72,    -1,    -1,    -1,    -1,    77,    78,    79,    -1,    81,
+      82,    83,    84,    85,    86,    87,    -1,    89,    90,    91,
+      92,    93,    94,    95,    96,    97,    98,    99,   100,   101,
+     102,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,   113,     1,   115,     3,     4,   118,   119,    -1,     8,
+       9,    10,   124,   125,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    21,    22,    23,    24,    25,    26,    27,    28,
+      29,    30,    31,    32,    33,    -1,    35,    36,    37,    38,
+      39,    -1,    -1,    -1,    43,    44,    -1,    -1,    -1,    -1,
+      49,    50,    51,    52,    53,    -1,    -1,    56,    -1,    -1,
+      -1,    60,    -1,    62,    63,    64,    65,    66,    67,    68,
+      69,    70,    71,    72,    -1,    -1,    -1,    -1,    77,    78,
+      79,    -1,    81,    82,    83,    84,    85,    86,    87,    -1,
+      89,    90,    91,    92,    93,    94,    95,    96,    97,    98,
+      99,   100,   101,   102,    -1,    -1,     1,    -1,     3,    -1,
+      58,    -1,    -1,    -1,   113,    -1,   115,    -1,    -1,   118,
+     119,    -1,    -1,    -1,    -1,   124,   125,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    -1,
+      35,    36,    37,    38,    39,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    48,    49,    50,    51,    52,    53,   107,
+     108,   109,   110,    -1,   112,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    70,    71,    72,    -1,   127,
+     128,   129,   130,   131,   132,   133,   134,   135,   136,   137,
+     138,    86,    -1,    -1,    89,    90,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     1,
+      -1,     3,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+     115,    -1,    -1,   118,   119,    -1,    -1,    -1,    -1,   124,
+      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
+      32,    33,    -1,    35,    36,    37,    38,    39,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    48,    49,    50,    51,
+      52,    53,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    70,    71,
+      72,    -1,    -1,     3,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    86,    -1,    -1,    89,    90,    -1,
+      -1,    -1,    22,    23,    24,    25,    26,    27,    28,    29,
+      30,    31,    32,    33,     3,    35,    36,    37,    38,    39,
+      -1,    -1,    -1,   115,    -1,    -1,   118,   119,    -1,    -1,
+      -1,    -1,   124,    22,    23,    24,    25,    26,    27,    28,
+      29,    30,    31,    32,    33,    -1,    35,    36,    37,    38,
+      39,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    48,
+      49,    50,    51,    52,    53,    -1,    86,    -1,    -1,    89,
+      90,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    70,    71,    72,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,   115,    -1,    86,    -1,   119,
+      89,    90,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,     3,    -1,
+      58,    -1,    -1,    -1,    -1,    -1,   115,    -1,    13,   118,
+     119,    -1,    -1,    -1,    -1,   124,   125,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    -1,
+      35,    36,    37,    38,    39,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    48,    49,    50,    51,    52,    53,   107,
+     108,   109,   110,    -1,   112,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    70,    71,    72,    -1,   127,
+     128,   129,   130,   131,   132,   133,   134,   135,   136,   137,
+     138,    86,    -1,    -1,    89,    90,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,     3,    -1,    58,    -1,    -1,    -1,    -1,    -1,    -1,
+     115,    -1,    -1,   118,   119,    -1,    -1,    -1,    -1,   124,
+      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
+      32,    33,    -1,    35,    36,    37,    38,    39,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    48,    49,    50,    51,
+      52,    53,   107,   108,   109,   110,    -1,   112,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    70,    71,
+      72,    -1,   127,   128,   129,   130,   131,   132,   133,   134,
+     135,   136,   137,   138,    86,    -1,    -1,    89,    90,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,     1,    -1,     3,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,   115,    -1,    -1,   118,   119,    -1,    -1,
+      -1,    -1,   124,    22,    23,    24,    25,    26,    27,    28,
+      29,    30,    31,    32,    33,    -1,    35,    36,    37,    38,
+      39,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      49,    50,    51,    52,    53,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    70,    71,    72,    -1,     3,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    86,    -1,    -1,
+      89,    90,    -1,    -1,    22,    23,    24,    25,    26,    27,
+      28,    29,    30,    31,    32,    33,    -1,    35,    36,    37,
+      38,    39,    -1,    -1,    -1,    -1,   115,    -1,    -1,    -1,
+     119,    49,    50,    51,    52,    53,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    70,    71,    72,    -1,    -1,     3,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    86,    87,
+      -1,    89,    90,    -1,    -1,    -1,    22,    23,    24,    25,
+      26,    27,    28,    29,    30,    31,    32,    33,    -1,    35,
+      36,    37,    38,    39,    -1,    -1,    -1,   115,    -1,    -1,
+      -1,   119,   120,    49,    50,    51,    52,    53,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    70,    71,    72,    -1,    -1,    -1,
+       3,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      86,    87,    -1,    89,    90,    -1,    -1,    -1,    -1,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    -1,    35,    36,    37,    38,    39,    -1,    -1,   115,
+      -1,    -1,    -1,   119,   120,    48,    49,    50,    51,    52,
+      53,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    70,    71,    72,
+      -1,     3,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    86,    -1,    -1,    89,    90,    -1,    -1,
+      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
+      32,    33,    -1,    35,    36,    37,    38,    39,    40,    -1,
+      -1,    -1,   115,    -1,    -1,   118,   119,    49,    50,    51,
+      52,    53,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    70,    71,
+      72,    -1,     3,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    86,    -1,    -1,    89,    90,    -1,
+      -1,    22,    23,    24,    25,    26,    27,    28,    29,    30,
+      31,    32,    33,    -1,    35,    36,    37,    38,    39,    -1,
+      -1,    -1,    -1,   115,    -1,    -1,    -1,   119,    49,    50,
+      51,    52,    53,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    70,
+      71,    72,    -1,     3,    -1,    58,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    86,    87,    -1,    89,    90,
+      -1,    -1,    22,    23,    24,    25,    26,    27,    28,    29,
+      30,    31,    32,    33,    -1,    35,    36,    37,    38,    39,
+      -1,    -1,    -1,    -1,   115,    -1,    -1,    -1,   119,    49,
+      50,    51,    52,    53,   107,   108,   109,   110,    -1,   112,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      70,    71,    72,     3,   127,   128,   129,   130,   131,   132,
+     133,   134,   135,   136,   137,   138,    86,    -1,    -1,    89,
+      90,    -1,    22,    23,    24,    25,    26,    27,    28,    29,
+      30,    31,    32,    33,    -1,    35,    36,    37,    38,    39,
+      -1,    -1,    -1,    -1,    -1,   115,    -1,    -1,    -1,   119,
+      -1,    58,    52,    53,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      70,    71,    72,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    -1,    86,    -1,    -1,    89,
+      90,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,
+     107,   108,   109,   110,    -1,   112,    -1,    -1,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,   115,    -1,    -1,    -1,   119,
+     127,   128,   129,   130,   131,   132,   133,   134,   135,   136,
+     137,   138
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const yytype_uint16 yystos[] =
+{
+       0,   121,   122,   123,   144,   145,   325,     1,     3,    22,
+      23,    24,    25,    26,    27,    28,    29,    30,    31,    32,
+      33,    35,    36,    37,    38,    39,    48,    49,    50,    51,
+      52,    53,    70,    71,    72,    86,    89,    90,   115,   118,
+     119,   124,   195,   239,   240,   256,   257,   259,   260,   261,
+     262,   263,   264,   295,   296,   310,   313,   315,     1,   240,
+       1,    40,     0,     1,     4,     8,     9,    10,    21,    43,
+      44,    56,    62,    63,    64,    65,    66,    67,    68,    69,
+      77,    78,    79,    81,    82,    83,    84,    85,    91,    92,
+      93,    94,    95,    96,    97,    98,    99,   100,   101,   102,
+     113,   118,   124,   125,   146,   147,   148,   150,   151,   152,
+     153,   154,   157,   158,   160,   161,   162,   163,   164,   165,
+     166,   169,   170,   171,   174,   176,   181,   182,   183,   184,
+     186,   190,   197,   198,   199,   200,   201,   205,   206,   213,
+     214,   226,   227,   234,   235,   325,    48,    52,    71,    48,
+      48,    40,   142,   103,   103,   309,   239,   313,   125,    43,
+     260,   256,    40,    48,    54,    57,    76,   119,   128,   131,
+     138,   140,   245,   246,   248,   250,   251,   252,   253,   313,
+     325,   256,   263,   313,   309,   117,   142,   314,    43,    43,
+     236,   237,   240,   325,   120,    40,     6,    85,   118,   319,
+      40,   322,   325,     1,   258,   259,   310,    40,   322,    40,
+     168,   325,    40,    40,    84,    85,    40,    84,    40,    77,
+      82,    44,    77,    92,   313,    46,   310,   313,    40,     4,
+      46,    40,    40,    43,    46,     4,   319,    40,   180,   258,
+     178,   180,    40,    40,   319,    40,   103,   296,   322,    40,
+     128,   131,   248,   250,   253,   313,    21,    85,    87,   195,
+     258,   296,    48,    48,    48,   313,   118,   119,   315,   316,
+     296,     3,     7,    11,    12,    13,    14,    15,    16,    17,
+      18,    19,    20,    40,    55,   128,   131,   134,   135,   138,
+     139,   140,   240,   241,   242,   244,   258,   259,   280,   281,
+     282,   283,   284,   319,   320,   325,   256,    40,   128,   131,
+     236,   251,   253,   313,    48,    46,   105,   106,   265,   266,
+     267,   268,   269,    58,   280,   282,   280,     3,    40,    48,
+     140,   249,   252,   313,    48,   249,   252,   253,   256,   313,
+     245,    40,    57,   245,    40,    57,    48,   128,   131,   249,
+     252,   313,   116,   315,   119,   316,    41,    42,   238,   325,
+     267,   310,   311,   319,   296,     6,    46,   311,   323,   311,
+      43,    40,   248,   250,    54,    41,   311,    52,    53,    71,
+     297,   298,   325,   310,   310,   311,    13,   175,   236,   236,
+     313,    43,    54,   216,    54,    46,   310,   177,   323,   310,
+     236,    46,   247,   248,   250,   251,   325,    43,    42,   179,
+     325,   311,   312,   325,   155,   156,   319,   236,   209,   210,
+     211,   240,   295,   325,   313,   319,   128,   131,   253,   310,
+     313,   323,    40,   311,    40,   128,   131,   313,   116,   248,
+     313,   270,   310,   325,    40,   248,    76,   287,   288,   313,
+     325,    48,    48,    41,   310,   314,   104,   111,   280,    40,
+      48,   280,   280,   280,   280,   280,   280,   280,   104,    42,
+     243,   325,    40,   107,   108,   109,   110,   112,   127,   128,
+     129,   130,   131,   132,   133,   134,   135,   136,   137,   138,
+      48,   111,     7,   128,   131,   253,   313,   250,   313,   250,
+      41,    41,   128,   131,   250,   313,   116,    48,    57,   280,
+      58,    40,   253,   313,    48,   313,    40,    57,    48,   253,
+     236,    58,   280,   236,    58,   280,    48,    48,   249,   252,
+      48,   249,   252,   116,    48,   128,   131,   249,   256,   314,
+      43,   125,   240,    41,   313,   185,    42,    54,    41,   245,
+      40,   265,    41,   313,    41,    54,    41,    42,   173,    42,
+      41,    41,    43,   258,   145,   313,   215,    41,    41,    41,
+      41,   178,    40,   180,    41,    41,    42,    46,    41,   104,
+      42,   212,   325,    59,   116,    41,   253,   313,    43,   236,
+     116,    80,    88,    89,    90,   128,   131,   254,   255,   256,
+     300,   302,   303,   304,   325,    54,    76,   196,   325,   236,
+     313,   304,   289,    46,    43,   287,   309,   296,     3,    41,
+     128,   131,   138,   253,   258,    48,   244,   280,   280,   280,
+     280,   280,   280,   280,   280,   280,   280,   280,   280,   280,
+     280,   280,   280,   280,     3,     3,   313,   116,    41,    41,
+      41,   116,   248,   251,   256,   250,   280,   236,   249,   313,
+      41,   116,    48,   236,    58,   280,    48,    41,    58,    41,
+      58,    48,    48,    48,    48,   128,   131,   249,   252,    48,
+      48,    48,   249,   240,   238,     4,    46,   319,   145,   323,
+     155,   283,   319,   324,    43,   236,    43,    46,     4,   167,
+     319,     4,    43,    46,   114,   172,   248,   319,   321,   311,
+     319,   324,    41,   240,   248,    46,   247,    47,    43,   145,
+      44,   235,   178,    43,    46,    40,    47,   236,   179,   115,
+     119,   310,   317,    43,   323,   240,   172,    91,   207,   211,
+     159,   256,   248,   319,   116,    41,    40,    40,   300,    90,
+      89,   302,   255,   111,    57,   191,   260,    43,    46,    41,
+     188,   245,    78,   290,   291,   299,   325,   203,    46,   313,
+     280,    41,    41,   138,   256,    41,   128,   131,   246,    48,
+     243,    76,    41,    41,   248,   251,    58,    41,    41,   249,
+     249,    41,    58,   249,   254,   254,   249,    48,    48,    48,
+      48,    48,   249,    48,    48,    48,   238,    47,    42,    42,
+      41,   149,    40,   304,    54,    41,    42,   173,   172,   248,
+     304,    43,    47,   319,   258,   310,    43,    54,   321,   236,
+      41,   142,   117,   142,   318,   103,    41,    47,   313,    44,
+     118,   186,   201,   205,   206,   208,   223,   225,   235,   212,
+     145,   304,    43,   236,   280,    30,    32,    35,   189,   261,
+     262,   313,    40,    46,   192,   152,   271,   272,   274,   276,
+     325,    40,    54,   302,   304,   305,     1,    42,    43,    46,
+     187,    42,    73,    74,    75,   292,   294,     1,    43,    66,
+      73,    74,    75,    78,   124,   140,   150,   151,   152,   153,
+     157,   158,   162,   164,   166,   169,   171,   174,   176,   181,
+     182,   183,   184,   201,   205,   206,   213,   217,   221,   222,
+     223,   224,   225,   226,   228,   229,   232,   235,   325,   202,
+     245,   280,   280,   280,    41,    41,    41,    40,   280,    41,
+      41,    41,   249,   249,    48,    48,    48,   249,    48,    48,
+     323,   323,   254,   217,   236,   172,   319,   324,    43,   248,
+      41,   304,    43,   248,    43,   180,    41,   254,   119,   310,
+     310,   119,   310,   241,     4,    46,    54,   103,    87,   120,
+     258,    60,    43,    41,    41,   300,   301,   325,   236,    40,
+      43,   193,   271,   124,   125,   277,   278,   310,    47,    42,
+     273,   275,   325,   236,   265,    54,    76,   306,   325,   248,
+     291,   313,   293,   220,    46,    76,    76,    76,   140,   221,
+     315,    47,   125,   217,    30,    32,    35,   233,   262,   313,
+     217,   280,   280,   258,   249,    48,    48,   249,   249,   245,
+      47,    41,   173,   304,    43,   248,   172,    43,    43,   318,
+     318,   104,   258,   209,   258,    40,   300,   188,    41,   194,
+     278,   278,   272,   125,    54,    43,   248,   152,   272,   276,
+      42,   273,    41,    43,   267,   307,   308,   313,    43,    46,
+     304,    48,   285,   286,   325,   299,   217,   218,   315,    40,
+      43,   204,   248,    76,    43,    47,   246,   249,   249,    43,
+      43,    43,   304,    43,   247,   104,    40,   128,   131,   253,
+     236,   187,   304,    43,   125,   279,   280,   304,   276,    43,
+      46,    43,    42,    48,    40,    46,   188,    48,   313,   217,
+      40,   236,   304,   280,   204,    41,    43,    43,   236,    40,
+      40,    40,   131,    41,   111,   192,   188,   308,    48,   187,
+      48,   286,    47,   236,    41,   188,    43,    41,   236,   236,
+     236,    40,   305,   258,   193,   187,    48,    48,   219,    41,
+     230,   304,   187,   231,   304,    41,    41,    41,   236,   192,
+      48,   217,   231,    43,    46,    54,    43,    46,    54,   231,
+     231,   231,    41,   193,    48,   267,   265,   231,    43,    43
+};
+
+#define yyerrok        (yyerrstatus = 0)
+#define yyclearin  (yychar = YYEMPTY)
+#define YYEMPTY        (-2)
+#define YYEOF      0
+
+#define YYACCEPT   goto yyacceptlab
+#define YYABORT        goto yyabortlab
+#define YYERROR        goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL     goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)                 \
+do                             \
+  if (yychar == YYEMPTY && yylen == 1)             \
+    {                              \
+      yychar = (Token);                        \
+      yylval = (Value);                        \
+      yytoken = YYTRANSLATE (yychar);              \
+      YYPOPSTACK (1);                      \
+      goto yybackup;                       \
+    }                              \
+  else                             \
+    {                              \
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;                         \
+    }                              \
+while (YYID (0))
+
+
+#define YYTERROR   1
+#define YYERRCODE  256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)               \
+    do                                 \
+      if (YYID (N))                                                    \
+   {                               \
+     (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;    \
+     (Current).first_column = YYRHSLOC (Rhs, 1).first_column;  \
+     (Current).last_line    = YYRHSLOC (Rhs, N).last_line;     \
+     (Current).last_column  = YYRHSLOC (Rhs, N).last_column;   \
+   }                               \
+      else                             \
+   {                               \
+     (Current).first_line   = (Current).last_line   =      \
+       YYRHSLOC (Rhs, 0).last_line;                \
+     (Current).first_column = (Current).last_column =      \
+       YYRHSLOC (Rhs, 0).last_column;              \
+   }                               \
+    while (YYID (0))
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)         \
+     fprintf (File, "%d.%d-%d.%d",         \
+         (Loc).first_line, (Loc).first_column, \
+         (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)           \
+do {                       \
+  if (yydebug)                 \
+    YYFPRINTF Args;                \
+} while (YYID (0))
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)           \
+do {                                     \
+  if (yydebug)                               \
+    {                                    \
+      YYFPRINTF (stderr, "%s ", Title);                      \
+      yy_symbol_print (stderr,                       \
+         Type, Value); \
+      YYFPRINTF (stderr, "\n");                          \
+    }                                    \
+} while (YYID (0))
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (!yyvaluep)
+    return;
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+   break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE const * const yyvaluep;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
+  YYFPRINTF (yyoutput, ")");
+}
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
+#else
+static void
+yy_stack_print (bottom, top)
+    yytype_int16 *bottom;
+    yytype_int16 *top;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (; bottom <= top; ++bottom)
+    YYFPRINTF (stderr, " %d", *bottom);
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)               \
+do {                               \
+  if (yydebug)                         \
+    yy_stack_print ((Bottom), (Top));              \
+} while (YYID (0))
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
+#else
+static void
+yy_reduce_print (yyvsp, yyrule)
+    YYSTYPE *yyvsp;
+    int yyrule;
+#endif
+{
+  int yynrhs = yyr2[yyrule];
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+        yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      fprintf (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+              &(yyvsp[(yyi + 1) - (yynrhs)])
+                          );
+      fprintf (stderr, "\n");
+    }
+}
+
+# define YY_REDUCE_PRINT(Rule)     \
+do {                   \
+  if (yydebug)             \
+    yy_reduce_print (yyvsp, Rule); \
+} while (YYID (0))
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef    YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined __GLIBC__ && defined _STRING_H
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static YYSIZE_T
+yystrlen (const char *yystr)
+#else
+static YYSIZE_T
+yystrlen (yystr)
+    const char *yystr;
+#endif
+{
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
+    continue;
+  return yylen;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static char *
+yystpcpy (char *yydest, const char *yysrc)
+#else
+static char *
+yystpcpy (yydest, yysrc)
+    char *yydest;
+    const char *yysrc;
+#endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      YYSIZE_T yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+   switch (*++yyp)
+     {
+     case '\'':
+     case ',':
+       goto do_not_strip_quotes;
+
+     case '\\':
+       if (*++yyp != '\\')
+         goto do_not_strip_quotes;
+       /* Fall through.  */
+     default:
+       if (yyres)
+         yyres[yyn] = *yyp;
+       yyn++;
+       break;
+
+     case '"':
+       if (yyres)
+         yyres[yyn] = '\0';
+       return yyn;
+     }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
+
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
+
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+    constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+           + sizeof yyexpecting - 1
+           + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+              * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
+
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+    YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
+
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn + 1;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
+
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
+
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+   if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+     {
+       if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+         {
+       yycount = 1;
+       yysize = yysize0;
+       yyformat[sizeof yyunexpected - 1] = '\0';
+       break;
+         }
+       yyarg[yycount++] = yytname[yyx];
+       yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+       yysize_overflow |= (yysize1 < yysize);
+       yysize = yysize1;
+       yyfmt = yystpcpy (yyfmt, yyprefix);
+       yyprefix = yyor;
+     }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+   return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+   {
+     /* Avoid sprintf, as that infringes on the user's name space.
+        Don't have undefined behavior even if the translation
+        produced a string with the wrong number of "%s"s.  */
+     char *yyp = yyresult;
+     int yyi = 0;
+     while ((*yyp = *yyf) != '\0')
+       {
+         if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+       {
+         yyp += yytnamerr (yyp, yyarg[yyi++]);
+         yyf += 2;
+       }
+         else
+       {
+         yyp++;
+         yyf++;
+       }
+       }
+   }
+      return yysize;
+    }
+}
+#endif /* YYERROR_VERBOSE */
+
+
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  YYUSE (yyvaluep);
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+
+      default:
+   break;
+    }
+}
+
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+
+#ifdef YYPARSE_PARAM
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void *YYPARSE_PARAM);
+#else
+int yyparse ();
+#endif
+#else /* ! YYPARSE_PARAM */
+#if defined __STDC__ || defined __cplusplus
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+
+/* The look-ahead symbol.  */
+int yychar;
+
+/* The semantic value of the look-ahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+#ifdef YYPARSE_PARAM
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
+#else /* ! YYPARSE_PARAM */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+
+#endif
+#endif
+{
+
+  int yystate;
+  int yyn;
+  int yyresult;
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Look-ahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
+
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack.  */
+  yytype_int16 yyssa[YYINITDEPTH];
+  yytype_int16 *yyss = yyssa;
+  yytype_int16 *yyssp;
+
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
+  YYSTYPE *yyvsp;
+
+
+
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
+
+  YYSIZE_T yystacksize = YYINITDEPTH;
+
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;        /* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed.  So pushing a state here evens the stacks.  */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+   /* Give user a chance to reallocate the stack.  Use copies of
+      these so that the &'s don't force the real ones into
+      memory.  */
+   YYSTYPE *yyvs1 = yyvs;
+   yytype_int16 *yyss1 = yyss;
+
+
+   /* Each stack pointer address is followed by the size of the
+      data in use in that stack, in bytes.  This used to be a
+      conditional around just the two extra args, but that might
+      be undefined if yyoverflow is a macro.  */
+   yyoverflow (YY_("memory exhausted"),
+           &yyss1, yysize * sizeof (*yyssp),
+           &yyvs1, yysize * sizeof (*yyvsp),
+
+           &yystacksize);
+
+   yyss = yyss1;
+   yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+   goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+   yystacksize = YYMAXDEPTH;
+
+      {
+   yytype_int16 *yyss1 = yyss;
+   union yyalloc *yyptr =
+     (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+   if (! yyptr)
+     goto yyexhaustedlab;
+   YYSTACK_RELOCATE (yyss);
+   YYSTACK_RELOCATE (yyvs);
+
+#  undef YYSTACK_RELOCATE
+   if (yyss1 != yyssa)
+     YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+         (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+   YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+  /* Do appropriate processing given the current state.  Read a
+     look-ahead token if we need one and don't already have one.  */
+
+  /* First try to decide what to do without reference to look-ahead token.  */
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a look-ahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+   goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  /* Shift the look-ahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the shifted token unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  yystate = yyn;
+  *++yyvsp = yylval;
+
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 2:
+#line 1713 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   if (!classes) classes = NewHash();
+          Setattr((yyvsp[(1) - (1)].node),"classes",classes);
+          Setattr((yyvsp[(1) - (1)].node),"name",ModuleName);
+
+          if ((!module_node) && ModuleName) {
+            module_node = new_node("module");
+            Setattr(module_node,"name",ModuleName);
+          }
+          Setattr((yyvsp[(1) - (1)].node),"module",module_node);
+              top = (yyvsp[(1) - (1)].node);
+               ;}
+    break;
+
+  case 3:
+#line 1725 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 top = Copy(Getattr((yyvsp[(2) - (3)].p),"type"));
+        Delete((yyvsp[(2) - (3)].p));
+               ;}
+    break;
+
+  case 4:
+#line 1729 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 top = 0;
+               ;}
+    break;
+
+  case 5:
+#line 1732 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 top = (yyvsp[(2) - (3)].p);
+               ;}
+    break;
+
+  case 6:
+#line 1735 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 top = 0;
+               ;}
+    break;
+
+  case 7:
+#line 1738 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 top = (yyvsp[(3) - (5)].pl);
+               ;}
+    break;
+
+  case 8:
+#line 1741 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 top = 0;
+               ;}
+    break;
+
+  case 9:
+#line 1746 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   /* add declaration to end of linked list (the declaration isn't always a single declaration, sometimes it is a linked list itself) */
+                   if (currentDeclComment != NULL) {
+            set_comment((yyvsp[(2) - (2)].node), currentDeclComment);
+            currentDeclComment = NULL;
+                   }
+                   appendChild((yyvsp[(1) - (2)].node),(yyvsp[(2) - (2)].node));
+                   (yyval.node) = (yyvsp[(1) - (2)].node);
+               ;}
+    break;
+
+  case 10:
+#line 1755 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   currentDeclComment = (yyvsp[(2) - (2)].str);
+                   (yyval.node) = (yyvsp[(1) - (2)].node);
+               ;}
+    break;
+
+  case 11:
+#line 1759 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   Node *node = lastChild((yyvsp[(1) - (2)].node));
+                   if (node) {
+                     set_comment(node, (yyvsp[(2) - (2)].str));
+                   }
+                   (yyval.node) = (yyvsp[(1) - (2)].node);
+               ;}
+    break;
+
+  case 12:
+#line 1766 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.node) = new_node("top");
+               ;}
+    break;
+
+  case 13:
+#line 1771 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 14:
+#line 1772 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 15:
+#line 1773 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 16:
+#line 1774 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = 0; ;}
+    break;
+
+  case 17:
+#line 1775 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                  (yyval.node) = 0;
+         if (cparse_unknown_directive) {
+             Swig_error(cparse_file, cparse_line, "Unknown directive '%s'.\n", cparse_unknown_directive);
+         } else {
+             Swig_error(cparse_file, cparse_line, "Syntax error in input(1).\n");
+         }
+         exit(1);
+               ;}
+    break;
+
+  case 18:
+#line 1785 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                  if ((yyval.node)) {
+                 add_symbols((yyval.node));
+                  }
+                  (yyval.node) = (yyvsp[(1) - (1)].node);
+          ;}
+    break;
+
+  case 19:
+#line 1801 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                  (yyval.node) = 0;
+                  skip_decl();
+               ;}
+    break;
+
+  case 20:
+#line 1811 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 21:
+#line 1812 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 22:
+#line 1813 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 23:
+#line 1814 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 24:
+#line 1815 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 25:
+#line 1816 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 26:
+#line 1817 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 27:
+#line 1818 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 28:
+#line 1819 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 29:
+#line 1820 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 30:
+#line 1821 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 31:
+#line 1822 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 32:
+#line 1823 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 33:
+#line 1824 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 34:
+#line 1825 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 35:
+#line 1826 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 36:
+#line 1827 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 37:
+#line 1828 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 38:
+#line 1829 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 39:
+#line 1830 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 40:
+#line 1831 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 41:
+#line 1838 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+               Node *cls;
+          String *clsname;
+          extendmode = 1;
+          cplus_mode = CPLUS_PUBLIC;
+          if (!classes) classes = NewHash();
+          if (!classes_typedefs) classes_typedefs = NewHash();
+          clsname = make_class_name((yyvsp[(4) - (5)].str));
+          cls = Getattr(classes,clsname);
+          if (!cls) {
+            cls = Getattr(classes_typedefs, clsname);
+        if (!cls) {
+          /* No previous definition. Create a new scope */
+          Node *am = Getattr(Swig_extend_hash(),clsname);
+          if (!am) {
+            Swig_symbol_newscope();
+            Swig_symbol_setscopename((yyvsp[(4) - (5)].str));
+            prev_symtab = 0;
+          } else {
+            prev_symtab = Swig_symbol_setscope(Getattr(am,"symtab"));
+          }
+          current_class = 0;
+        } else {
+          /* Previous typedef class definition.  Use its symbol table.
+             Deprecated, just the real name should be used.
+             Note that %extend before the class typedef never worked, only %extend after the class typdef. */
+          prev_symtab = Swig_symbol_setscope(Getattr(cls, "symtab"));
+          current_class = cls;
+          SWIG_WARN_NODE_BEGIN(cls);
+          Swig_warning(WARN_PARSE_EXTEND_NAME, cparse_file, cparse_line, "Deprecated %%extend name used - the %s name '%s' should be used instead of the typedef name '%s'.\n", Getattr(cls, "kind"), SwigType_namestr(Getattr(cls, "name")), (yyvsp[(4) - (5)].str));
+          SWIG_WARN_NODE_END(cls);
+        }
+          } else {
+        /* Previous class definition.  Use its symbol table */
+        prev_symtab = Swig_symbol_setscope(Getattr(cls,"symtab"));
+        current_class = cls;
+          }
+          Classprefix = NewString((yyvsp[(4) - (5)].str));
+          Namespaceprefix= Swig_symbol_qualifiedscopename(0);
+          Delete(clsname);
+        ;}
+    break;
+
+  case 42:
+#line 1878 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+               String *clsname;
+          extendmode = 0;
+               (yyval.node) = new_node("extend");
+          Setattr((yyval.node),"symtab",Swig_symbol_popscope());
+          if (prev_symtab) {
+        Swig_symbol_setscope(prev_symtab);
+          }
+          Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+               clsname = make_class_name((yyvsp[(4) - (8)].str));
+          Setattr((yyval.node),"name",clsname);
+
+          mark_nodes_as_extend((yyvsp[(7) - (8)].node));
+          if (current_class) {
+        /* We add the extension to the previously defined class */
+        appendChild((yyval.node), (yyvsp[(7) - (8)].node));
+        appendChild(current_class,(yyval.node));
+          } else {
+        /* We store the extensions in the extensions hash */
+        Node *am = Getattr(Swig_extend_hash(),clsname);
+        if (am) {
+          /* Append the members to the previous extend methods */
+          appendChild(am, (yyvsp[(7) - (8)].node));
+        } else {
+          appendChild((yyval.node), (yyvsp[(7) - (8)].node));
+          Setattr(Swig_extend_hash(),clsname,(yyval.node));
+        }
+          }
+          current_class = 0;
+          Delete(Classprefix);
+          Delete(clsname);
+          Classprefix = 0;
+          prev_symtab = 0;
+          (yyval.node) = 0;
+
+        ;}
+    break;
+
+  case 43:
+#line 1920 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.node) = new_node("apply");
+                    Setattr((yyval.node),"pattern",Getattr((yyvsp[(2) - (5)].p),"pattern"));
+           appendChild((yyval.node),(yyvsp[(4) - (5)].p));
+               ;}
+    break;
+
+  case 44:
+#line 1930 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.node) = new_node("clear");
+        appendChild((yyval.node),(yyvsp[(2) - (3)].p));
+               ;}
+    break;
+
+  case 45:
+#line 1941 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          if (((yyvsp[(4) - (5)].dtype).type != T_ERROR) && ((yyvsp[(4) - (5)].dtype).type != T_SYMBOL)) {
+            SwigType *type = NewSwigType((yyvsp[(4) - (5)].dtype).type);
+            (yyval.node) = new_node("constant");
+            Setattr((yyval.node),"name",(yyvsp[(2) - (5)].id));
+            Setattr((yyval.node),"type",type);
+            Setattr((yyval.node),"value",(yyvsp[(4) - (5)].dtype).val);
+            if ((yyvsp[(4) - (5)].dtype).rawval) Setattr((yyval.node),"rawval", (yyvsp[(4) - (5)].dtype).rawval);
+            Setattr((yyval.node),"storage","%constant");
+            SetFlag((yyval.node),"feature:immutable");
+            add_symbols((yyval.node));
+            Delete(type);
+          } else {
+            if ((yyvsp[(4) - (5)].dtype).type == T_ERROR) {
+              Swig_warning(WARN_PARSE_UNSUPPORTED_VALUE,cparse_file,cparse_line,"Unsupported constant value (ignored)\n");
+            }
+            (yyval.node) = 0;
+          }
+
+          ;}
+    break;
+
+  case 46:
+#line 1961 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        if (((yyvsp[(4) - (5)].dtype).type != T_ERROR) && ((yyvsp[(4) - (5)].dtype).type != T_SYMBOL)) {
+          SwigType_push((yyvsp[(2) - (5)].type),(yyvsp[(3) - (5)].decl).type);
+          /* Sneaky callback function trick */
+          if (SwigType_isfunction((yyvsp[(2) - (5)].type))) {
+            SwigType_add_pointer((yyvsp[(2) - (5)].type));
+          }
+          (yyval.node) = new_node("constant");
+          Setattr((yyval.node),"name",(yyvsp[(3) - (5)].decl).id);
+          Setattr((yyval.node),"type",(yyvsp[(2) - (5)].type));
+          Setattr((yyval.node),"value",(yyvsp[(4) - (5)].dtype).val);
+          if ((yyvsp[(4) - (5)].dtype).rawval) Setattr((yyval.node),"rawval", (yyvsp[(4) - (5)].dtype).rawval);
+          Setattr((yyval.node),"storage","%constant");
+          SetFlag((yyval.node),"feature:immutable");
+          add_symbols((yyval.node));
+        } else {
+          if ((yyvsp[(4) - (5)].dtype).type == T_ERROR) {
+            Swig_warning(WARN_PARSE_UNSUPPORTED_VALUE,cparse_file,cparse_line, "Unsupported constant value\n");
+          }
+          (yyval.node) = 0;
+        }
+               ;}
+    break;
+
+  case 47:
+#line 1985 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        if (((yyvsp[(8) - (9)].dtype).type != T_ERROR) && ((yyvsp[(8) - (9)].dtype).type != T_SYMBOL)) {
+          SwigType_add_function((yyvsp[(2) - (9)].type), (yyvsp[(5) - (9)].pl));
+          SwigType_push((yyvsp[(2) - (9)].type), (yyvsp[(7) - (9)].dtype).qualifier);
+          SwigType_push((yyvsp[(2) - (9)].type), (yyvsp[(3) - (9)].decl).type);
+          /* Sneaky callback function trick */
+          if (SwigType_isfunction((yyvsp[(2) - (9)].type))) {
+            SwigType_add_pointer((yyvsp[(2) - (9)].type));
+          }
+          (yyval.node) = new_node("constant");
+          Setattr((yyval.node), "name", (yyvsp[(3) - (9)].decl).id);
+          Setattr((yyval.node), "type", (yyvsp[(2) - (9)].type));
+          Setattr((yyval.node), "value", (yyvsp[(8) - (9)].dtype).val);
+          if ((yyvsp[(8) - (9)].dtype).rawval) Setattr((yyval.node), "rawval", (yyvsp[(8) - (9)].dtype).rawval);
+          Setattr((yyval.node), "storage", "%constant");
+          SetFlag((yyval.node), "feature:immutable");
+          add_symbols((yyval.node));
+        } else {
+          if ((yyvsp[(8) - (9)].dtype).type == T_ERROR) {
+            Swig_warning(WARN_PARSE_UNSUPPORTED_VALUE,cparse_file,cparse_line, "Unsupported constant value\n");
+          }
+          (yyval.node) = 0;
+        }
+          ;}
+    break;
+
+  case 48:
+#line 2009 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        Swig_warning(WARN_PARSE_BAD_VALUE,cparse_file,cparse_line,"Bad constant value (ignored).\n");
+        (yyval.node) = 0;
+          ;}
+    break;
+
+  case 49:
+#line 2020 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        char temp[64];
+        Replace((yyvsp[(2) - (2)].str),"$file",cparse_file, DOH_REPLACE_ANY);
+        sprintf(temp,"%d", cparse_line);
+        Replace((yyvsp[(2) - (2)].str),"$line",temp,DOH_REPLACE_ANY);
+        Printf(stderr,"%s\n", (yyvsp[(2) - (2)].str));
+        Delete((yyvsp[(2) - (2)].str));
+                 (yyval.node) = 0;
+          ;}
+    break;
+
+  case 50:
+#line 2029 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        char temp[64];
+        String *s = (yyvsp[(2) - (2)].str);
+        Replace(s,"$file",cparse_file, DOH_REPLACE_ANY);
+        sprintf(temp,"%d", cparse_line);
+        Replace(s,"$line",temp,DOH_REPLACE_ANY);
+        Printf(stderr,"%s\n", s);
+        Delete(s);
+                 (yyval.node) = 0;
+               ;}
+    break;
+
+  case 51:
+#line 2048 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    skip_balanced('{','}');
+           (yyval.node) = 0;
+           Swig_warning(WARN_DEPRECATED_EXCEPT,cparse_file, cparse_line, "%%except is deprecated.  Use %%exception instead.\n");
+          ;}
+    break;
+
+  case 52:
+#line 2054 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    skip_balanced('{','}');
+           (yyval.node) = 0;
+           Swig_warning(WARN_DEPRECATED_EXCEPT,cparse_file, cparse_line, "%%except is deprecated.  Use %%exception instead.\n");
+               ;}
+    break;
+
+  case 53:
+#line 2060 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.node) = 0;
+        Swig_warning(WARN_DEPRECATED_EXCEPT,cparse_file, cparse_line, "%%except is deprecated.  Use %%exception instead.\n");
+               ;}
+    break;
+
+  case 54:
+#line 2065 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.node) = 0;
+        Swig_warning(WARN_DEPRECATED_EXCEPT,cparse_file, cparse_line, "%%except is deprecated.  Use %%exception instead.\n");
+          ;}
+    break;
+
+  case 55:
+#line 2072 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.node) = NewHash();
+                 Setattr((yyval.node),"value",(yyvsp[(1) - (4)].str));
+        Setattr((yyval.node),"type",Getattr((yyvsp[(3) - (4)].p),"type"));
+               ;}
+    break;
+
+  case 56:
+#line 2079 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.node) = NewHash();
+                 Setattr((yyval.node),"value",(yyvsp[(1) - (1)].str));
+              ;}
+    break;
+
+  case 57:
+#line 2083 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                (yyval.node) = (yyvsp[(1) - (1)].node);
+              ;}
+    break;
+
+  case 58:
+#line 2096 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   Hash *p = (yyvsp[(5) - (7)].node);
+          (yyval.node) = new_node("fragment");
+          Setattr((yyval.node),"value",Getattr((yyvsp[(3) - (7)].node),"value"));
+          Setattr((yyval.node),"type",Getattr((yyvsp[(3) - (7)].node),"type"));
+          Setattr((yyval.node),"section",Getattr(p,"name"));
+          Setattr((yyval.node),"kwargs",nextSibling(p));
+          Setattr((yyval.node),"code",(yyvsp[(7) - (7)].str));
+                 ;}
+    break;
+
+  case 59:
+#line 2105 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          Hash *p = (yyvsp[(5) - (7)].node);
+          String *code;
+                   skip_balanced('{','}');
+          (yyval.node) = new_node("fragment");
+          Setattr((yyval.node),"value",Getattr((yyvsp[(3) - (7)].node),"value"));
+          Setattr((yyval.node),"type",Getattr((yyvsp[(3) - (7)].node),"type"));
+          Setattr((yyval.node),"section",Getattr(p,"name"));
+          Setattr((yyval.node),"kwargs",nextSibling(p));
+          Delitem(scanner_ccode,0);
+          Delitem(scanner_ccode,DOH_END);
+          code = Copy(scanner_ccode);
+          Setattr((yyval.node),"code",code);
+          Delete(code);
+                 ;}
+    break;
+
+  case 60:
+#line 2120 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          (yyval.node) = new_node("fragment");
+          Setattr((yyval.node),"value",Getattr((yyvsp[(3) - (5)].node),"value"));
+          Setattr((yyval.node),"type",Getattr((yyvsp[(3) - (5)].node),"type"));
+          Setattr((yyval.node),"emitonly","1");
+        ;}
+    break;
+
+  case 61:
+#line 2133 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                     (yyvsp[(1) - (4)].loc).filename = Copy(cparse_file);
+            (yyvsp[(1) - (4)].loc).line = cparse_line;
+            scanner_set_location((yyvsp[(3) - (4)].str),1);
+                     if ((yyvsp[(2) - (4)].node)) {
+              String *maininput = Getattr((yyvsp[(2) - (4)].node), "maininput");
+              if (maininput)
+                scanner_set_main_input_file(NewString(maininput));
+            }
+               ;}
+    break;
+
+  case 62:
+#line 2142 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                     String *mname = 0;
+                     (yyval.node) = (yyvsp[(6) - (7)].node);
+            scanner_set_location((yyvsp[(1) - (7)].loc).filename,(yyvsp[(1) - (7)].loc).line+1);
+            if (strcmp((yyvsp[(1) - (7)].loc).type,"include") == 0) set_nodeType((yyval.node),"include");
+            if (strcmp((yyvsp[(1) - (7)].loc).type,"import") == 0) {
+              mname = (yyvsp[(2) - (7)].node) ? Getattr((yyvsp[(2) - (7)].node),"module") : 0;
+              set_nodeType((yyval.node),"import");
+              if (import_mode) --import_mode;
+            }
+
+            Setattr((yyval.node),"name",(yyvsp[(3) - (7)].str));
+            /* Search for the module (if any) */
+            {
+            Node *n = firstChild((yyval.node));
+            while (n) {
+                if (Strcmp(nodeType(n),"module") == 0) {
+                    if (mname) {
+                  Setattr(n,"name", mname);
+                  mname = 0;
+                }
+                Setattr((yyval.node),"module",Getattr(n,"name"));
+                break;
+                }
+                n = nextSibling(n);
+            }
+            if (mname) {
+              /* There is no module node in the import
+                 node, ie, you imported a .h file
+                 directly.  We are forced then to create
+                 a new import node with a module node.
+              */
+              Node *nint = new_node("import");
+              Node *mnode = new_node("module");
+              Setattr(mnode,"name", mname);
+                           Setattr(mnode,"options",(yyvsp[(2) - (7)].node));
+              appendChild(nint,mnode);
+              Delete(mnode);
+              appendChild(nint,firstChild((yyval.node)));
+              (yyval.node) = nint;
+              Setattr((yyval.node),"module",mname);
+            }
+            }
+            Setattr((yyval.node),"options",(yyvsp[(2) - (7)].node));
+               ;}
+    break;
+
+  case 63:
+#line 2189 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.loc).type = "include"; ;}
+    break;
+
+  case 64:
+#line 2190 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.loc).type = "import"; ++import_mode;;}
+    break;
+
+  case 65:
+#line 2197 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 String *cpps;
+        if (Namespaceprefix) {
+          Swig_error(cparse_file, cparse_start_line, "%%inline directive inside a namespace is disallowed.\n");
+          (yyval.node) = 0;
+        } else {
+          (yyval.node) = new_node("insert");
+          Setattr((yyval.node),"code",(yyvsp[(2) - (2)].str));
+          /* Need to run through the preprocessor */
+          Seek((yyvsp[(2) - (2)].str),0,SEEK_SET);
+          Setline((yyvsp[(2) - (2)].str),cparse_start_line);
+          Setfile((yyvsp[(2) - (2)].str),cparse_file);
+          cpps = Preprocessor_parse((yyvsp[(2) - (2)].str));
+          start_inline(Char(cpps), cparse_start_line);
+          Delete((yyvsp[(2) - (2)].str));
+          Delete(cpps);
+        }
+
+          ;}
+    break;
+
+  case 66:
+#line 2216 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 String *cpps;
+        int start_line = cparse_line;
+        skip_balanced('{','}');
+        if (Namespaceprefix) {
+          Swig_error(cparse_file, cparse_start_line, "%%inline directive inside a namespace is disallowed.\n");
+
+          (yyval.node) = 0;
+        } else {
+          String *code;
+                   (yyval.node) = new_node("insert");
+          Delitem(scanner_ccode,0);
+          Delitem(scanner_ccode,DOH_END);
+          code = Copy(scanner_ccode);
+          Setattr((yyval.node),"code", code);
+          Delete(code);
+          cpps=Copy(scanner_ccode);
+          start_inline(Char(cpps), start_line);
+          Delete(cpps);
+        }
+               ;}
+    break;
+
+  case 67:
+#line 2247 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.node) = new_node("insert");
+        Setattr((yyval.node),"code",(yyvsp[(1) - (1)].str));
+          ;}
+    break;
+
+  case 68:
+#line 2251 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        String *code = NewStringEmpty();
+        (yyval.node) = new_node("insert");
+        Setattr((yyval.node),"section",(yyvsp[(3) - (5)].id));
+        Setattr((yyval.node),"code",code);
+        if (Swig_insert_file((yyvsp[(5) - (5)].str),code) < 0) {
+          Swig_error(cparse_file, cparse_line, "Couldn't find '%s'.\n", (yyvsp[(5) - (5)].str));
+          (yyval.node) = 0;
+        }
+               ;}
+    break;
+
+  case 69:
+#line 2261 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.node) = new_node("insert");
+        Setattr((yyval.node),"section",(yyvsp[(3) - (5)].id));
+        Setattr((yyval.node),"code",(yyvsp[(5) - (5)].str));
+               ;}
+    break;
+
+  case 70:
+#line 2266 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        String *code;
+                 skip_balanced('{','}');
+        (yyval.node) = new_node("insert");
+        Setattr((yyval.node),"section",(yyvsp[(3) - (5)].id));
+        Delitem(scanner_ccode,0);
+        Delitem(scanner_ccode,DOH_END);
+        code = Copy(scanner_ccode);
+        Setattr((yyval.node),"code", code);
+        Delete(code);
+          ;}
+    break;
+
+  case 71:
+#line 2284 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.node) = new_node("module");
+        if ((yyvsp[(2) - (3)].node)) {
+          Setattr((yyval.node),"options",(yyvsp[(2) - (3)].node));
+          if (Getattr((yyvsp[(2) - (3)].node),"directors")) {
+            Wrapper_director_mode_set(1);
+            if (!cparse_cplusplus) {
+              Swig_error(cparse_file, cparse_line, "Directors are not supported for C code and require the -c++ option\n");
+            }
+          }
+          if (Getattr((yyvsp[(2) - (3)].node),"dirprot")) {
+            Wrapper_director_protected_mode_set(1);
+          }
+          if (Getattr((yyvsp[(2) - (3)].node),"allprotected")) {
+            Wrapper_all_protected_mode_set(1);
+          }
+          if (Getattr((yyvsp[(2) - (3)].node),"templatereduce")) {
+            template_reduce = 1;
+          }
+          if (Getattr((yyvsp[(2) - (3)].node),"notemplatereduce")) {
+            template_reduce = 0;
+          }
+        }
+        if (!ModuleName) ModuleName = NewString((yyvsp[(3) - (3)].id));
+        if (!import_mode) {
+          /* first module included, we apply global
+             ModuleName, which can be modify by -module */
+          String *mname = Copy(ModuleName);
+          Setattr((yyval.node),"name",mname);
+          Delete(mname);
+        } else {
+          /* import mode, we just pass the idstring */
+          Setattr((yyval.node),"name",(yyvsp[(3) - (3)].id));
+        }
+        if (!module_node) module_node = (yyval.node);
+          ;}
+    break;
+
+  case 72:
+#line 2327 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 Swig_warning(WARN_DEPRECATED_NAME,cparse_file,cparse_line, "%%name is deprecated.  Use %%rename instead.\n");
+        Delete(yyrename);
+                 yyrename = NewString((yyvsp[(3) - (4)].id));
+        (yyval.node) = 0;
+               ;}
+    break;
+
+  case 73:
+#line 2333 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        Swig_warning(WARN_DEPRECATED_NAME,cparse_file,cparse_line, "%%name is deprecated.  Use %%rename instead.\n");
+        (yyval.node) = 0;
+        Swig_error(cparse_file,cparse_line,"Missing argument to %%name directive.\n");
+          ;}
+    break;
+
+  case 74:
+#line 2346 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.node) = new_node("native");
+        Setattr((yyval.node),"name",(yyvsp[(3) - (7)].id));
+        Setattr((yyval.node),"wrap:name",(yyvsp[(6) - (7)].id));
+            add_symbols((yyval.node));
+          ;}
+    break;
+
+  case 75:
+#line 2352 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        if (!SwigType_isfunction((yyvsp[(7) - (8)].decl).type)) {
+          Swig_error(cparse_file,cparse_line,"%%native declaration '%s' is not a function.\n", (yyvsp[(7) - (8)].decl).id);
+          (yyval.node) = 0;
+        } else {
+            Delete(SwigType_pop_function((yyvsp[(7) - (8)].decl).type));
+            /* Need check for function here */
+            SwigType_push((yyvsp[(6) - (8)].type),(yyvsp[(7) - (8)].decl).type);
+            (yyval.node) = new_node("native");
+                Setattr((yyval.node),"name",(yyvsp[(3) - (8)].id));
+            Setattr((yyval.node),"wrap:name",(yyvsp[(7) - (8)].decl).id);
+            Setattr((yyval.node),"type",(yyvsp[(6) - (8)].type));
+            Setattr((yyval.node),"parms",(yyvsp[(7) - (8)].decl).parms);
+            Setattr((yyval.node),"decl",(yyvsp[(7) - (8)].decl).type);
+        }
+            add_symbols((yyval.node));
+          ;}
+    break;
+
+  case 76:
+#line 2378 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.node) = new_node("pragma");
+        Setattr((yyval.node),"lang",(yyvsp[(2) - (5)].id));
+        Setattr((yyval.node),"name",(yyvsp[(3) - (5)].id));
+        Setattr((yyval.node),"value",(yyvsp[(5) - (5)].str));
+          ;}
+    break;
+
+  case 77:
+#line 2384 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+       (yyval.node) = new_node("pragma");
+       Setattr((yyval.node),"lang",(yyvsp[(2) - (3)].id));
+       Setattr((yyval.node),"name",(yyvsp[(3) - (3)].id));
+         ;}
+    break;
+
+  case 78:
+#line 2391 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.str) = (yyvsp[(1) - (1)].str); ;}
+    break;
+
+  case 79:
+#line 2392 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.str) = (yyvsp[(1) - (1)].str); ;}
+    break;
+
+  case 80:
+#line 2395 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = (yyvsp[(2) - (3)].id); ;}
+    break;
+
+  case 81:
+#line 2396 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = (char *) "swig"; ;}
+    break;
+
+  case 82:
+#line 2403 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                SwigType *t = (yyvsp[(2) - (4)].decl).type;
+       Hash *kws = NewHash();
+       String *fixname;
+       fixname = feature_identifier_fix((yyvsp[(2) - (4)].decl).id);
+       Setattr(kws,"name",(yyvsp[(3) - (4)].id));
+       if (!Len(t)) t = 0;
+       /* Special declarator check */
+       if (t) {
+         if (SwigType_isfunction(t)) {
+           SwigType *decl = SwigType_pop_function(t);
+           if (SwigType_ispointer(t)) {
+             String *nname = NewStringf("*%s",fixname);
+             if ((yyvsp[(1) - (4)].intvalue)) {
+           Swig_name_rename_add(Namespaceprefix, nname,decl,kws,(yyvsp[(2) - (4)].decl).parms);
+             } else {
+           Swig_name_namewarn_add(Namespaceprefix,nname,decl,kws);
+             }
+             Delete(nname);
+           } else {
+             if ((yyvsp[(1) - (4)].intvalue)) {
+           Swig_name_rename_add(Namespaceprefix,(fixname),decl,kws,(yyvsp[(2) - (4)].decl).parms);
+             } else {
+           Swig_name_namewarn_add(Namespaceprefix,(fixname),decl,kws);
+             }
+           }
+           Delete(decl);
+         } else if (SwigType_ispointer(t)) {
+           String *nname = NewStringf("*%s",fixname);
+           if ((yyvsp[(1) - (4)].intvalue)) {
+             Swig_name_rename_add(Namespaceprefix,(nname),0,kws,(yyvsp[(2) - (4)].decl).parms);
+           } else {
+             Swig_name_namewarn_add(Namespaceprefix,(nname),0,kws);
+           }
+           Delete(nname);
+         }
+       } else {
+         if ((yyvsp[(1) - (4)].intvalue)) {
+           Swig_name_rename_add(Namespaceprefix,(fixname),0,kws,(yyvsp[(2) - (4)].decl).parms);
+         } else {
+           Swig_name_namewarn_add(Namespaceprefix,(fixname),0,kws);
+         }
+       }
+                (yyval.node) = 0;
+       scanner_clear_rename();
+              ;}
+    break;
+
+  case 83:
+#line 2449 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+       String *fixname;
+       Hash *kws = (yyvsp[(3) - (7)].node);
+       SwigType *t = (yyvsp[(5) - (7)].decl).type;
+       fixname = feature_identifier_fix((yyvsp[(5) - (7)].decl).id);
+       if (!Len(t)) t = 0;
+       /* Special declarator check */
+       if (t) {
+         if ((yyvsp[(6) - (7)].dtype).qualifier) SwigType_push(t,(yyvsp[(6) - (7)].dtype).qualifier);
+         if (SwigType_isfunction(t)) {
+           SwigType *decl = SwigType_pop_function(t);
+           if (SwigType_ispointer(t)) {
+             String *nname = NewStringf("*%s",fixname);
+             if ((yyvsp[(1) - (7)].intvalue)) {
+           Swig_name_rename_add(Namespaceprefix, nname,decl,kws,(yyvsp[(5) - (7)].decl).parms);
+             } else {
+           Swig_name_namewarn_add(Namespaceprefix,nname,decl,kws);
+             }
+             Delete(nname);
+           } else {
+             if ((yyvsp[(1) - (7)].intvalue)) {
+           Swig_name_rename_add(Namespaceprefix,(fixname),decl,kws,(yyvsp[(5) - (7)].decl).parms);
+             } else {
+           Swig_name_namewarn_add(Namespaceprefix,(fixname),decl,kws);
+             }
+           }
+           Delete(decl);
+         } else if (SwigType_ispointer(t)) {
+           String *nname = NewStringf("*%s",fixname);
+           if ((yyvsp[(1) - (7)].intvalue)) {
+             Swig_name_rename_add(Namespaceprefix,(nname),0,kws,(yyvsp[(5) - (7)].decl).parms);
+           } else {
+             Swig_name_namewarn_add(Namespaceprefix,(nname),0,kws);
+           }
+           Delete(nname);
+         }
+       } else {
+         if ((yyvsp[(1) - (7)].intvalue)) {
+           Swig_name_rename_add(Namespaceprefix,(fixname),0,kws,(yyvsp[(5) - (7)].decl).parms);
+         } else {
+           Swig_name_namewarn_add(Namespaceprefix,(fixname),0,kws);
+         }
+       }
+                (yyval.node) = 0;
+       scanner_clear_rename();
+              ;}
+    break;
+
+  case 84:
+#line 2495 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+       if ((yyvsp[(1) - (6)].intvalue)) {
+         Swig_name_rename_add(Namespaceprefix,(yyvsp[(5) - (6)].str),0,(yyvsp[(3) - (6)].node),0);
+       } else {
+         Swig_name_namewarn_add(Namespaceprefix,(yyvsp[(5) - (6)].str),0,(yyvsp[(3) - (6)].node));
+       }
+       (yyval.node) = 0;
+       scanner_clear_rename();
+              ;}
+    break;
+
+  case 85:
+#line 2506 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.intvalue) = 1;
+                ;}
+    break;
+
+  case 86:
+#line 2509 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.intvalue) = 0;
+                ;}
+    break;
+
+  case 87:
+#line 2536 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    String *val = (yyvsp[(7) - (7)].str) ? NewString((yyvsp[(7) - (7)].str)) : NewString("1");
+                    new_feature((yyvsp[(3) - (7)].id), val, 0, (yyvsp[(5) - (7)].decl).id, (yyvsp[(5) - (7)].decl).type, (yyvsp[(5) - (7)].decl).parms, (yyvsp[(6) - (7)].dtype).qualifier);
+                    (yyval.node) = 0;
+                    scanner_clear_rename();
+                  ;}
+    break;
+
+  case 88:
+#line 2542 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    String *val = Len((yyvsp[(5) - (9)].str)) ? (yyvsp[(5) - (9)].str) : 0;
+                    new_feature((yyvsp[(3) - (9)].id), val, 0, (yyvsp[(7) - (9)].decl).id, (yyvsp[(7) - (9)].decl).type, (yyvsp[(7) - (9)].decl).parms, (yyvsp[(8) - (9)].dtype).qualifier);
+                    (yyval.node) = 0;
+                    scanner_clear_rename();
+                  ;}
+    break;
+
+  case 89:
+#line 2548 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    String *val = (yyvsp[(8) - (8)].str) ? NewString((yyvsp[(8) - (8)].str)) : NewString("1");
+                    new_feature((yyvsp[(3) - (8)].id), val, (yyvsp[(4) - (8)].node), (yyvsp[(6) - (8)].decl).id, (yyvsp[(6) - (8)].decl).type, (yyvsp[(6) - (8)].decl).parms, (yyvsp[(7) - (8)].dtype).qualifier);
+                    (yyval.node) = 0;
+                    scanner_clear_rename();
+                  ;}
+    break;
+
+  case 90:
+#line 2554 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    String *val = Len((yyvsp[(5) - (10)].str)) ? (yyvsp[(5) - (10)].str) : 0;
+                    new_feature((yyvsp[(3) - (10)].id), val, (yyvsp[(6) - (10)].node), (yyvsp[(8) - (10)].decl).id, (yyvsp[(8) - (10)].decl).type, (yyvsp[(8) - (10)].decl).parms, (yyvsp[(9) - (10)].dtype).qualifier);
+                    (yyval.node) = 0;
+                    scanner_clear_rename();
+                  ;}
+    break;
+
+  case 91:
+#line 2562 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    String *val = (yyvsp[(5) - (5)].str) ? NewString((yyvsp[(5) - (5)].str)) : NewString("1");
+                    new_feature((yyvsp[(3) - (5)].id), val, 0, 0, 0, 0, 0);
+                    (yyval.node) = 0;
+                    scanner_clear_rename();
+                  ;}
+    break;
+
+  case 92:
+#line 2568 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    String *val = Len((yyvsp[(5) - (7)].str)) ? (yyvsp[(5) - (7)].str) : 0;
+                    new_feature((yyvsp[(3) - (7)].id), val, 0, 0, 0, 0, 0);
+                    (yyval.node) = 0;
+                    scanner_clear_rename();
+                  ;}
+    break;
+
+  case 93:
+#line 2574 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    String *val = (yyvsp[(6) - (6)].str) ? NewString((yyvsp[(6) - (6)].str)) : NewString("1");
+                    new_feature((yyvsp[(3) - (6)].id), val, (yyvsp[(4) - (6)].node), 0, 0, 0, 0);
+                    (yyval.node) = 0;
+                    scanner_clear_rename();
+                  ;}
+    break;
+
+  case 94:
+#line 2580 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    String *val = Len((yyvsp[(5) - (8)].str)) ? (yyvsp[(5) - (8)].str) : 0;
+                    new_feature((yyvsp[(3) - (8)].id), val, (yyvsp[(6) - (8)].node), 0, 0, 0, 0);
+                    (yyval.node) = 0;
+                    scanner_clear_rename();
+                  ;}
+    break;
+
+  case 95:
+#line 2588 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.str) = (yyvsp[(1) - (1)].str); ;}
+    break;
+
+  case 96:
+#line 2589 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.str) = 0; ;}
+    break;
+
+  case 97:
+#line 2590 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.str) = (yyvsp[(3) - (5)].pl); ;}
+    break;
+
+  case 98:
+#line 2593 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.node) = NewHash();
+         Setattr((yyval.node),"name",(yyvsp[(2) - (4)].id));
+         Setattr((yyval.node),"value",(yyvsp[(4) - (4)].str));
+                ;}
+    break;
+
+  case 99:
+#line 2598 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.node) = NewHash();
+         Setattr((yyval.node),"name",(yyvsp[(2) - (5)].id));
+         Setattr((yyval.node),"value",(yyvsp[(4) - (5)].str));
+                  set_nextSibling((yyval.node),(yyvsp[(5) - (5)].node));
+                ;}
+    break;
+
+  case 100:
+#line 2608 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 Parm *val;
+        String *name;
+        SwigType *t;
+        if (Namespaceprefix) name = NewStringf("%s::%s", Namespaceprefix, (yyvsp[(5) - (7)].decl).id);
+        else name = NewString((yyvsp[(5) - (7)].decl).id);
+        val = (yyvsp[(3) - (7)].pl);
+        if ((yyvsp[(5) - (7)].decl).parms) {
+          Setmeta(val,"parms",(yyvsp[(5) - (7)].decl).parms);
+        }
+        t = (yyvsp[(5) - (7)].decl).type;
+        if (!Len(t)) t = 0;
+        if (t) {
+          if ((yyvsp[(6) - (7)].dtype).qualifier) SwigType_push(t,(yyvsp[(6) - (7)].dtype).qualifier);
+          if (SwigType_isfunction(t)) {
+            SwigType *decl = SwigType_pop_function(t);
+            if (SwigType_ispointer(t)) {
+              String *nname = NewStringf("*%s",name);
+              Swig_feature_set(Swig_cparse_features(), nname, decl, "feature:varargs", val, 0);
+              Delete(nname);
+            } else {
+              Swig_feature_set(Swig_cparse_features(), name, decl, "feature:varargs", val, 0);
+            }
+            Delete(decl);
+          } else if (SwigType_ispointer(t)) {
+            String *nname = NewStringf("*%s",name);
+            Swig_feature_set(Swig_cparse_features(),nname,0,"feature:varargs",val, 0);
+            Delete(nname);
+          }
+        } else {
+          Swig_feature_set(Swig_cparse_features(),name,0,"feature:varargs",val, 0);
+        }
+        Delete(name);
+        (yyval.node) = 0;
+              ;}
+    break;
+
+  case 101:
+#line 2644 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.pl) = (yyvsp[(1) - (1)].pl); ;}
+    break;
+
+  case 102:
+#line 2645 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         int i;
+         int n;
+         Parm *p;
+         n = atoi(Char((yyvsp[(1) - (3)].dtype).val));
+         if (n <= 0) {
+           Swig_error(cparse_file, cparse_line,"Argument count in %%varargs must be positive.\n");
+           (yyval.pl) = 0;
+         } else {
+           String *name = Getattr((yyvsp[(3) - (3)].p), "name");
+           (yyval.pl) = Copy((yyvsp[(3) - (3)].p));
+           if (name)
+             Setattr((yyval.pl), "name", NewStringf("%s%d", name, n));
+           for (i = 1; i < n; i++) {
+             p = Copy((yyvsp[(3) - (3)].p));
+             name = Getattr(p, "name");
+             if (name)
+               Setattr(p, "name", NewStringf("%s%d", name, n-i));
+             set_nextSibling(p,(yyval.pl));
+             Delete((yyval.pl));
+             (yyval.pl) = p;
+           }
+         }
+                ;}
+    break;
+
+  case 103:
+#line 2680 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          (yyval.node) = 0;
+          if ((yyvsp[(3) - (6)].tmap).method) {
+            String *code = 0;
+            (yyval.node) = new_node("typemap");
+            Setattr((yyval.node),"method",(yyvsp[(3) - (6)].tmap).method);
+            if ((yyvsp[(3) - (6)].tmap).kwargs) {
+              ParmList *kw = (yyvsp[(3) - (6)].tmap).kwargs;
+                       code = remove_block(kw, (yyvsp[(6) - (6)].str));
+              Setattr((yyval.node),"kwargs", (yyvsp[(3) - (6)].tmap).kwargs);
+            }
+            code = code ? code : NewString((yyvsp[(6) - (6)].str));
+            Setattr((yyval.node),"code", code);
+            Delete(code);
+            appendChild((yyval.node),(yyvsp[(5) - (6)].p));
+          }
+          ;}
+    break;
+
+  case 104:
+#line 2697 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.node) = 0;
+        if ((yyvsp[(3) - (6)].tmap).method) {
+          (yyval.node) = new_node("typemap");
+          Setattr((yyval.node),"method",(yyvsp[(3) - (6)].tmap).method);
+          appendChild((yyval.node),(yyvsp[(5) - (6)].p));
+        }
+          ;}
+    break;
+
+  case 105:
+#line 2705 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          (yyval.node) = 0;
+          if ((yyvsp[(3) - (8)].tmap).method) {
+            (yyval.node) = new_node("typemapcopy");
+            Setattr((yyval.node),"method",(yyvsp[(3) - (8)].tmap).method);
+            Setattr((yyval.node),"pattern", Getattr((yyvsp[(7) - (8)].p),"pattern"));
+            appendChild((yyval.node),(yyvsp[(5) - (8)].p));
+          }
+          ;}
+    break;
+
+  case 106:
+#line 2718 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        Hash *p;
+        String *name;
+        p = nextSibling((yyvsp[(1) - (1)].node));
+        if (p && (!Getattr(p,"value"))) {
+          /* this is the deprecated two argument typemap form */
+          Swig_warning(WARN_DEPRECATED_TYPEMAP_LANG,cparse_file, cparse_line,
+               "Specifying the language name in %%typemap is deprecated - use #ifdef SWIG<LANG> instead.\n");
+          /* two argument typemap form */
+          name = Getattr((yyvsp[(1) - (1)].node),"name");
+          if (!name || (Strcmp(name,typemap_lang))) {
+            (yyval.tmap).method = 0;
+            (yyval.tmap).kwargs = 0;
+          } else {
+            (yyval.tmap).method = Getattr(p,"name");
+            (yyval.tmap).kwargs = nextSibling(p);
+          }
+        } else {
+          /* one-argument typemap-form */
+          (yyval.tmap).method = Getattr((yyvsp[(1) - (1)].node),"name");
+          (yyval.tmap).kwargs = p;
+        }
+                ;}
+    break;
+
+  case 107:
+#line 2743 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.p) = (yyvsp[(1) - (2)].p);
+        set_nextSibling((yyval.p),(yyvsp[(2) - (2)].p));
+       ;}
+    break;
+
+  case 108:
+#line 2749 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.p) = (yyvsp[(2) - (3)].p);
+        set_nextSibling((yyval.p),(yyvsp[(3) - (3)].p));
+                ;}
+    break;
+
+  case 109:
+#line 2753 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.p) = 0;;}
+    break;
+
+  case 110:
+#line 2756 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                  Parm *parm;
+         SwigType_push((yyvsp[(1) - (2)].type),(yyvsp[(2) - (2)].decl).type);
+         (yyval.p) = new_node("typemapitem");
+         parm = NewParmWithoutFileLineInfo((yyvsp[(1) - (2)].type),(yyvsp[(2) - (2)].decl).id);
+         Setattr((yyval.p),"pattern",parm);
+         Setattr((yyval.p),"parms", (yyvsp[(2) - (2)].decl).parms);
+         Delete(parm);
+         /*          $$ = NewParmWithoutFileLineInfo($1,$2.id);
+                 Setattr($$,"parms",$2.parms); */
+                ;}
+    break;
+
+  case 111:
+#line 2767 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                  (yyval.p) = new_node("typemapitem");
+         Setattr((yyval.p),"pattern",(yyvsp[(2) - (3)].pl));
+         /*          Setattr($$,"multitype",$2); */
+               ;}
+    break;
+
+  case 112:
+#line 2772 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.p) = new_node("typemapitem");
+        Setattr((yyval.p),"pattern", (yyvsp[(2) - (6)].pl));
+        /*                 Setattr($$,"multitype",$2); */
+        Setattr((yyval.p),"parms",(yyvsp[(5) - (6)].pl));
+               ;}
+    break;
+
+  case 113:
+#line 2785 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.node) = new_node("types");
+          Setattr((yyval.node),"parms",(yyvsp[(3) - (5)].pl));
+                   if ((yyvsp[(5) - (5)].str))
+            Setattr((yyval.node),"convcode",NewString((yyvsp[(5) - (5)].str)));
+               ;}
+    break;
+
+  case 114:
+#line 2797 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                  Parm *p, *tp;
+         Node *n;
+         Node *outer_class = currentOuterClass;
+         Symtab *tscope = 0;
+         int     specialized = 0;
+         int     variadic = 0;
+
+         (yyval.node) = 0;
+
+         tscope = Swig_symbol_current();          /* Get the current scope */
+
+         /* If the class name is qualified, we need to create or lookup namespace entries */
+         (yyvsp[(5) - (9)].str) = resolve_create_node_scope((yyvsp[(5) - (9)].str), 0);
+
+         if (nscope_inner && Strcmp(nodeType(nscope_inner), "class") == 0) {
+           outer_class = nscope_inner;
+         }
+
+         /*
+           We use the new namespace entry 'nscope' only to
+           emit the template node. The template parameters are
+           resolved in the current 'tscope'.
+
+           This is closer to the C++ (typedef) behavior.
+         */
+         n = Swig_cparse_template_locate((yyvsp[(5) - (9)].str),(yyvsp[(7) - (9)].p),tscope);
+
+         /* Patch the argument types to respect namespaces */
+         p = (yyvsp[(7) - (9)].p);
+         while (p) {
+           SwigType *value = Getattr(p,"value");
+           if (!value) {
+             SwigType *ty = Getattr(p,"type");
+             if (ty) {
+           SwigType *rty = 0;
+           int reduce = template_reduce;
+           if (reduce || !SwigType_ispointer(ty)) {
+             rty = Swig_symbol_typedef_reduce(ty,tscope);
+             if (!reduce) reduce = SwigType_ispointer(rty);
+           }
+           ty = reduce ? Swig_symbol_type_qualify(rty,tscope) : Swig_symbol_type_qualify(ty,tscope);
+           Setattr(p,"type",ty);
+           Delete(ty);
+           Delete(rty);
+             }
+           } else {
+             value = Swig_symbol_type_qualify(value,tscope);
+             Setattr(p,"value",value);
+             Delete(value);
+           }
+
+           p = nextSibling(p);
+         }
+
+         /* Look for the template */
+         {
+                    Node *nn = n;
+                    Node *linklistend = 0;
+                    Node *linkliststart = 0;
+                    while (nn) {
+                      Node *templnode = 0;
+                      if (Strcmp(nodeType(nn),"template") == 0) {
+                        int nnisclass = (Strcmp(Getattr(nn,"templatetype"),"class") == 0); /* if not a templated class it is a templated function */
+                        Parm *tparms = Getattr(nn,"templateparms");
+                        if (!tparms) {
+                          specialized = 1;
+                        } else if (Getattr(tparms,"variadic") && strncmp(Char(Getattr(tparms,"variadic")), "1", 1)==0) {
+                          variadic = 1;
+                        }
+                        if (nnisclass && !variadic && !specialized && (ParmList_len((yyvsp[(7) - (9)].p)) > ParmList_len(tparms))) {
+                          Swig_error(cparse_file, cparse_line, "Too many template parameters. Maximum of %d.\n", ParmList_len(tparms));
+                        } else if (nnisclass && !specialized && ((ParmList_len((yyvsp[(7) - (9)].p)) < (ParmList_numrequired(tparms) - (variadic?1:0))))) { /* Variadic parameter is optional */
+                          Swig_error(cparse_file, cparse_line, "Not enough template parameters specified. %d required.\n", (ParmList_numrequired(tparms)-(variadic?1:0)) );
+                        } else if (!nnisclass && ((ParmList_len((yyvsp[(7) - (9)].p)) != ParmList_len(tparms)))) {
+                          /* must be an overloaded templated method - ignore it as it is overloaded with a different number of template parameters */
+                          nn = Getattr(nn,"sym:nextSibling"); /* repeat for overloaded templated functions */
+                          continue;
+                        } else {
+             String *tname = Copy((yyvsp[(5) - (9)].str));
+                          int def_supplied = 0;
+                          /* Expand the template */
+             Node *templ = Swig_symbol_clookup((yyvsp[(5) - (9)].str),0);
+             Parm *targs = templ ? Getattr(templ,"templateparms") : 0;
+
+                          ParmList *temparms;
+                          if (specialized) temparms = CopyParmList((yyvsp[(7) - (9)].p));
+                          else temparms = CopyParmList(tparms);
+
+                          /* Create typedef's and arguments */
+                          p = (yyvsp[(7) - (9)].p);
+                          tp = temparms;
+                          if (!p && ParmList_len(p) != ParmList_len(temparms)) {
+                            /* we have no template parameters supplied in %template for a template that has default args*/
+                            p = tp;
+                            def_supplied = 1;
+                          }
+
+                          while (p) {
+                            String *value = Getattr(p,"value");
+                            if (def_supplied) {
+                              Setattr(p,"default","1");
+                            }
+                            if (value) {
+                              Setattr(tp,"value",value);
+                            } else {
+                              SwigType *ty = Getattr(p,"type");
+                              if (ty) {
+                                Setattr(tp,"type",ty);
+                              }
+                              Delattr(tp,"value");
+                            }
+               /* fix default arg values */
+               if (targs) {
+                 Parm *pi = temparms;
+                 Parm *ti = targs;
+                 String *tv = Getattr(tp,"value");
+                 if (!tv) tv = Getattr(tp,"type");
+                 while(pi != tp && ti && pi) {
+               String *name = Getattr(ti,"name");
+               String *value = Getattr(pi,"value");
+               if (!value) value = Getattr(pi,"type");
+               Replaceid(tv, name, value);
+               pi = nextSibling(pi);
+               ti = nextSibling(ti);
+                 }
+               }
+                            p = nextSibling(p);
+                            tp = nextSibling(tp);
+                            if (!p && tp) {
+                              p = tp;
+                              def_supplied = 1;
+                            } else if (p && !tp) { /* Variadic template - tp < p */
+                 SWIG_WARN_NODE_BEGIN(nn);
+                              Swig_warning(WARN_CPP11_VARIADIC_TEMPLATE,cparse_file, cparse_line,"Only the first variadic template argument is currently supported.\n");
+                 SWIG_WARN_NODE_END(nn);
+                              break;
+                            }
+                          }
+
+                          templnode = copy_node(nn);
+             update_nested_classes(templnode); /* update classes nested within template */
+                          /* We need to set the node name based on name used to instantiate */
+                          Setattr(templnode,"name",tname);
+             Delete(tname);
+                          if (!specialized) {
+                            Delattr(templnode,"sym:typename");
+                          } else {
+                            Setattr(templnode,"sym:typename","1");
+                          }
+             /* for now, nested %template is allowed only in the same scope as the template declaration */
+                          if ((yyvsp[(3) - (9)].id) && !(nnisclass && ((outer_class && (outer_class != Getattr(nn, "nested:outer")))
+               ||(extendmode && current_class && (current_class != Getattr(nn, "nested:outer")))))) {
+               /*
+                  Comment this out for 1.3.28. We need to
+                  re-enable it later but first we need to
+                  move %ignore from using %rename to use
+                  %feature(ignore).
+
+                  String *symname = Swig_name_make(templnode,0,$3,0,0);
+               */
+               String *symname = NewString((yyvsp[(3) - (9)].id));
+                            Swig_cparse_template_expand(templnode,symname,temparms,tscope);
+                            Setattr(templnode,"sym:name",symname);
+                          } else {
+                            static int cnt = 0;
+                            String *nname = NewStringf("__dummy_%d__", cnt++);
+                            Swig_cparse_template_expand(templnode,nname,temparms,tscope);
+                            Setattr(templnode,"sym:name",nname);
+               Delete(nname);
+                            Setattr(templnode,"feature:onlychildren", "typemap,typemapitem,typemapcopy,typedef,types,fragment,apply");
+               if ((yyvsp[(3) - (9)].id)) {
+                 Swig_warning(WARN_PARSE_NESTED_TEMPLATE, cparse_file, cparse_line, "Named nested template instantiations not supported. Processing as if no name was given to %%template().\n");
+               }
+                          }
+                          Delattr(templnode,"templatetype");
+                          Setattr(templnode,"template",nn);
+                          Setfile(templnode,cparse_file);
+                          Setline(templnode,cparse_line);
+                          Delete(temparms);
+             if (outer_class && nnisclass) {
+               SetFlag(templnode, "nested");
+               Setattr(templnode, "nested:outer", outer_class);
+             }
+                          add_symbols_copy(templnode);
+
+                          if (Strcmp(nodeType(templnode),"class") == 0) {
+
+                            /* Identify pure abstract methods */
+                            Setattr(templnode,"abstracts", pure_abstracts(firstChild(templnode)));
+
+                            /* Set up inheritance in symbol table */
+                            {
+                              Symtab  *csyms;
+                              List *baselist = Getattr(templnode,"baselist");
+                              csyms = Swig_symbol_current();
+                              Swig_symbol_setscope(Getattr(templnode,"symtab"));
+                              if (baselist) {
+                                List *bases = Swig_make_inherit_list(Getattr(templnode,"name"),baselist, Namespaceprefix);
+                                if (bases) {
+                                  Iterator s;
+                                  for (s = First(bases); s.item; s = Next(s)) {
+                                    Symtab *st = Getattr(s.item,"symtab");
+                                    if (st) {
+                     Setfile(st,Getfile(s.item));
+                     Setline(st,Getline(s.item));
+                                      Swig_symbol_inherit(st);
+                                    }
+                                  }
+                 Delete(bases);
+                                }
+                              }
+                              Swig_symbol_setscope(csyms);
+                            }
+
+                            /* Merge in %extend methods for this class.
+                  This only merges methods within %extend for a template specialized class such as
+                    template<typename T> class K {}; %extend K<int> { ... }
+                  The copy_node() call above has already added in the generic %extend methods such as
+                    template<typename T> class K {}; %extend K { ... } */
+
+               /* !!! This may be broken.  We may have to add the
+                  %extend methods at the beginning of the class */
+                            {
+                              String *stmp = 0;
+                              String *clsname;
+                              Node *am;
+                              if (Namespaceprefix) {
+                                clsname = stmp = NewStringf("%s::%s", Namespaceprefix, Getattr(templnode,"name"));
+                              } else {
+                                clsname = Getattr(templnode,"name");
+                              }
+                              am = Getattr(Swig_extend_hash(),clsname);
+                              if (am) {
+                                Symtab *st = Swig_symbol_current();
+                                Swig_symbol_setscope(Getattr(templnode,"symtab"));
+                                /*             Printf(stdout,"%s: %s %p %p\n", Getattr(templnode,"name"), clsname, Swig_symbol_current(), Getattr(templnode,"symtab")); */
+                                Swig_extend_merge(templnode,am);
+                                Swig_symbol_setscope(st);
+               Swig_extend_append_previous(templnode,am);
+                                Delattr(Swig_extend_hash(),clsname);
+                              }
+                 if (stmp) Delete(stmp);
+                            }
+
+                            /* Add to classes hash */
+               if (!classes)
+                 classes = NewHash();
+
+               if (Namespaceprefix) {
+                 String *temp = NewStringf("%s::%s", Namespaceprefix, Getattr(templnode,"name"));
+                 Setattr(classes,temp,templnode);
+                 Delete(temp);
+               } else {
+                 String *qs = Swig_symbol_qualifiedscopename(templnode);
+                 Setattr(classes, qs,templnode);
+                 Delete(qs);
+               }
+                          }
+                        }
+
+                        /* all the overloaded templated functions are added into a linked list */
+                        if (!linkliststart)
+                          linkliststart = templnode;
+                        if (nscope_inner) {
+                          /* non-global namespace */
+                          if (templnode) {
+                            appendChild(nscope_inner,templnode);
+               Delete(templnode);
+                            if (nscope) (yyval.node) = nscope;
+                          }
+                        } else {
+                          /* global namespace */
+                          if (!linklistend) {
+                            (yyval.node) = templnode;
+                          } else {
+                            set_nextSibling(linklistend,templnode);
+               Delete(templnode);
+                          }
+                          linklistend = templnode;
+                        }
+                      }
+                      nn = Getattr(nn,"sym:nextSibling"); /* repeat for overloaded templated functions. If a templated class there will never be a sibling. */
+                    }
+                    update_defaultargs(linkliststart);
+                    update_abstracts(linkliststart);
+         }
+             Swig_symbol_setscope(tscope);
+         Delete(Namespaceprefix);
+         Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+                ;}
+    break;
+
+  case 115:
+#line 3095 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         Swig_warning(0,cparse_file, cparse_line,"%s\n", (yyvsp[(2) - (2)].str));
+         (yyval.node) = 0;
+               ;}
+    break;
+
+  case 116:
+#line 3105 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.node) = (yyvsp[(1) - (1)].node);
+                    if ((yyval.node)) {
+                 add_symbols((yyval.node));
+                      default_arguments((yyval.node));
+                   }
+                ;}
+    break;
+
+  case 117:
+#line 3112 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 118:
+#line 3113 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 119:
+#line 3117 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         if (Strcmp((yyvsp[(2) - (3)].str),"C") == 0) {
+           cparse_externc = 1;
+         }
+       ;}
+    break;
+
+  case 120:
+#line 3121 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         cparse_externc = 0;
+         if (Strcmp((yyvsp[(2) - (6)].str),"C") == 0) {
+           Node *n = firstChild((yyvsp[(5) - (6)].node));
+           (yyval.node) = new_node("extern");
+           Setattr((yyval.node),"name",(yyvsp[(2) - (6)].str));
+           appendChild((yyval.node),n);
+           while (n) {
+             SwigType *decl = Getattr(n,"decl");
+             if (SwigType_isfunction(decl) && !Equal(Getattr(n, "storage"), "typedef")) {
+           Setattr(n,"storage","externc");
+             }
+             n = nextSibling(n);
+           }
+         } else {
+            Swig_warning(WARN_PARSE_UNDEFINED_EXTERN,cparse_file, cparse_line,"Unrecognized extern type \"%s\".\n", (yyvsp[(2) - (6)].str));
+           (yyval.node) = new_node("extern");
+           Setattr((yyval.node),"name",(yyvsp[(2) - (6)].str));
+           appendChild((yyval.node),firstChild((yyvsp[(5) - (6)].node)));
+         }
+                ;}
+    break;
+
+  case 121:
+#line 3142 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.node) = (yyvsp[(1) - (1)].node);
+         SWIG_WARN_NODE_BEGIN((yyval.node));
+         Swig_warning(WARN_CPP11_LAMBDA, cparse_file, cparse_line, "Lambda expressions and closures are not fully supported yet.\n");
+         SWIG_WARN_NODE_END((yyval.node));
+       ;}
+    break;
+
+  case 122:
+#line 3148 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         /* Convert using statement to a typedef statement */
+         (yyval.node) = new_node("cdecl");
+         Setattr((yyval.node),"type",(yyvsp[(4) - (6)].type));
+         Setattr((yyval.node),"storage","typedef");
+         Setattr((yyval.node),"name",(yyvsp[(2) - (6)].str));
+         Setattr((yyval.node),"decl",(yyvsp[(5) - (6)].decl).type);
+         SetFlag((yyval.node),"typealias");
+         add_symbols((yyval.node));
+       ;}
+    break;
+
+  case 123:
+#line 3158 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         /* Convert alias template to a "template" typedef statement */
+         (yyval.node) = new_node("template");
+         Setattr((yyval.node),"type",(yyvsp[(8) - (10)].type));
+         Setattr((yyval.node),"storage","typedef");
+         Setattr((yyval.node),"name",(yyvsp[(6) - (10)].str));
+         Setattr((yyval.node),"decl",(yyvsp[(9) - (10)].decl).type);
+         Setattr((yyval.node),"templateparms",(yyvsp[(3) - (10)].tparms));
+         Setattr((yyval.node),"templatetype","cdecl");
+         SetFlag((yyval.node),"aliastemplate");
+         add_symbols((yyval.node));
+       ;}
+    break;
+
+  case 124:
+#line 3170 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.node) = (yyvsp[(1) - (1)].node);
+                ;}
+    break;
+
+  case 125:
+#line 3179 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         String *decl = (yyvsp[(3) - (6)].decl).type;
+              (yyval.node) = new_node("cdecl");
+         if ((yyvsp[(4) - (6)].dtype).qualifier)
+           decl = add_qualifier_to_declarator((yyvsp[(3) - (6)].decl).type, (yyvsp[(4) - (6)].dtype).qualifier);
+         Setattr((yyval.node),"refqualifier",(yyvsp[(4) - (6)].dtype).refqualifier);
+         Setattr((yyval.node),"type",(yyvsp[(2) - (6)].type));
+         Setattr((yyval.node),"storage",(yyvsp[(1) - (6)].id));
+         Setattr((yyval.node),"name",(yyvsp[(3) - (6)].decl).id);
+         Setattr((yyval.node),"decl",decl);
+         Setattr((yyval.node),"parms",(yyvsp[(3) - (6)].decl).parms);
+         Setattr((yyval.node),"value",(yyvsp[(5) - (6)].dtype).val);
+         Setattr((yyval.node),"throws",(yyvsp[(4) - (6)].dtype).throws);
+         Setattr((yyval.node),"throw",(yyvsp[(4) - (6)].dtype).throwf);
+         Setattr((yyval.node),"noexcept",(yyvsp[(4) - (6)].dtype).nexcept);
+         Setattr((yyval.node),"final",(yyvsp[(4) - (6)].dtype).final);
+         if ((yyvsp[(5) - (6)].dtype).val && (yyvsp[(5) - (6)].dtype).type) {
+       /* store initializer type as it might be different to the declared type */
+       SwigType *valuetype = NewSwigType((yyvsp[(5) - (6)].dtype).type);
+       if (Len(valuetype) > 0)
+         Setattr((yyval.node),"valuetype",valuetype);
+       else
+         Delete(valuetype);
+         }
+         if (!(yyvsp[(6) - (6)].node)) {
+       if (Len(scanner_ccode)) {
+         String *code = Copy(scanner_ccode);
+         Setattr((yyval.node),"code",code);
+         Delete(code);
+       }
+         } else {
+       Node *n = (yyvsp[(6) - (6)].node);
+       /* Inherit attributes */
+       while (n) {
+         String *type = Copy((yyvsp[(2) - (6)].type));
+         Setattr(n,"type",type);
+         Setattr(n,"storage",(yyvsp[(1) - (6)].id));
+         n = nextSibling(n);
+         Delete(type);
+       }
+         }
+         if ((yyvsp[(5) - (6)].dtype).bitfield) {
+       Setattr((yyval.node),"bitfield", (yyvsp[(5) - (6)].dtype).bitfield);
+         }
+
+         if ((yyvsp[(3) - (6)].decl).id) {
+       /* Look for "::" declarations (ignored) */
+       if (Strstr((yyvsp[(3) - (6)].decl).id, "::")) {
+         /* This is a special case. If the scope name of the declaration exactly
+            matches that of the declaration, then we will allow it. Otherwise, delete. */
+         String *p = Swig_scopename_prefix((yyvsp[(3) - (6)].decl).id);
+         if (p) {
+           if ((Namespaceprefix && Strcmp(p, Namespaceprefix) == 0) ||
+           (Classprefix && Strcmp(p, Classprefix) == 0)) {
+             String *lstr = Swig_scopename_last((yyvsp[(3) - (6)].decl).id);
+             Setattr((yyval.node), "name", lstr);
+             Delete(lstr);
+             set_nextSibling((yyval.node), (yyvsp[(6) - (6)].node));
+           } else {
+             Delete((yyval.node));
+             (yyval.node) = (yyvsp[(6) - (6)].node);
+           }
+           Delete(p);
+         } else {
+           Delete((yyval.node));
+           (yyval.node) = (yyvsp[(6) - (6)].node);
+         }
+       } else {
+         set_nextSibling((yyval.node), (yyvsp[(6) - (6)].node));
+       }
+         } else {
+       Swig_error(cparse_file, cparse_line, "Missing symbol name for global declaration\n");
+       (yyval.node) = 0;
+         }
+
+         if ((yyvsp[(4) - (6)].dtype).qualifier && (yyvsp[(1) - (6)].id) && Strstr((yyvsp[(1) - (6)].id), "static"))
+       Swig_error(cparse_file, cparse_line, "Static function %s cannot have a qualifier.\n", Swig_name_decl((yyval.node)));
+           ;}
+    break;
+
+  case 126:
+#line 3259 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+              (yyval.node) = new_node("cdecl");
+         if ((yyvsp[(4) - (9)].dtype).qualifier) SwigType_push((yyvsp[(3) - (9)].decl).type, (yyvsp[(4) - (9)].dtype).qualifier);
+         Setattr((yyval.node),"refqualifier",(yyvsp[(4) - (9)].dtype).refqualifier);
+         Setattr((yyval.node),"type",(yyvsp[(6) - (9)].node));
+         Setattr((yyval.node),"storage",(yyvsp[(1) - (9)].id));
+         Setattr((yyval.node),"name",(yyvsp[(3) - (9)].decl).id);
+         Setattr((yyval.node),"decl",(yyvsp[(3) - (9)].decl).type);
+         Setattr((yyval.node),"parms",(yyvsp[(3) - (9)].decl).parms);
+         Setattr((yyval.node),"value",(yyvsp[(4) - (9)].dtype).val);
+         Setattr((yyval.node),"throws",(yyvsp[(4) - (9)].dtype).throws);
+         Setattr((yyval.node),"throw",(yyvsp[(4) - (9)].dtype).throwf);
+         Setattr((yyval.node),"noexcept",(yyvsp[(4) - (9)].dtype).nexcept);
+         Setattr((yyval.node),"final",(yyvsp[(4) - (9)].dtype).final);
+         if (!(yyvsp[(9) - (9)].node)) {
+       if (Len(scanner_ccode)) {
+         String *code = Copy(scanner_ccode);
+         Setattr((yyval.node),"code",code);
+         Delete(code);
+       }
+         } else {
+       Node *n = (yyvsp[(9) - (9)].node);
+       while (n) {
+         String *type = Copy((yyvsp[(6) - (9)].node));
+         Setattr(n,"type",type);
+         Setattr(n,"storage",(yyvsp[(1) - (9)].id));
+         n = nextSibling(n);
+         Delete(type);
+       }
+         }
+         if ((yyvsp[(4) - (9)].dtype).bitfield) {
+       Setattr((yyval.node),"bitfield", (yyvsp[(4) - (9)].dtype).bitfield);
+         }
+
+         if (Strstr((yyvsp[(3) - (9)].decl).id,"::")) {
+                String *p = Swig_scopename_prefix((yyvsp[(3) - (9)].decl).id);
+       if (p) {
+         if ((Namespaceprefix && Strcmp(p, Namespaceprefix) == 0) ||
+             (Classprefix && Strcmp(p, Classprefix) == 0)) {
+           String *lstr = Swig_scopename_last((yyvsp[(3) - (9)].decl).id);
+           Setattr((yyval.node),"name",lstr);
+           Delete(lstr);
+           set_nextSibling((yyval.node), (yyvsp[(9) - (9)].node));
+         } else {
+           Delete((yyval.node));
+           (yyval.node) = (yyvsp[(9) - (9)].node);
+         }
+         Delete(p);
+       } else {
+         Delete((yyval.node));
+         (yyval.node) = (yyvsp[(9) - (9)].node);
+       }
+         } else {
+       set_nextSibling((yyval.node), (yyvsp[(9) - (9)].node));
+         }
+
+         if ((yyvsp[(4) - (9)].dtype).qualifier && (yyvsp[(1) - (9)].id) && Strstr((yyvsp[(1) - (9)].id), "static"))
+       Swig_error(cparse_file, cparse_line, "Static function %s cannot have a qualifier.\n", Swig_name_decl((yyval.node)));
+           ;}
+    break;
+
+  case 127:
+#line 3322 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.node) = 0;
+                   Clear(scanner_ccode);
+               ;}
+    break;
+
+  case 128:
+#line 3326 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.node) = new_node("cdecl");
+        if ((yyvsp[(3) - (5)].dtype).qualifier) SwigType_push((yyvsp[(2) - (5)].decl).type,(yyvsp[(3) - (5)].dtype).qualifier);
+        Setattr((yyval.node),"refqualifier",(yyvsp[(3) - (5)].dtype).refqualifier);
+        Setattr((yyval.node),"name",(yyvsp[(2) - (5)].decl).id);
+        Setattr((yyval.node),"decl",(yyvsp[(2) - (5)].decl).type);
+        Setattr((yyval.node),"parms",(yyvsp[(2) - (5)].decl).parms);
+        Setattr((yyval.node),"value",(yyvsp[(4) - (5)].dtype).val);
+        Setattr((yyval.node),"throws",(yyvsp[(3) - (5)].dtype).throws);
+        Setattr((yyval.node),"throw",(yyvsp[(3) - (5)].dtype).throwf);
+        Setattr((yyval.node),"noexcept",(yyvsp[(3) - (5)].dtype).nexcept);
+        Setattr((yyval.node),"final",(yyvsp[(3) - (5)].dtype).final);
+        if ((yyvsp[(4) - (5)].dtype).bitfield) {
+          Setattr((yyval.node),"bitfield", (yyvsp[(4) - (5)].dtype).bitfield);
+        }
+        if (!(yyvsp[(5) - (5)].node)) {
+          if (Len(scanner_ccode)) {
+            String *code = Copy(scanner_ccode);
+            Setattr((yyval.node),"code",code);
+            Delete(code);
+          }
+        } else {
+          set_nextSibling((yyval.node), (yyvsp[(5) - (5)].node));
+        }
+          ;}
+    break;
+
+  case 129:
+#line 3351 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   skip_balanced('{','}');
+                   (yyval.node) = 0;
+               ;}
+    break;
+
+  case 130:
+#line 3355 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          (yyval.node) = 0;
+          if (yychar == RPAREN) {
+              Swig_error(cparse_file, cparse_line, "Unexpected ')'.\n");
+          } else {
+              Swig_error(cparse_file, cparse_line, "Syntax error - possibly a missing semicolon.\n");
+          }
+          exit(1);
+               ;}
+    break;
+
+  case 131:
+#line 3366 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.dtype) = (yyvsp[(1) - (1)].dtype);
+              ;}
+    break;
+
+  case 132:
+#line 3371 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].type); ;}
+    break;
+
+  case 133:
+#line 3372 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].type); ;}
+    break;
+
+  case 134:
+#line 3373 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].type); ;}
+    break;
+
+  case 135:
+#line 3377 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].type); ;}
+    break;
+
+  case 136:
+#line 3378 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].str); ;}
+    break;
+
+  case 137:
+#line 3379 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].type); ;}
+    break;
+
+  case 138:
+#line 3390 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.node) = new_node("lambda");
+         Setattr((yyval.node),"name",(yyvsp[(3) - (11)].str));
+         add_symbols((yyval.node));
+           ;}
+    break;
+
+  case 139:
+#line 3395 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.node) = new_node("lambda");
+         Setattr((yyval.node),"name",(yyvsp[(3) - (13)].str));
+         add_symbols((yyval.node));
+       ;}
+    break;
+
+  case 140:
+#line 3400 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.node) = new_node("lambda");
+         Setattr((yyval.node),"name",(yyvsp[(3) - (7)].str));
+         add_symbols((yyval.node));
+       ;}
+    break;
+
+  case 141:
+#line 3407 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         skip_balanced('[',']');
+         (yyval.node) = 0;
+           ;}
+    break;
+
+  case 142:
+#line 3413 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         skip_balanced('{','}');
+         (yyval.node) = 0;
+       ;}
+    break;
+
+  case 143:
+#line 3418 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.pl) = 0;
+       ;}
+    break;
+
+  case 144:
+#line 3421 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         skip_balanced('(',')');
+       ;}
+    break;
+
+  case 145:
+#line 3423 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.pl) = 0;
+       ;}
+    break;
+
+  case 146:
+#line 3434 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          (yyval.node) = (char *)"enum";
+         ;}
+    break;
+
+  case 147:
+#line 3437 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          (yyval.node) = (char *)"enum class";
+         ;}
+    break;
+
+  case 148:
+#line 3440 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          (yyval.node) = (char *)"enum struct";
+         ;}
+    break;
+
+  case 149:
+#line 3449 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.node) = (yyvsp[(2) - (2)].type);
+              ;}
+    break;
+
+  case 150:
+#line 3452 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = 0; ;}
+    break;
+
+  case 151:
+#line 3459 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          SwigType *ty = 0;
+          int scopedenum = (yyvsp[(3) - (5)].id) && !Equal((yyvsp[(2) - (5)].node), "enum");
+          (yyval.node) = new_node("enumforward");
+          ty = NewStringf("enum %s", (yyvsp[(3) - (5)].id));
+          Setattr((yyval.node),"enumkey",(yyvsp[(2) - (5)].node));
+          if (scopedenum)
+            SetFlag((yyval.node), "scopedenum");
+          Setattr((yyval.node),"name",(yyvsp[(3) - (5)].id));
+          Setattr((yyval.node),"inherit",(yyvsp[(4) - (5)].node));
+          Setattr((yyval.node),"type",ty);
+          Setattr((yyval.node),"sym:weak", "1");
+          add_symbols((yyval.node));
+         ;}
+    break;
+
+  case 152:
+#line 3481 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         SwigType *ty = 0;
+         int scopedenum = (yyvsp[(3) - (8)].id) && !Equal((yyvsp[(2) - (8)].node), "enum");
+                  (yyval.node) = new_node("enum");
+         ty = NewStringf("enum %s", (yyvsp[(3) - (8)].id));
+         Setattr((yyval.node),"enumkey",(yyvsp[(2) - (8)].node));
+         if (scopedenum)
+           SetFlag((yyval.node), "scopedenum");
+         Setattr((yyval.node),"name",(yyvsp[(3) - (8)].id));
+         Setattr((yyval.node),"inherit",(yyvsp[(4) - (8)].node));
+         Setattr((yyval.node),"type",ty);
+         appendChild((yyval.node),(yyvsp[(6) - (8)].node));
+         add_symbols((yyval.node));      /* Add to tag space */
+
+         if (scopedenum) {
+           Swig_symbol_newscope();
+           Swig_symbol_setscopename((yyvsp[(3) - (8)].id));
+           Delete(Namespaceprefix);
+           Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+         }
+
+         add_symbols((yyvsp[(6) - (8)].node));      /* Add enum values to appropriate enum or enum class scope */
+
+         if (scopedenum) {
+           Setattr((yyval.node),"symtab", Swig_symbol_popscope());
+           Delete(Namespaceprefix);
+           Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+         }
+               ;}
+    break;
+
+  case 153:
+#line 3510 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        Node *n;
+        SwigType *ty = 0;
+        String   *unnamed = 0;
+        int       unnamedinstance = 0;
+        int scopedenum = (yyvsp[(3) - (11)].id) && !Equal((yyvsp[(2) - (11)].node), "enum");
+
+        (yyval.node) = new_node("enum");
+        Setattr((yyval.node),"enumkey",(yyvsp[(2) - (11)].node));
+        if (scopedenum)
+          SetFlag((yyval.node), "scopedenum");
+        Setattr((yyval.node),"inherit",(yyvsp[(4) - (11)].node));
+        if ((yyvsp[(3) - (11)].id)) {
+          Setattr((yyval.node),"name",(yyvsp[(3) - (11)].id));
+          ty = NewStringf("enum %s", (yyvsp[(3) - (11)].id));
+        } else if ((yyvsp[(8) - (11)].decl).id) {
+          unnamed = make_unnamed();
+          ty = NewStringf("enum %s", unnamed);
+          Setattr((yyval.node),"unnamed",unnamed);
+                   /* name is not set for unnamed enum instances, e.g. enum { foo } Instance; */
+          if ((yyvsp[(1) - (11)].id) && Cmp((yyvsp[(1) - (11)].id),"typedef") == 0) {
+            Setattr((yyval.node),"name",(yyvsp[(8) - (11)].decl).id);
+                   } else {
+                     unnamedinstance = 1;
+                   }
+          Setattr((yyval.node),"storage",(yyvsp[(1) - (11)].id));
+        }
+        if ((yyvsp[(8) - (11)].decl).id && Cmp((yyvsp[(1) - (11)].id),"typedef") == 0) {
+          Setattr((yyval.node),"tdname",(yyvsp[(8) - (11)].decl).id);
+                   Setattr((yyval.node),"allows_typedef","1");
+                 }
+        appendChild((yyval.node),(yyvsp[(6) - (11)].node));
+        n = new_node("cdecl");
+        Setattr(n,"type",ty);
+        Setattr(n,"name",(yyvsp[(8) - (11)].decl).id);
+        Setattr(n,"storage",(yyvsp[(1) - (11)].id));
+        Setattr(n,"decl",(yyvsp[(8) - (11)].decl).type);
+        Setattr(n,"parms",(yyvsp[(8) - (11)].decl).parms);
+        Setattr(n,"unnamed",unnamed);
+
+                 if (unnamedinstance) {
+          SwigType *cty = NewString("enum ");
+          Setattr((yyval.node),"type",cty);
+          SetFlag((yyval.node),"unnamedinstance");
+          SetFlag(n,"unnamedinstance");
+          Delete(cty);
+                 }
+        if ((yyvsp[(11) - (11)].node)) {
+          Node *p = (yyvsp[(11) - (11)].node);
+          set_nextSibling(n,p);
+          while (p) {
+            SwigType *cty = Copy(ty);
+            Setattr(p,"type",cty);
+            Setattr(p,"unnamed",unnamed);
+            Setattr(p,"storage",(yyvsp[(1) - (11)].id));
+            Delete(cty);
+            p = nextSibling(p);
+          }
+        } else {
+          if (Len(scanner_ccode)) {
+            String *code = Copy(scanner_ccode);
+            Setattr(n,"code",code);
+            Delete(code);
+          }
+        }
+
+                 /* Ensure that typedef enum ABC {foo} XYZ; uses XYZ for sym:name, like structs.
+                  * Note that class_rename/yyrename are bit of a mess so used this simple approach to change the name. */
+                 if ((yyvsp[(8) - (11)].decl).id && (yyvsp[(3) - (11)].id) && Cmp((yyvsp[(1) - (11)].id),"typedef") == 0) {
+          String *name = NewString((yyvsp[(8) - (11)].decl).id);
+                   Setattr((yyval.node), "parser:makename", name);
+          Delete(name);
+                 }
+
+        add_symbols((yyval.node));       /* Add enum to tag space */
+        set_nextSibling((yyval.node),n);
+        Delete(n);
+
+        if (scopedenum) {
+          Swig_symbol_newscope();
+          Swig_symbol_setscopename((yyvsp[(3) - (11)].id));
+          Delete(Namespaceprefix);
+          Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+        }
+
+        add_symbols((yyvsp[(6) - (11)].node));      /* Add enum values to appropriate enum or enum class scope */
+
+        if (scopedenum) {
+          Setattr((yyval.node),"symtab", Swig_symbol_popscope());
+          Delete(Namespaceprefix);
+          Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+        }
+
+            add_symbols(n);
+        Delete(unnamed);
+          ;}
+    break;
+
+  case 154:
+#line 3608 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   /* This is a sick hack.  If the ctor_end has parameters,
+                      and the parms parameter only has 1 parameter, this
+                      could be a declaration of the form:
+
+                         type (id)(parms)
+
+            Otherwise it's an error. */
+                    int err = 0;
+                    (yyval.node) = 0;
+
+           if ((ParmList_len((yyvsp[(4) - (6)].pl)) == 1) && (!Swig_scopename_check((yyvsp[(2) - (6)].type)))) {
+             SwigType *ty = Getattr((yyvsp[(4) - (6)].pl),"type");
+             String *name = Getattr((yyvsp[(4) - (6)].pl),"name");
+             err = 1;
+             if (!name) {
+           (yyval.node) = new_node("cdecl");
+           Setattr((yyval.node),"type",(yyvsp[(2) - (6)].type));
+           Setattr((yyval.node),"storage",(yyvsp[(1) - (6)].id));
+           Setattr((yyval.node),"name",ty);
+
+           if ((yyvsp[(6) - (6)].decl).have_parms) {
+             SwigType *decl = NewStringEmpty();
+             SwigType_add_function(decl,(yyvsp[(6) - (6)].decl).parms);
+             Setattr((yyval.node),"decl",decl);
+             Setattr((yyval.node),"parms",(yyvsp[(6) - (6)].decl).parms);
+             if (Len(scanner_ccode)) {
+               String *code = Copy(scanner_ccode);
+               Setattr((yyval.node),"code",code);
+               Delete(code);
+             }
+           }
+           if ((yyvsp[(6) - (6)].decl).defarg) {
+             Setattr((yyval.node),"value",(yyvsp[(6) - (6)].decl).defarg);
+           }
+           Setattr((yyval.node),"throws",(yyvsp[(6) - (6)].decl).throws);
+           Setattr((yyval.node),"throw",(yyvsp[(6) - (6)].decl).throwf);
+           Setattr((yyval.node),"noexcept",(yyvsp[(6) - (6)].decl).nexcept);
+           Setattr((yyval.node),"final",(yyvsp[(6) - (6)].decl).final);
+           err = 0;
+             }
+           }
+           if (err) {
+             Swig_error(cparse_file,cparse_line,"Syntax error in input(2).\n");
+             exit(1);
+           }
+                ;}
+    break;
+
+  case 155:
+#line 3661 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {  (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 156:
+#line 3662 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 157:
+#line 3663 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 158:
+#line 3664 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 159:
+#line 3665 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 160:
+#line 3666 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = 0; ;}
+    break;
+
+  case 161:
+#line 3671 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   String *prefix;
+                   List *bases = 0;
+          Node *scope = 0;
+          String *code;
+          (yyval.node) = new_node("class");
+          Setline((yyval.node),cparse_start_line);
+          Setattr((yyval.node),"kind",(yyvsp[(2) - (5)].id));
+          if ((yyvsp[(4) - (5)].bases)) {
+            Setattr((yyval.node),"baselist", Getattr((yyvsp[(4) - (5)].bases),"public"));
+            Setattr((yyval.node),"protectedbaselist", Getattr((yyvsp[(4) - (5)].bases),"protected"));
+            Setattr((yyval.node),"privatebaselist", Getattr((yyvsp[(4) - (5)].bases),"private"));
+          }
+          Setattr((yyval.node),"allows_typedef","1");
+
+          /* preserve the current scope */
+          Setattr((yyval.node),"prev_symtab",Swig_symbol_current());
+
+          /* If the class name is qualified.  We need to create or lookup namespace/scope entries */
+          scope = resolve_create_node_scope((yyvsp[(3) - (5)].str), 1);
+          /* save nscope_inner to the class - it may be overwritten in nested classes*/
+          Setattr((yyval.node), "nested:innerscope", nscope_inner);
+          Setattr((yyval.node), "nested:nscope", nscope);
+          Setfile(scope,cparse_file);
+          Setline(scope,cparse_line);
+          (yyvsp[(3) - (5)].str) = scope;
+          Setattr((yyval.node),"name",(yyvsp[(3) - (5)].str));
+
+          if (currentOuterClass) {
+            SetFlag((yyval.node), "nested");
+            Setattr((yyval.node), "nested:outer", currentOuterClass);
+            set_access_mode((yyval.node));
+          }
+          Swig_features_get(Swig_cparse_features(), Namespaceprefix, Getattr((yyval.node), "name"), 0, (yyval.node));
+          /* save yyrename to the class attribute, to be used later in add_symbols()*/
+          Setattr((yyval.node), "class_rename", make_name((yyval.node), (yyvsp[(3) - (5)].str), 0));
+          Setattr((yyval.node), "Classprefix", (yyvsp[(3) - (5)].str));
+          Classprefix = NewString((yyvsp[(3) - (5)].str));
+          /* Deal with inheritance  */
+          if ((yyvsp[(4) - (5)].bases))
+            bases = Swig_make_inherit_list((yyvsp[(3) - (5)].str),Getattr((yyvsp[(4) - (5)].bases),"public"),Namespaceprefix);
+          prefix = SwigType_istemplate_templateprefix((yyvsp[(3) - (5)].str));
+          if (prefix) {
+            String *fbase, *tbase;
+            if (Namespaceprefix) {
+              fbase = NewStringf("%s::%s", Namespaceprefix,(yyvsp[(3) - (5)].str));
+              tbase = NewStringf("%s::%s", Namespaceprefix, prefix);
+            } else {
+              fbase = Copy((yyvsp[(3) - (5)].str));
+              tbase = Copy(prefix);
+            }
+            Swig_name_inherit(tbase,fbase);
+            Delete(fbase);
+            Delete(tbase);
+          }
+                   if (strcmp((yyvsp[(2) - (5)].id),"class") == 0) {
+            cplus_mode = CPLUS_PRIVATE;
+          } else {
+            cplus_mode = CPLUS_PUBLIC;
+          }
+          if (!cparse_cplusplus) {
+            set_scope_to_global();
+          }
+          Swig_symbol_newscope();
+          Swig_symbol_setscopename((yyvsp[(3) - (5)].str));
+          Swig_inherit_base_symbols(bases);
+          Delete(Namespaceprefix);
+          Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+          cparse_start_line = cparse_line;
+
+          /* If there are active template parameters, we need to make sure they are
+                      placed in the class symbol table so we can catch shadows */
+
+          if (template_parameters) {
+            Parm *tp = template_parameters;
+            while(tp) {
+              String *tpname = Copy(Getattr(tp,"name"));
+              Node *tn = new_node("templateparm");
+              Setattr(tn,"name",tpname);
+              Swig_symbol_cadd(tpname,tn);
+              tp = nextSibling(tp);
+              Delete(tpname);
+            }
+          }
+          Delete(prefix);
+          inclass = 1;
+          currentOuterClass = (yyval.node);
+          if (cparse_cplusplusout) {
+            /* save the structure declaration to declare it in global scope for C++ to see */
+            code = get_raw_text_balanced('{', '}');
+            Setattr((yyval.node), "code", code);
+            Delete(code);
+          }
+               ;}
+    break;
+
+  case 162:
+#line 3764 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          Node *p;
+          SwigType *ty;
+          Symtab *cscope;
+          Node *am = 0;
+          String *scpname = 0;
+          (void) (yyvsp[(6) - (9)].node);
+          (yyval.node) = currentOuterClass;
+          currentOuterClass = Getattr((yyval.node), "nested:outer");
+          nscope_inner = Getattr((yyval.node), "nested:innerscope");
+          nscope = Getattr((yyval.node), "nested:nscope");
+          Delattr((yyval.node), "nested:innerscope");
+          Delattr((yyval.node), "nested:nscope");
+          if (nscope_inner && Strcmp(nodeType(nscope_inner), "class") == 0) { /* actual parent class for this class */
+            Node* forward_declaration = Swig_symbol_clookup_no_inherit(Getattr((yyval.node),"name"), Getattr(nscope_inner, "symtab"));
+            if (forward_declaration) {
+              Setattr((yyval.node), "access", Getattr(forward_declaration, "access"));
+            }
+            Setattr((yyval.node), "nested:outer", nscope_inner);
+            SetFlag((yyval.node), "nested");
+                   }
+          if (!currentOuterClass)
+            inclass = 0;
+          cscope = Getattr((yyval.node), "prev_symtab");
+          Delattr((yyval.node), "prev_symtab");
+
+          /* Check for pure-abstract class */
+          Setattr((yyval.node),"abstracts", pure_abstracts((yyvsp[(7) - (9)].node)));
+
+          /* This bit of code merges in a previously defined %extend directive (if any) */
+          {
+            String *clsname = Swig_symbol_qualifiedscopename(0);
+            am = Getattr(Swig_extend_hash(), clsname);
+            if (am) {
+              Swig_extend_merge((yyval.node), am);
+              Delattr(Swig_extend_hash(), clsname);
+            }
+            Delete(clsname);
+          }
+          if (!classes) classes = NewHash();
+          scpname = Swig_symbol_qualifiedscopename(0);
+          Setattr(classes, scpname, (yyval.node));
+
+          appendChild((yyval.node), (yyvsp[(7) - (9)].node));
+
+          if (am)
+            Swig_extend_append_previous((yyval.node), am);
+
+          p = (yyvsp[(9) - (9)].node);
+          if (p && !nscope_inner) {
+            if (!cparse_cplusplus && currentOuterClass)
+              appendChild(currentOuterClass, p);
+            else
+             appendSibling((yyval.node), p);
+          }
+
+          if (nscope_inner) {
+            ty = NewString(scpname); /* if the class is declared out of scope, let the declarator use fully qualified type*/
+          } else if (cparse_cplusplus && !cparse_externc) {
+            ty = NewString((yyvsp[(3) - (9)].str));
+          } else {
+            ty = NewStringf("%s %s", (yyvsp[(2) - (9)].id), (yyvsp[(3) - (9)].str));
+          }
+          while (p) {
+            Setattr(p, "storage", (yyvsp[(1) - (9)].id));
+            Setattr(p, "type" ,ty);
+            if (!cparse_cplusplus && currentOuterClass && (!Getattr(currentOuterClass, "name"))) {
+              SetFlag(p, "hasconsttype");
+              SetFlag(p, "feature:immutable");
+            }
+            p = nextSibling(p);
+          }
+          if ((yyvsp[(9) - (9)].node) && Cmp((yyvsp[(1) - (9)].id),"typedef") == 0)
+            add_typedef_name((yyval.node), (yyvsp[(9) - (9)].node), (yyvsp[(3) - (9)].str), cscope, scpname);
+          Delete(scpname);
+
+          if (cplus_mode != CPLUS_PUBLIC) {
+          /* we 'open' the class at the end, to allow %template
+             to add new members */
+            Node *pa = new_node("access");
+            Setattr(pa, "kind", "public");
+            cplus_mode = CPLUS_PUBLIC;
+            appendChild((yyval.node), pa);
+            Delete(pa);
+          }
+          if (currentOuterClass)
+            restore_access_mode((yyval.node));
+          Setattr((yyval.node), "symtab", Swig_symbol_popscope());
+          Classprefix = Getattr((yyval.node), "Classprefix");
+          Delattr((yyval.node), "Classprefix");
+          Delete(Namespaceprefix);
+          Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+          if (cplus_mode == CPLUS_PRIVATE) {
+            (yyval.node) = 0; /* skip private nested classes */
+          } else if (cparse_cplusplus && currentOuterClass && ignore_nested_classes && !GetFlag((yyval.node), "feature:flatnested")) {
+            (yyval.node) = nested_forward_declaration((yyvsp[(1) - (9)].id), (yyvsp[(2) - (9)].id), (yyvsp[(3) - (9)].str), Copy((yyvsp[(3) - (9)].str)), (yyvsp[(9) - (9)].node));
+          } else if (nscope_inner) {
+            /* this is tricky */
+            /* we add the declaration in the original namespace */
+            if (Strcmp(nodeType(nscope_inner), "class") == 0 && cparse_cplusplus && ignore_nested_classes && !GetFlag((yyval.node), "feature:flatnested"))
+              (yyval.node) = nested_forward_declaration((yyvsp[(1) - (9)].id), (yyvsp[(2) - (9)].id), (yyvsp[(3) - (9)].str), Copy((yyvsp[(3) - (9)].str)), (yyvsp[(9) - (9)].node));
+            appendChild(nscope_inner, (yyval.node));
+            Swig_symbol_setscope(Getattr(nscope_inner, "symtab"));
+            Delete(Namespaceprefix);
+            Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+            yyrename = Copy(Getattr((yyval.node), "class_rename"));
+            add_symbols((yyval.node));
+            Delattr((yyval.node), "class_rename");
+            /* but the variable definition in the current scope */
+            Swig_symbol_setscope(cscope);
+            Delete(Namespaceprefix);
+            Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+            add_symbols((yyvsp[(9) - (9)].node));
+            if (nscope) {
+              (yyval.node) = nscope; /* here we return recreated namespace tower instead of the class itself */
+              if ((yyvsp[(9) - (9)].node)) {
+            appendSibling((yyval.node), (yyvsp[(9) - (9)].node));
+              }
+            } else if (!SwigType_istemplate(ty) && template_parameters == 0) { /* for template we need the class itself */
+              (yyval.node) = (yyvsp[(9) - (9)].node);
+            }
+          } else {
+            Delete(yyrename);
+            yyrename = 0;
+            if (!cparse_cplusplus && currentOuterClass) { /* nested C structs go into global scope*/
+              Node *outer = currentOuterClass;
+              while (Getattr(outer, "nested:outer"))
+            outer = Getattr(outer, "nested:outer");
+              appendSibling(outer, (yyval.node));
+              Swig_symbol_setscope(cscope); /* declaration goes in the parent scope */
+              add_symbols((yyvsp[(9) - (9)].node));
+              set_scope_to_global();
+              Delete(Namespaceprefix);
+              Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+              yyrename = Copy(Getattr((yyval.node), "class_rename"));
+              add_symbols((yyval.node));
+              if (!cparse_cplusplusout)
+            Delattr((yyval.node), "nested:outer");
+              Delattr((yyval.node), "class_rename");
+              (yyval.node) = 0;
+            } else {
+              yyrename = Copy(Getattr((yyval.node), "class_rename"));
+              add_symbols((yyval.node));
+              add_symbols((yyvsp[(9) - (9)].node));
+              Delattr((yyval.node), "class_rename");
+            }
+          }
+          Delete(ty);
+          Swig_symbol_setscope(cscope);
+          Delete(Namespaceprefix);
+          Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+          Classprefix = currentOuterClass ? Getattr(currentOuterClass, "Classprefix") : 0;
+          ;}
+    break;
+
+  case 163:
+#line 3920 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          String *unnamed;
+          String *code;
+          unnamed = make_unnamed();
+          (yyval.node) = new_node("class");
+          Setline((yyval.node),cparse_start_line);
+          Setattr((yyval.node),"kind",(yyvsp[(2) - (4)].id));
+          if ((yyvsp[(3) - (4)].bases)) {
+        Setattr((yyval.node),"baselist", Getattr((yyvsp[(3) - (4)].bases),"public"));
+        Setattr((yyval.node),"protectedbaselist", Getattr((yyvsp[(3) - (4)].bases),"protected"));
+        Setattr((yyval.node),"privatebaselist", Getattr((yyvsp[(3) - (4)].bases),"private"));
+          }
+          Setattr((yyval.node),"storage",(yyvsp[(1) - (4)].id));
+          Setattr((yyval.node),"unnamed",unnamed);
+          Setattr((yyval.node),"allows_typedef","1");
+          if (currentOuterClass) {
+        SetFlag((yyval.node), "nested");
+        Setattr((yyval.node), "nested:outer", currentOuterClass);
+        set_access_mode((yyval.node));
+          }
+          Swig_features_get(Swig_cparse_features(), Namespaceprefix, 0, 0, (yyval.node));
+          /* save yyrename to the class attribute, to be used later in add_symbols()*/
+          Setattr((yyval.node), "class_rename", make_name((yyval.node),0,0));
+          if (strcmp((yyvsp[(2) - (4)].id),"class") == 0) {
+        cplus_mode = CPLUS_PRIVATE;
+          } else {
+        cplus_mode = CPLUS_PUBLIC;
+          }
+          Swig_symbol_newscope();
+          cparse_start_line = cparse_line;
+          currentOuterClass = (yyval.node);
+          inclass = 1;
+          Classprefix = 0;
+          Delete(Namespaceprefix);
+          Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+          /* save the structure declaration to make a typedef for it later*/
+          code = get_raw_text_balanced('{', '}');
+          Setattr((yyval.node), "code", code);
+          Delete(code);
+        ;}
+    break;
+
+  case 164:
+#line 3959 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          String *unnamed;
+               List *bases = 0;
+          String *name = 0;
+          Node *n;
+          Classprefix = 0;
+          (void)(yyvsp[(5) - (8)].node);
+          (yyval.node) = currentOuterClass;
+          currentOuterClass = Getattr((yyval.node), "nested:outer");
+          if (!currentOuterClass)
+        inclass = 0;
+          else
+        restore_access_mode((yyval.node));
+          unnamed = Getattr((yyval.node),"unnamed");
+               /* Check for pure-abstract class */
+          Setattr((yyval.node),"abstracts", pure_abstracts((yyvsp[(6) - (8)].node)));
+          n = (yyvsp[(8) - (8)].node);
+          if (cparse_cplusplus && currentOuterClass && ignore_nested_classes && !GetFlag((yyval.node), "feature:flatnested")) {
+        String *name = n ? Copy(Getattr(n, "name")) : 0;
+        (yyval.node) = nested_forward_declaration((yyvsp[(1) - (8)].id), (yyvsp[(2) - (8)].id), 0, name, n);
+        Swig_symbol_popscope();
+            Delete(Namespaceprefix);
+        Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+          } else if (n) {
+            appendSibling((yyval.node),n);
+        /* If a proper typedef name was given, we'll use it to set the scope name */
+        name = try_to_find_a_name_for_unnamed_structure((yyvsp[(1) - (8)].id), n);
+        if (name) {
+          String *scpname = 0;
+          SwigType *ty;
+          Setattr((yyval.node),"tdname",name);
+          Setattr((yyval.node),"name",name);
+          Swig_symbol_setscopename(name);
+          if ((yyvsp[(3) - (8)].bases))
+            bases = Swig_make_inherit_list(name,Getattr((yyvsp[(3) - (8)].bases),"public"),Namespaceprefix);
+          Swig_inherit_base_symbols(bases);
+
+            /* If a proper name was given, we use that as the typedef, not unnamed */
+          Clear(unnamed);
+          Append(unnamed, name);
+          if (cparse_cplusplus && !cparse_externc) {
+            ty = NewString(name);
+          } else {
+            ty = NewStringf("%s %s", (yyvsp[(2) - (8)].id),name);
+          }
+          while (n) {
+            Setattr(n,"storage",(yyvsp[(1) - (8)].id));
+            Setattr(n, "type", ty);
+            if (!cparse_cplusplus && currentOuterClass && (!Getattr(currentOuterClass, "name"))) {
+              SetFlag(n,"hasconsttype");
+              SetFlag(n,"feature:immutable");
+            }
+            n = nextSibling(n);
+          }
+          n = (yyvsp[(8) - (8)].node);
+
+          /* Check for previous extensions */
+          {
+            String *clsname = Swig_symbol_qualifiedscopename(0);
+            Node *am = Getattr(Swig_extend_hash(),clsname);
+            if (am) {
+              /* Merge the extension into the symbol table */
+              Swig_extend_merge((yyval.node),am);
+              Swig_extend_append_previous((yyval.node),am);
+              Delattr(Swig_extend_hash(),clsname);
+            }
+            Delete(clsname);
+          }
+          if (!classes) classes = NewHash();
+          scpname = Swig_symbol_qualifiedscopename(0);
+          Setattr(classes,scpname,(yyval.node));
+          Delete(scpname);
+        } else { /* no suitable name was found for a struct */
+          Setattr((yyval.node), "nested:unnamed", Getattr(n, "name")); /* save the name of the first declarator for later use in name generation*/
+          while (n) { /* attach unnamed struct to the declarators, so that they would receive proper type later*/
+            Setattr(n, "nested:unnamedtype", (yyval.node));
+            Setattr(n, "storage", (yyvsp[(1) - (8)].id));
+            n = nextSibling(n);
+          }
+          n = (yyvsp[(8) - (8)].node);
+          Swig_symbol_setscopename("<unnamed>");
+        }
+        appendChild((yyval.node),(yyvsp[(6) - (8)].node));
+        /* Pop the scope */
+        Setattr((yyval.node),"symtab",Swig_symbol_popscope());
+        if (name) {
+          Delete(yyrename);
+          yyrename = Copy(Getattr((yyval.node), "class_rename"));
+          Delete(Namespaceprefix);
+          Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+          add_symbols((yyval.node));
+          add_symbols(n);
+          Delattr((yyval.node), "class_rename");
+        }else if (cparse_cplusplus)
+          (yyval.node) = 0; /* ignore unnamed structs for C++ */
+            Delete(unnamed);
+          } else { /* unnamed struct w/o declarator*/
+        Swig_symbol_popscope();
+            Delete(Namespaceprefix);
+        Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+        add_symbols((yyvsp[(6) - (8)].node));
+        Delete((yyval.node));
+        (yyval.node) = (yyvsp[(6) - (8)].node); /* pass member list to outer class/namespace (instead of self)*/
+          }
+          Classprefix = currentOuterClass ? Getattr(currentOuterClass, "Classprefix") : 0;
+              ;}
+    break;
+
+  case 165:
+#line 4067 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = 0; ;}
+    break;
+
+  case 166:
+#line 4068 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                        (yyval.node) = new_node("cdecl");
+                        Setattr((yyval.node),"name",(yyvsp[(1) - (4)].decl).id);
+                        Setattr((yyval.node),"decl",(yyvsp[(1) - (4)].decl).type);
+                        Setattr((yyval.node),"parms",(yyvsp[(1) - (4)].decl).parms);
+           set_nextSibling((yyval.node), (yyvsp[(4) - (4)].node));
+                    ;}
+    break;
+
+  case 167:
+#line 4080 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+              if ((yyvsp[(1) - (4)].id) && (Strcmp((yyvsp[(1) - (4)].id),"friend") == 0)) {
+       /* Ignore */
+                (yyval.node) = 0;
+         } else {
+       (yyval.node) = new_node("classforward");
+       Setattr((yyval.node),"kind",(yyvsp[(2) - (4)].id));
+       Setattr((yyval.node),"name",(yyvsp[(3) - (4)].str));
+       Setattr((yyval.node),"sym:weak", "1");
+       add_symbols((yyval.node));
+         }
+             ;}
+    break;
+
+  case 168:
+#line 4098 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           if (currentOuterClass)
+             Setattr(currentOuterClass, "template_parameters", template_parameters);
+           template_parameters = (yyvsp[(3) - (4)].tparms);
+           parsing_template_declaration = 1;
+         ;}
+    break;
+
+  case 169:
+#line 4103 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           String *tname = 0;
+           int     error = 0;
+
+           /* check if we get a namespace node with a class declaration, and retrieve the class */
+           Symtab *cscope = Swig_symbol_current();
+           Symtab *sti = 0;
+           Node *ntop = (yyvsp[(6) - (6)].node);
+           Node *ni = ntop;
+           SwigType *ntype = ni ? nodeType(ni) : 0;
+           while (ni && Strcmp(ntype,"namespace") == 0) {
+             sti = Getattr(ni,"symtab");
+             ni = firstChild(ni);
+             ntype = nodeType(ni);
+           }
+           if (sti) {
+             Swig_symbol_setscope(sti);
+             Delete(Namespaceprefix);
+             Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+             (yyvsp[(6) - (6)].node) = ni;
+           }
+
+           (yyval.node) = (yyvsp[(6) - (6)].node);
+           if ((yyval.node)) tname = Getattr((yyval.node),"name");
+
+           /* Check if the class is a template specialization */
+           if (((yyval.node)) && (Strchr(tname,'<')) && (!is_operator(tname))) {
+             /* If a specialization.  Check if defined. */
+             Node *tempn = 0;
+             {
+               String *tbase = SwigType_templateprefix(tname);
+               tempn = Swig_symbol_clookup_local(tbase,0);
+               if (!tempn || (Strcmp(nodeType(tempn),"template") != 0)) {
+                 SWIG_WARN_NODE_BEGIN(tempn);
+                 Swig_warning(WARN_PARSE_TEMPLATE_SP_UNDEF, Getfile((yyval.node)),Getline((yyval.node)),"Specialization of non-template '%s'.\n", tbase);
+                 SWIG_WARN_NODE_END(tempn);
+                 tempn = 0;
+                 error = 1;
+               }
+               Delete(tbase);
+             }
+             Setattr((yyval.node),"specialization","1");
+             Setattr((yyval.node),"templatetype",nodeType((yyval.node)));
+             set_nodeType((yyval.node),"template");
+             /* Template partial specialization */
+             if (tempn && ((yyvsp[(3) - (6)].tparms)) && ((yyvsp[(6) - (6)].node))) {
+               List   *tlist;
+               String *targs = SwigType_templateargs(tname);
+               tlist = SwigType_parmlist(targs);
+               /*            Printf(stdout,"targs = '%s' %s\n", targs, tlist); */
+               if (!Getattr((yyval.node),"sym:weak")) {
+                 Setattr((yyval.node),"sym:typename","1");
+               }
+
+               if (Len(tlist) != ParmList_len(Getattr(tempn,"templateparms"))) {
+                 Swig_error(Getfile((yyval.node)),Getline((yyval.node)),"Inconsistent argument count in template partial specialization. %d %d\n", Len(tlist), ParmList_len(Getattr(tempn,"templateparms")));
+
+               } else {
+
+               /* This code builds the argument list for the partial template
+                  specialization.  This is a little hairy, but the idea is as
+                  follows:
+
+                  $3 contains a list of arguments supplied for the template.
+                  For example template<class T>.
+
+                  tlist is a list of the specialization arguments--which may be
+                  different.  For example class<int,T>.
+
+                  tp is a copy of the arguments in the original template definition.
+
+                  The patching algorithm walks through the list of supplied
+                  arguments ($3), finds the position in the specialization arguments
+                  (tlist), and then patches the name in the argument list of the
+                  original template.
+               */
+
+               {
+                 String *pn;
+                 Parm *p, *p1;
+                 int i, nargs;
+                 Parm *tp = CopyParmList(Getattr(tempn,"templateparms"));
+                 nargs = Len(tlist);
+                 p = (yyvsp[(3) - (6)].tparms);
+                 while (p) {
+               for (i = 0; i < nargs; i++){
+                 pn = Getattr(p,"name");
+                 if (Strcmp(pn,SwigType_base(Getitem(tlist,i))) == 0) {
+                   int j;
+                   Parm *p1 = tp;
+                   for (j = 0; j < i; j++) {
+                     p1 = nextSibling(p1);
+                   }
+                   Setattr(p1,"name",pn);
+                   Setattr(p1,"partialarg","1");
+                 }
+               }
+               p = nextSibling(p);
+                 }
+                 p1 = tp;
+                 i = 0;
+                 while (p1) {
+               if (!Getattr(p1,"partialarg")) {
+                 Delattr(p1,"name");
+                 Setattr(p1,"type", Getitem(tlist,i));
+               }
+               i++;
+               p1 = nextSibling(p1);
+                 }
+                 Setattr((yyval.node),"templateparms",tp);
+                 Delete(tp);
+               }
+  #if 0
+               /* Patch the parameter list */
+               if (tempn) {
+                 Parm *p,*p1;
+                 ParmList *tp = CopyParmList(Getattr(tempn,"templateparms"));
+                 p = (yyvsp[(3) - (6)].tparms);
+                 p1 = tp;
+                 while (p && p1) {
+               String *pn = Getattr(p,"name");
+               Printf(stdout,"pn = '%s'\n", pn);
+               if (pn) Setattr(p1,"name",pn);
+               else Delattr(p1,"name");
+               pn = Getattr(p,"type");
+               if (pn) Setattr(p1,"type",pn);
+               p = nextSibling(p);
+               p1 = nextSibling(p1);
+                 }
+                 Setattr((yyval.node),"templateparms",tp);
+                 Delete(tp);
+               } else {
+                 Setattr((yyval.node),"templateparms",(yyvsp[(3) - (6)].tparms));
+               }
+  #endif
+               Delattr((yyval.node),"specialization");
+               Setattr((yyval.node),"partialspecialization","1");
+               /* Create a specialized name for matching */
+               {
+                 Parm *p = (yyvsp[(3) - (6)].tparms);
+                 String *fname = NewString(Getattr((yyval.node),"name"));
+                 String *ffname = 0;
+                 ParmList *partialparms = 0;
+
+                 char   tmp[32];
+                 int    i, ilen;
+                 while (p) {
+               String *n = Getattr(p,"name");
+               if (!n) {
+                 p = nextSibling(p);
+                 continue;
+               }
+               ilen = Len(tlist);
+               for (i = 0; i < ilen; i++) {
+                 if (Strstr(Getitem(tlist,i),n)) {
+                   sprintf(tmp,"$%d",i+1);
+                   Replaceid(fname,n,tmp);
+                 }
+               }
+               p = nextSibling(p);
+                 }
+                 /* Patch argument names with typedef */
+                 {
+               Iterator tt;
+               Parm *parm_current = 0;
+               List *tparms = SwigType_parmlist(fname);
+               ffname = SwigType_templateprefix(fname);
+               Append(ffname,"<(");
+               for (tt = First(tparms); tt.item; ) {
+                 SwigType *rtt = Swig_symbol_typedef_reduce(tt.item,0);
+                 SwigType *ttr = Swig_symbol_type_qualify(rtt,0);
+
+                 Parm *newp = NewParmWithoutFileLineInfo(ttr, 0);
+                 if (partialparms)
+                   set_nextSibling(parm_current, newp);
+                 else
+                   partialparms = newp;
+                 parm_current = newp;
+
+                 Append(ffname,ttr);
+                 tt = Next(tt);
+                 if (tt.item) Putc(',',ffname);
+                 Delete(rtt);
+                 Delete(ttr);
+               }
+               Delete(tparms);
+               Append(ffname,")>");
+                 }
+                 {
+               Node *new_partial = NewHash();
+               String *partials = Getattr(tempn,"partials");
+               if (!partials) {
+                 partials = NewList();
+                 Setattr(tempn,"partials",partials);
+                 Delete(partials);
+               }
+               /*                Printf(stdout,"partial: fname = '%s', '%s'\n", fname, Swig_symbol_typedef_reduce(fname,0)); */
+               Setattr(new_partial, "partialparms", partialparms);
+               Setattr(new_partial, "templcsymname", ffname);
+               Append(partials, new_partial);
+                 }
+                 Setattr((yyval.node),"partialargs",ffname);
+                 Swig_symbol_cadd(ffname,(yyval.node));
+               }
+               }
+               Delete(tlist);
+               Delete(targs);
+             } else {
+               /* An explicit template specialization */
+               /* add default args from primary (unspecialized) template */
+               String *ty = Swig_symbol_template_deftype(tname,0);
+               String *fname = Swig_symbol_type_qualify(ty,0);
+               Swig_symbol_cadd(fname,(yyval.node));
+               Delete(ty);
+               Delete(fname);
+             }
+           }  else if ((yyval.node)) {
+             Setattr((yyval.node),"templatetype",nodeType((yyvsp[(6) - (6)].node)));
+             set_nodeType((yyval.node),"template");
+             Setattr((yyval.node),"templateparms", (yyvsp[(3) - (6)].tparms));
+             if (!Getattr((yyval.node),"sym:weak")) {
+               Setattr((yyval.node),"sym:typename","1");
+             }
+             add_symbols((yyval.node));
+             default_arguments((yyval.node));
+             /* We also place a fully parameterized version in the symbol table */
+             {
+               Parm *p;
+               String *fname = NewStringf("%s<(", Getattr((yyval.node),"name"));
+               p = (yyvsp[(3) - (6)].tparms);
+               while (p) {
+                 String *n = Getattr(p,"name");
+                 if (!n) n = Getattr(p,"type");
+                 Append(fname,n);
+                 p = nextSibling(p);
+                 if (p) Putc(',',fname);
+               }
+               Append(fname,")>");
+               Swig_symbol_cadd(fname,(yyval.node));
+             }
+           }
+           (yyval.node) = ntop;
+           Swig_symbol_setscope(cscope);
+           Delete(Namespaceprefix);
+           Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+           if (error || (nscope_inner && Strcmp(nodeType(nscope_inner), "class") == 0)) {
+             (yyval.node) = 0;
+           }
+           if (currentOuterClass)
+             template_parameters = Getattr(currentOuterClass, "template_parameters");
+           else
+             template_parameters = 0;
+           parsing_template_declaration = 0;
+                ;}
+    break;
+
+  case 170:
+#line 4359 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         Swig_warning(WARN_PARSE_EXPLICIT_TEMPLATE, cparse_file, cparse_line, "Explicit template instantiation ignored.\n");
+                  (yyval.node) = 0;
+       ;}
+    break;
+
+  case 171:
+#line 4365 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         Swig_warning(WARN_PARSE_EXPLICIT_TEMPLATE, cparse_file, cparse_line, "Explicit template instantiation ignored.\n");
+                  (yyval.node) = 0;
+                ;}
+    break;
+
+  case 172:
+#line 4371 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.node) = (yyvsp[(1) - (1)].node);
+                ;}
+    break;
+
+  case 173:
+#line 4374 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.node) = (yyvsp[(1) - (1)].node);
+                ;}
+    break;
+
+  case 174:
+#line 4377 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.node) = (yyvsp[(1) - (1)].node);
+                ;}
+    break;
+
+  case 175:
+#line 4380 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.node) = 0;
+                ;}
+    break;
+
+  case 176:
+#line 4383 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                  (yyval.node) = (yyvsp[(1) - (1)].node);
+                ;}
+    break;
+
+  case 177:
+#line 4386 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                  (yyval.node) = (yyvsp[(1) - (1)].node);
+                ;}
+    break;
+
+  case 178:
+#line 4391 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          /* Rip out the parameter names */
+         Parm *p = (yyvsp[(1) - (1)].pl);
+         (yyval.tparms) = (yyvsp[(1) - (1)].pl);
+
+         while (p) {
+           String *name = Getattr(p,"name");
+           if (!name) {
+             /* Hmmm. Maybe it's a 'class T' parameter */
+             char *type = Char(Getattr(p,"type"));
+             /* Template template parameter */
+             if (strncmp(type,"template<class> ",16) == 0) {
+           type += 16;
+             }
+             if ((strncmp(type,"class ",6) == 0) || (strncmp(type,"typename ", 9) == 0)) {
+           char *t = strchr(type,' ');
+           Setattr(p,"name", t+1);
+             } else
+                      /* Variadic template args */
+             if ((strncmp(type,"class... ",9) == 0) || (strncmp(type,"typename... ", 12) == 0)) {
+           char *t = strchr(type,' ');
+           Setattr(p,"name", t+1);
+           Setattr(p,"variadic", "1");
+             } else {
+           /*
+            Swig_error(cparse_file, cparse_line, "Missing template parameter name\n");
+            $$.rparms = 0;
+            $$.parms = 0;
+            break; */
+             }
+           }
+           p = nextSibling(p);
+         }
+                 ;}
+    break;
+
+  case 179:
+#line 4427 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                      set_nextSibling((yyvsp[(1) - (2)].p),(yyvsp[(2) - (2)].pl));
+                      (yyval.pl) = (yyvsp[(1) - (2)].p);
+                   ;}
+    break;
+
+  case 180:
+#line 4431 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.pl) = 0; ;}
+    break;
+
+  case 181:
+#line 4434 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.p) = NewParmWithoutFileLineInfo(NewString((yyvsp[(1) - (1)].id)), 0);
+                  ;}
+    break;
+
+  case 182:
+#line 4437 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.p) = (yyvsp[(1) - (1)].p);
+                  ;}
+    break;
+
+  case 183:
+#line 4442 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                         set_nextSibling((yyvsp[(2) - (3)].p),(yyvsp[(3) - (3)].pl));
+                         (yyval.pl) = (yyvsp[(2) - (3)].p);
+                       ;}
+    break;
+
+  case 184:
+#line 4446 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.pl) = 0; ;}
+    break;
+
+  case 185:
+#line 4451 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                  String *uname = Swig_symbol_type_qualify((yyvsp[(2) - (3)].str),0);
+         String *name = Swig_scopename_last((yyvsp[(2) - (3)].str));
+                  (yyval.node) = new_node("using");
+         Setattr((yyval.node),"uname",uname);
+         Setattr((yyval.node),"name", name);
+         Delete(uname);
+         Delete(name);
+         add_symbols((yyval.node));
+             ;}
+    break;
+
+  case 186:
+#line 4461 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          Node *n = Swig_symbol_clookup((yyvsp[(3) - (4)].str),0);
+          if (!n) {
+        Swig_error(cparse_file, cparse_line, "Nothing known about namespace '%s'\n", (yyvsp[(3) - (4)].str));
+        (yyval.node) = 0;
+          } else {
+
+        while (Strcmp(nodeType(n),"using") == 0) {
+          n = Getattr(n,"node");
+        }
+        if (n) {
+          if (Strcmp(nodeType(n),"namespace") == 0) {
+            Symtab *current = Swig_symbol_current();
+            Symtab *symtab = Getattr(n,"symtab");
+            (yyval.node) = new_node("using");
+            Setattr((yyval.node),"node",n);
+            Setattr((yyval.node),"namespace", (yyvsp[(3) - (4)].str));
+            if (current != symtab) {
+              Swig_symbol_inherit(symtab);
+            }
+          } else {
+            Swig_error(cparse_file, cparse_line, "'%s' is not a namespace.\n", (yyvsp[(3) - (4)].str));
+            (yyval.node) = 0;
+          }
+        } else {
+          (yyval.node) = 0;
+        }
+          }
+             ;}
+    break;
+
+  case 187:
+#line 4492 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                Hash *h;
+       Node *parent_ns = 0;
+       List *scopes = Swig_scopename_tolist((yyvsp[(2) - (3)].str));
+       int ilen = Len(scopes);
+       int i;
+
+/*
+Printf(stdout, "==== Namespace %s creation...\n", $2);
+*/
+       (yyval.node) = 0;
+       for (i = 0; i < ilen; i++) {
+         Node *ns = new_node("namespace");
+         Symtab *current_symtab = Swig_symbol_current();
+         String *scopename = Getitem(scopes, i);
+         Setattr(ns, "name", scopename);
+         (yyval.node) = ns;
+         if (parent_ns)
+           appendChild(parent_ns, ns);
+         parent_ns = ns;
+         h = Swig_symbol_clookup(scopename, 0);
+         if (h && (current_symtab == Getattr(h, "sym:symtab")) && (Strcmp(nodeType(h), "namespace") == 0)) {
+/*
+Printf(stdout, "  Scope %s [found C++17 style]\n", scopename);
+*/
+           if (Getattr(h, "alias")) {
+             h = Getattr(h, "namespace");
+             Swig_warning(WARN_PARSE_NAMESPACE_ALIAS, cparse_file, cparse_line, "Namespace alias '%s' not allowed here. Assuming '%s'\n",
+                  scopename, Getattr(h, "name"));
+             scopename = Getattr(h, "name");
+           }
+           Swig_symbol_setscope(Getattr(h, "symtab"));
+         } else {
+/*
+Printf(stdout, "  Scope %s [creating single scope C++17 style]\n", scopename);
+*/
+           h = Swig_symbol_newscope();
+           Swig_symbol_setscopename(scopename);
+         }
+         Delete(Namespaceprefix);
+         Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+       }
+       Delete(scopes);
+             ;}
+    break;
+
+  case 188:
+#line 4535 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+       Node *n = (yyvsp[(4) - (6)].node);
+       Node *top_ns = 0;
+       do {
+         Setattr(n, "symtab", Swig_symbol_popscope());
+         Delete(Namespaceprefix);
+         Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+         add_symbols(n);
+         top_ns = n;
+         n = parentNode(n);
+       } while(n);
+       appendChild((yyvsp[(4) - (6)].node), firstChild((yyvsp[(5) - (6)].node)));
+       Delete((yyvsp[(5) - (6)].node));
+       (yyval.node) = top_ns;
+             ;}
+    break;
+
+  case 189:
+#line 4550 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          Hash *h;
+          (yyvsp[(1) - (2)].node) = Swig_symbol_current();
+          h = Swig_symbol_clookup("    ",0);
+          if (h && (Strcmp(nodeType(h),"namespace") == 0)) {
+        Swig_symbol_setscope(Getattr(h,"symtab"));
+          } else {
+        Swig_symbol_newscope();
+        /* we don't use "__unnamed__", but a long 'empty' name */
+        Swig_symbol_setscopename("    ");
+          }
+          Namespaceprefix = 0;
+             ;}
+    break;
+
+  case 190:
+#line 4562 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          (yyval.node) = (yyvsp[(4) - (5)].node);
+          set_nodeType((yyval.node),"namespace");
+          Setattr((yyval.node),"unnamed","1");
+          Setattr((yyval.node),"symtab", Swig_symbol_popscope());
+          Swig_symbol_setscope((yyvsp[(1) - (5)].node));
+          Delete(Namespaceprefix);
+          Namespaceprefix = Swig_symbol_qualifiedscopename(0);
+          add_symbols((yyval.node));
+             ;}
+    break;
+
+  case 191:
+#line 4572 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          /* Namespace alias */
+          Node *n;
+          (yyval.node) = new_node("namespace");
+          Setattr((yyval.node),"name",(yyvsp[(2) - (5)].id));
+          Setattr((yyval.node),"alias",(yyvsp[(4) - (5)].str));
+          n = Swig_symbol_clookup((yyvsp[(4) - (5)].str),0);
+          if (!n) {
+        Swig_error(cparse_file, cparse_line, "Unknown namespace '%s'\n", (yyvsp[(4) - (5)].str));
+        (yyval.node) = 0;
+          } else {
+        if (Strcmp(nodeType(n),"namespace") != 0) {
+          Swig_error(cparse_file, cparse_line, "'%s' is not a namespace\n",(yyvsp[(4) - (5)].str));
+          (yyval.node) = 0;
+        } else {
+          while (Getattr(n,"alias")) {
+            n = Getattr(n,"namespace");
+          }
+          Setattr((yyval.node),"namespace",n);
+          add_symbols((yyval.node));
+          /* Set up a scope alias */
+          Swig_symbol_alias((yyvsp[(2) - (5)].id),Getattr(n,"symtab"));
+        }
+          }
+             ;}
+    break;
+
+  case 192:
+#line 4599 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.node) = (yyvsp[(1) - (2)].node);
+                   /* Insert cpp_member (including any siblings) to the front of the cpp_members linked list */
+          if ((yyval.node)) {
+            Node *p = (yyval.node);
+            Node *pp =0;
+            while (p) {
+              pp = p;
+              p = nextSibling(p);
+            }
+            set_nextSibling(pp,(yyvsp[(2) - (2)].node));
+            if ((yyvsp[(2) - (2)].node))
+              set_previousSibling((yyvsp[(2) - (2)].node), pp);
+          } else {
+            (yyval.node) = (yyvsp[(2) - (2)].node);
+          }
+             ;}
+    break;
+
+  case 193:
+#line 4616 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          extendmode = 1;
+          if (cplus_mode != CPLUS_PUBLIC) {
+        Swig_error(cparse_file,cparse_line,"%%extend can only be used in a public section\n");
+          }
+             ;}
+    break;
+
+  case 194:
+#line 4621 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          extendmode = 0;
+        ;}
+    break;
+
+  case 195:
+#line 4623 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          (yyval.node) = new_node("extend");
+          mark_nodes_as_extend((yyvsp[(4) - (7)].node));
+          appendChild((yyval.node),(yyvsp[(4) - (7)].node));
+          set_nextSibling((yyval.node),(yyvsp[(7) - (7)].node));
+        ;}
+    break;
+
+  case 196:
+#line 4629 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 197:
+#line 4630 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = 0;;}
+    break;
+
+  case 198:
+#line 4631 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          int start_line = cparse_line;
+          skip_decl();
+          Swig_error(cparse_file,start_line,"Syntax error in input(3).\n");
+          exit(1);
+          ;}
+    break;
+
+  case 199:
+#line 4636 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.node) = (yyvsp[(3) - (3)].node);
+            ;}
+    break;
+
+  case 200:
+#line 4647 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 201:
+#line 4648 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.node) = (yyvsp[(1) - (1)].node);
+        if (extendmode && current_class) {
+          String *symname;
+          symname= make_name((yyval.node),Getattr((yyval.node),"name"), Getattr((yyval.node),"decl"));
+          if (Strcmp(symname,Getattr((yyval.node),"name")) == 0) {
+            /* No renaming operation.  Set name to class name */
+            Delete(yyrename);
+            yyrename = NewString(Getattr(current_class,"sym:name"));
+          } else {
+            Delete(yyrename);
+            yyrename = symname;
+          }
+        }
+        add_symbols((yyval.node));
+                 default_arguments((yyval.node));
+             ;}
+    break;
+
+  case 202:
+#line 4665 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 203:
+#line 4666 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 204:
+#line 4667 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 205:
+#line 4668 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 206:
+#line 4669 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 207:
+#line 4670 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 208:
+#line 4671 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = 0; ;}
+    break;
+
+  case 209:
+#line 4672 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 210:
+#line 4673 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 211:
+#line 4674 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = 0; ;}
+    break;
+
+  case 212:
+#line 4675 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 213:
+#line 4676 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 214:
+#line 4677 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = 0; ;}
+    break;
+
+  case 215:
+#line 4678 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {(yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 216:
+#line 4679 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {(yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 217:
+#line 4680 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = 0; ;}
+    break;
+
+  case 218:
+#line 4682 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+       (yyval.node) = (yyvsp[(1) - (1)].node);
+        ;}
+    break;
+
+  case 219:
+#line 4685 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+            (yyval.node) = (yyvsp[(2) - (2)].node);
+        set_comment((yyvsp[(2) - (2)].node), (yyvsp[(1) - (2)].str));
+        ;}
+    break;
+
+  case 220:
+#line 4689 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+            (yyval.node) = (yyvsp[(1) - (2)].node);
+        set_comment((yyvsp[(1) - (2)].node), (yyvsp[(2) - (2)].str));
+        ;}
+    break;
+
+  case 221:
+#line 4701 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+              if (inclass || extendmode) {
+       SwigType *decl = NewStringEmpty();
+       (yyval.node) = new_node("constructor");
+       Setattr((yyval.node),"storage",(yyvsp[(1) - (6)].id));
+       Setattr((yyval.node),"name",(yyvsp[(2) - (6)].type));
+       Setattr((yyval.node),"parms",(yyvsp[(4) - (6)].pl));
+       SwigType_add_function(decl,(yyvsp[(4) - (6)].pl));
+       Setattr((yyval.node),"decl",decl);
+       Setattr((yyval.node),"throws",(yyvsp[(6) - (6)].decl).throws);
+       Setattr((yyval.node),"throw",(yyvsp[(6) - (6)].decl).throwf);
+       Setattr((yyval.node),"noexcept",(yyvsp[(6) - (6)].decl).nexcept);
+       Setattr((yyval.node),"final",(yyvsp[(6) - (6)].decl).final);
+       if (Len(scanner_ccode)) {
+         String *code = Copy(scanner_ccode);
+         Setattr((yyval.node),"code",code);
+         Delete(code);
+       }
+       SetFlag((yyval.node),"feature:new");
+       if ((yyvsp[(6) - (6)].decl).defarg)
+         Setattr((yyval.node),"value",(yyvsp[(6) - (6)].decl).defarg);
+         } else {
+       (yyval.node) = 0;
+              }
+              ;}
+    break;
+
+  case 222:
+#line 4730 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+               String *name = NewStringf("%s",(yyvsp[(2) - (6)].str));
+          if (*(Char(name)) != '~') Insert(name,0,"~");
+               (yyval.node) = new_node("destructor");
+          Setattr((yyval.node),"name",name);
+          Delete(name);
+          if (Len(scanner_ccode)) {
+        String *code = Copy(scanner_ccode);
+        Setattr((yyval.node),"code",code);
+        Delete(code);
+          }
+          {
+        String *decl = NewStringEmpty();
+        SwigType_add_function(decl,(yyvsp[(4) - (6)].pl));
+        Setattr((yyval.node),"decl",decl);
+        Delete(decl);
+          }
+          Setattr((yyval.node),"throws",(yyvsp[(6) - (6)].dtype).throws);
+          Setattr((yyval.node),"throw",(yyvsp[(6) - (6)].dtype).throwf);
+          Setattr((yyval.node),"noexcept",(yyvsp[(6) - (6)].dtype).nexcept);
+          Setattr((yyval.node),"final",(yyvsp[(6) - (6)].dtype).final);
+          if ((yyvsp[(6) - (6)].dtype).val)
+            Setattr((yyval.node),"value",(yyvsp[(6) - (6)].dtype).val);
+          if ((yyvsp[(6) - (6)].dtype).qualifier)
+        Swig_error(cparse_file, cparse_line, "Destructor %s %s cannot have a qualifier.\n", Swig_name_decl((yyval.node)), SwigType_str((yyvsp[(6) - (6)].dtype).qualifier, 0));
+          add_symbols((yyval.node));
+         ;}
+    break;
+
+  case 223:
+#line 4760 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+       String *name;
+       (yyval.node) = new_node("destructor");
+       Setattr((yyval.node),"storage","virtual");
+           name = NewStringf("%s",(yyvsp[(3) - (7)].str));
+       if (*(Char(name)) != '~') Insert(name,0,"~");
+       Setattr((yyval.node),"name",name);
+       Delete(name);
+       Setattr((yyval.node),"throws",(yyvsp[(7) - (7)].dtype).throws);
+       Setattr((yyval.node),"throw",(yyvsp[(7) - (7)].dtype).throwf);
+       Setattr((yyval.node),"noexcept",(yyvsp[(7) - (7)].dtype).nexcept);
+       Setattr((yyval.node),"final",(yyvsp[(7) - (7)].dtype).final);
+       if ((yyvsp[(7) - (7)].dtype).val)
+         Setattr((yyval.node),"value",(yyvsp[(7) - (7)].dtype).val);
+       if (Len(scanner_ccode)) {
+         String *code = Copy(scanner_ccode);
+         Setattr((yyval.node),"code",code);
+         Delete(code);
+       }
+       {
+         String *decl = NewStringEmpty();
+         SwigType_add_function(decl,(yyvsp[(5) - (7)].pl));
+         Setattr((yyval.node),"decl",decl);
+         Delete(decl);
+       }
+       if ((yyvsp[(7) - (7)].dtype).qualifier)
+         Swig_error(cparse_file, cparse_line, "Destructor %s %s cannot have a qualifier.\n", Swig_name_decl((yyval.node)), SwigType_str((yyvsp[(7) - (7)].dtype).qualifier, 0));
+       add_symbols((yyval.node));
+         ;}
+    break;
+
+  case 224:
+#line 4793 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.node) = new_node("cdecl");
+                 Setattr((yyval.node),"type",(yyvsp[(3) - (8)].type));
+        Setattr((yyval.node),"name",(yyvsp[(2) - (8)].str));
+        Setattr((yyval.node),"storage",(yyvsp[(1) - (8)].id));
+
+        SwigType_add_function((yyvsp[(4) - (8)].type),(yyvsp[(6) - (8)].pl));
+        if ((yyvsp[(8) - (8)].dtype).qualifier) {
+          SwigType_push((yyvsp[(4) - (8)].type),(yyvsp[(8) - (8)].dtype).qualifier);
+        }
+        Setattr((yyval.node),"refqualifier",(yyvsp[(8) - (8)].dtype).refqualifier);
+        Setattr((yyval.node),"decl",(yyvsp[(4) - (8)].type));
+        Setattr((yyval.node),"parms",(yyvsp[(6) - (8)].pl));
+        Setattr((yyval.node),"conversion_operator","1");
+        add_symbols((yyval.node));
+              ;}
+    break;
+
+  case 225:
+#line 4809 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        SwigType *decl;
+                 (yyval.node) = new_node("cdecl");
+                 Setattr((yyval.node),"type",(yyvsp[(3) - (8)].type));
+        Setattr((yyval.node),"name",(yyvsp[(2) - (8)].str));
+        Setattr((yyval.node),"storage",(yyvsp[(1) - (8)].id));
+        decl = NewStringEmpty();
+        SwigType_add_reference(decl);
+        SwigType_add_function(decl,(yyvsp[(6) - (8)].pl));
+        if ((yyvsp[(8) - (8)].dtype).qualifier) {
+          SwigType_push(decl,(yyvsp[(8) - (8)].dtype).qualifier);
+        }
+        Setattr((yyval.node),"refqualifier",(yyvsp[(8) - (8)].dtype).refqualifier);
+        Setattr((yyval.node),"decl",decl);
+        Setattr((yyval.node),"parms",(yyvsp[(6) - (8)].pl));
+        Setattr((yyval.node),"conversion_operator","1");
+        add_symbols((yyval.node));
+          ;}
+    break;
+
+  case 226:
+#line 4827 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        SwigType *decl;
+                 (yyval.node) = new_node("cdecl");
+                 Setattr((yyval.node),"type",(yyvsp[(3) - (8)].type));
+        Setattr((yyval.node),"name",(yyvsp[(2) - (8)].str));
+        Setattr((yyval.node),"storage",(yyvsp[(1) - (8)].id));
+        decl = NewStringEmpty();
+        SwigType_add_rvalue_reference(decl);
+        SwigType_add_function(decl,(yyvsp[(6) - (8)].pl));
+        if ((yyvsp[(8) - (8)].dtype).qualifier) {
+          SwigType_push(decl,(yyvsp[(8) - (8)].dtype).qualifier);
+        }
+        Setattr((yyval.node),"refqualifier",(yyvsp[(8) - (8)].dtype).refqualifier);
+        Setattr((yyval.node),"decl",decl);
+        Setattr((yyval.node),"parms",(yyvsp[(6) - (8)].pl));
+        Setattr((yyval.node),"conversion_operator","1");
+        add_symbols((yyval.node));
+          ;}
+    break;
+
+  case 227:
+#line 4846 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        SwigType *decl;
+                 (yyval.node) = new_node("cdecl");
+                 Setattr((yyval.node),"type",(yyvsp[(3) - (9)].type));
+        Setattr((yyval.node),"name",(yyvsp[(2) - (9)].str));
+        Setattr((yyval.node),"storage",(yyvsp[(1) - (9)].id));
+        decl = NewStringEmpty();
+        SwigType_add_pointer(decl);
+        SwigType_add_reference(decl);
+        SwigType_add_function(decl,(yyvsp[(7) - (9)].pl));
+        if ((yyvsp[(9) - (9)].dtype).qualifier) {
+          SwigType_push(decl,(yyvsp[(9) - (9)].dtype).qualifier);
+        }
+        Setattr((yyval.node),"refqualifier",(yyvsp[(9) - (9)].dtype).refqualifier);
+        Setattr((yyval.node),"decl",decl);
+        Setattr((yyval.node),"parms",(yyvsp[(7) - (9)].pl));
+        Setattr((yyval.node),"conversion_operator","1");
+        add_symbols((yyval.node));
+          ;}
+    break;
+
+  case 228:
+#line 4866 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+       String *t = NewStringEmpty();
+       (yyval.node) = new_node("cdecl");
+       Setattr((yyval.node),"type",(yyvsp[(3) - (7)].type));
+       Setattr((yyval.node),"name",(yyvsp[(2) - (7)].str));
+        Setattr((yyval.node),"storage",(yyvsp[(1) - (7)].id));
+       SwigType_add_function(t,(yyvsp[(5) - (7)].pl));
+       if ((yyvsp[(7) - (7)].dtype).qualifier) {
+         SwigType_push(t,(yyvsp[(7) - (7)].dtype).qualifier);
+       }
+        Setattr((yyval.node),"refqualifier",(yyvsp[(7) - (7)].dtype).refqualifier);
+       Setattr((yyval.node),"decl",t);
+       Setattr((yyval.node),"parms",(yyvsp[(5) - (7)].pl));
+       Setattr((yyval.node),"conversion_operator","1");
+       add_symbols((yyval.node));
+              ;}
+    break;
+
+  case 229:
+#line 4886 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 skip_balanced('{','}');
+                 (yyval.node) = 0;
+               ;}
+    break;
+
+  case 230:
+#line 4894 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                skip_balanced('(',')');
+                (yyval.node) = 0;
+              ;}
+    break;
+
+  case 231:
+#line 4901 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                (yyval.node) = new_node("access");
+       Setattr((yyval.node),"kind","public");
+                cplus_mode = CPLUS_PUBLIC;
+              ;}
+    break;
+
+  case 232:
+#line 4908 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                (yyval.node) = new_node("access");
+                Setattr((yyval.node),"kind","private");
+       cplus_mode = CPLUS_PRIVATE;
+         ;}
+    break;
+
+  case 233:
+#line 4916 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+       (yyval.node) = new_node("access");
+       Setattr((yyval.node),"kind","protected");
+       cplus_mode = CPLUS_PROTECTED;
+         ;}
+    break;
+
+  case 234:
+#line 4924 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 235:
+#line 4927 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 236:
+#line 4931 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 237:
+#line 4934 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 238:
+#line 4935 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 239:
+#line 4936 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 240:
+#line 4937 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 241:
+#line 4938 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 242:
+#line 4939 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 243:
+#line 4940 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 244:
+#line 4941 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = (yyvsp[(1) - (1)].node); ;}
+    break;
+
+  case 245:
+#line 4944 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+               Clear(scanner_ccode);
+           (yyval.dtype).val = 0;
+           (yyval.dtype).qualifier = (yyvsp[(1) - (2)].dtype).qualifier;
+           (yyval.dtype).refqualifier = (yyvsp[(1) - (2)].dtype).refqualifier;
+           (yyval.dtype).bitfield = 0;
+           (yyval.dtype).throws = (yyvsp[(1) - (2)].dtype).throws;
+           (yyval.dtype).throwf = (yyvsp[(1) - (2)].dtype).throwf;
+           (yyval.dtype).nexcept = (yyvsp[(1) - (2)].dtype).nexcept;
+           (yyval.dtype).final = (yyvsp[(1) - (2)].dtype).final;
+               ;}
+    break;
+
+  case 246:
+#line 4955 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+               Clear(scanner_ccode);
+           (yyval.dtype).val = (yyvsp[(3) - (4)].dtype).val;
+           (yyval.dtype).qualifier = (yyvsp[(1) - (4)].dtype).qualifier;
+           (yyval.dtype).refqualifier = (yyvsp[(1) - (4)].dtype).refqualifier;
+           (yyval.dtype).bitfield = 0;
+           (yyval.dtype).throws = (yyvsp[(1) - (4)].dtype).throws;
+           (yyval.dtype).throwf = (yyvsp[(1) - (4)].dtype).throwf;
+           (yyval.dtype).nexcept = (yyvsp[(1) - (4)].dtype).nexcept;
+           (yyval.dtype).final = (yyvsp[(1) - (4)].dtype).final;
+               ;}
+    break;
+
+  case 247:
+#line 4966 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           skip_balanced('{','}');
+           (yyval.dtype).val = 0;
+           (yyval.dtype).qualifier = (yyvsp[(1) - (2)].dtype).qualifier;
+           (yyval.dtype).refqualifier = (yyvsp[(1) - (2)].dtype).refqualifier;
+           (yyval.dtype).bitfield = 0;
+           (yyval.dtype).throws = (yyvsp[(1) - (2)].dtype).throws;
+           (yyval.dtype).throwf = (yyvsp[(1) - (2)].dtype).throwf;
+           (yyval.dtype).nexcept = (yyvsp[(1) - (2)].dtype).nexcept;
+           (yyval.dtype).final = (yyvsp[(1) - (2)].dtype).final;
+          ;}
+    break;
+
+  case 248:
+#line 4979 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                     Clear(scanner_ccode);
+                     (yyval.dtype).val = 0;
+                     (yyval.dtype).qualifier = (yyvsp[(1) - (2)].dtype).qualifier;
+                     (yyval.dtype).refqualifier = (yyvsp[(1) - (2)].dtype).refqualifier;
+                     (yyval.dtype).bitfield = 0;
+                     (yyval.dtype).throws = (yyvsp[(1) - (2)].dtype).throws;
+                     (yyval.dtype).throwf = (yyvsp[(1) - (2)].dtype).throwf;
+                     (yyval.dtype).nexcept = (yyvsp[(1) - (2)].dtype).nexcept;
+                     (yyval.dtype).final = (yyvsp[(1) - (2)].dtype).final;
+                ;}
+    break;
+
+  case 249:
+#line 4990 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                     Clear(scanner_ccode);
+                     (yyval.dtype).val = (yyvsp[(3) - (4)].dtype).val;
+                     (yyval.dtype).qualifier = (yyvsp[(1) - (4)].dtype).qualifier;
+                     (yyval.dtype).refqualifier = (yyvsp[(1) - (4)].dtype).refqualifier;
+                     (yyval.dtype).bitfield = 0;
+                     (yyval.dtype).throws = (yyvsp[(1) - (4)].dtype).throws;
+                     (yyval.dtype).throwf = (yyvsp[(1) - (4)].dtype).throwf;
+                     (yyval.dtype).nexcept = (yyvsp[(1) - (4)].dtype).nexcept;
+                     (yyval.dtype).final = (yyvsp[(1) - (4)].dtype).final;
+               ;}
+    break;
+
+  case 250:
+#line 5001 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                     skip_balanced('{','}');
+                     (yyval.dtype).val = 0;
+                     (yyval.dtype).qualifier = (yyvsp[(1) - (2)].dtype).qualifier;
+                     (yyval.dtype).refqualifier = (yyvsp[(1) - (2)].dtype).refqualifier;
+                     (yyval.dtype).bitfield = 0;
+                     (yyval.dtype).throws = (yyvsp[(1) - (2)].dtype).throws;
+                     (yyval.dtype).throwf = (yyvsp[(1) - (2)].dtype).throwf;
+                     (yyval.dtype).nexcept = (yyvsp[(1) - (2)].dtype).nexcept;
+                     (yyval.dtype).final = (yyvsp[(1) - (2)].dtype).final;
+               ;}
+    break;
+
+  case 251:
+#line 5015 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { ;}
+    break;
+
+  case 252:
+#line 5018 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.type) = (yyvsp[(1) - (1)].type);
+                  /* Printf(stdout,"primitive = '%s'\n", $$);*/
+                ;}
+    break;
+
+  case 253:
+#line 5021 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.type) = (yyvsp[(1) - (1)].type); ;}
+    break;
+
+  case 254:
+#line 5022 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.type) = (yyvsp[(1) - (1)].type); ;}
+    break;
+
+  case 255:
+#line 5026 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.type) = (yyvsp[(1) - (1)].type); ;}
+    break;
+
+  case 256:
+#line 5028 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.type) = (yyvsp[(1) - (1)].str);
+               ;}
+    break;
+
+  case 257:
+#line 5036 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   if (Strcmp((yyvsp[(2) - (2)].str),"C") == 0) {
+            (yyval.id) = "externc";
+                   } else if (Strcmp((yyvsp[(2) - (2)].str),"C++") == 0) {
+            (yyval.id) = "extern";
+          } else {
+            Swig_warning(WARN_PARSE_UNDEFINED_EXTERN,cparse_file, cparse_line,"Unrecognized extern type \"%s\".\n", (yyvsp[(2) - (2)].str));
+            (yyval.id) = 0;
+          }
+               ;}
+    break;
+
+  case 258:
+#line 5048 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = "extern"; ;}
+    break;
+
+  case 259:
+#line 5049 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = (yyvsp[(1) - (1)].id); ;}
+    break;
+
+  case 260:
+#line 5050 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = "thread_local"; ;}
+    break;
+
+  case 261:
+#line 5051 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = "typedef"; ;}
+    break;
+
+  case 262:
+#line 5052 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = "static"; ;}
+    break;
+
+  case 263:
+#line 5053 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = "typedef"; ;}
+    break;
+
+  case 264:
+#line 5054 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = "virtual"; ;}
+    break;
+
+  case 265:
+#line 5055 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = "friend"; ;}
+    break;
+
+  case 266:
+#line 5056 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = "explicit"; ;}
+    break;
+
+  case 267:
+#line 5057 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = "constexpr"; ;}
+    break;
+
+  case 268:
+#line 5058 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = "explicit constexpr"; ;}
+    break;
+
+  case 269:
+#line 5059 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = "explicit constexpr"; ;}
+    break;
+
+  case 270:
+#line 5060 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = "static constexpr"; ;}
+    break;
+
+  case 271:
+#line 5061 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = "static constexpr"; ;}
+    break;
+
+  case 272:
+#line 5062 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = "thread_local"; ;}
+    break;
+
+  case 273:
+#line 5063 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = "static thread_local"; ;}
+    break;
+
+  case 274:
+#line 5064 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = "static thread_local"; ;}
+    break;
+
+  case 275:
+#line 5065 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = "extern thread_local"; ;}
+    break;
+
+  case 276:
+#line 5066 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = "extern thread_local"; ;}
+    break;
+
+  case 277:
+#line 5067 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = 0; ;}
+    break;
+
+  case 278:
+#line 5074 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 Parm *p;
+        (yyval.pl) = (yyvsp[(1) - (1)].pl);
+        p = (yyvsp[(1) - (1)].pl);
+                 while (p) {
+          Replace(Getattr(p,"type"),"typename ", "", DOH_REPLACE_ANY);
+          p = nextSibling(p);
+                 }
+               ;}
+    break;
+
+  case 279:
+#line 5085 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                  set_nextSibling((yyvsp[(1) - (2)].p),(yyvsp[(2) - (2)].pl));
+                  (yyval.pl) = (yyvsp[(1) - (2)].p);
+       ;}
+    break;
+
+  case 280:
+#line 5089 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.pl) = 0;
+         previousNode = currentNode;
+         currentNode=0;
+          ;}
+    break;
+
+  case 281:
+#line 5096 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 set_nextSibling((yyvsp[(2) - (3)].p),(yyvsp[(3) - (3)].pl));
+        (yyval.pl) = (yyvsp[(2) - (3)].p);
+                ;}
+    break;
+
+  case 282:
+#line 5100 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        set_comment(previousNode, (yyvsp[(2) - (4)].str));
+                 set_nextSibling((yyvsp[(3) - (4)].p), (yyvsp[(4) - (4)].pl));
+        (yyval.pl) = (yyvsp[(3) - (4)].p);
+               ;}
+    break;
+
+  case 283:
+#line 5105 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.pl) = 0; ;}
+    break;
+
+  case 284:
+#line 5109 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   SwigType_push((yyvsp[(1) - (2)].type),(yyvsp[(2) - (2)].decl).type);
+          (yyval.p) = NewParmWithoutFileLineInfo((yyvsp[(1) - (2)].type),(yyvsp[(2) - (2)].decl).id);
+          previousNode = currentNode;
+          currentNode = (yyval.p);
+          Setfile((yyval.p),cparse_file);
+          Setline((yyval.p),cparse_line);
+          if ((yyvsp[(2) - (2)].decl).defarg) {
+            Setattr((yyval.p),"value",(yyvsp[(2) - (2)].decl).defarg);
+          }
+       ;}
+    break;
+
+  case 285:
+#line 5121 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                  (yyval.p) = NewParmWithoutFileLineInfo(NewStringf("template<class> %s %s", (yyvsp[(5) - (7)].id),(yyvsp[(6) - (7)].str)), 0);
+         previousNode = currentNode;
+         currentNode = (yyval.p);
+         Setfile((yyval.p),cparse_file);
+         Setline((yyval.p),cparse_line);
+                  if ((yyvsp[(7) - (7)].dtype).val) {
+                    Setattr((yyval.p),"value",(yyvsp[(7) - (7)].dtype).val);
+                  }
+                ;}
+    break;
+
+  case 286:
+#line 5131 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         SwigType *t = NewString("v(...)");
+         (yyval.p) = NewParmWithoutFileLineInfo(t, 0);
+         previousNode = currentNode;
+         currentNode = (yyval.p);
+         Setfile((yyval.p),cparse_file);
+         Setline((yyval.p),cparse_line);
+       ;}
+    break;
+
+  case 287:
+#line 5141 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.p) = (yyvsp[(1) - (1)].p);
+       ;}
+    break;
+
+  case 288:
+#line 5144 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.p) = (yyvsp[(2) - (2)].p);
+         set_comment((yyvsp[(2) - (2)].p), (yyvsp[(1) - (2)].str));
+       ;}
+    break;
+
+  case 289:
+#line 5148 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.p) = (yyvsp[(1) - (2)].p);
+         set_comment((yyvsp[(1) - (2)].p), (yyvsp[(2) - (2)].str));
+       ;}
+    break;
+
+  case 290:
+#line 5154 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 Parm *p;
+        (yyval.p) = (yyvsp[(1) - (1)].p);
+        p = (yyvsp[(1) - (1)].p);
+                 while (p) {
+          if (Getattr(p,"type")) {
+            Replace(Getattr(p,"type"),"typename ", "", DOH_REPLACE_ANY);
+          }
+          p = nextSibling(p);
+                 }
+               ;}
+    break;
+
+  case 291:
+#line 5167 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                  set_nextSibling((yyvsp[(1) - (2)].p),(yyvsp[(2) - (2)].p));
+                  (yyval.p) = (yyvsp[(1) - (2)].p);
+       ;}
+    break;
+
+  case 292:
+#line 5171 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.p) = 0; ;}
+    break;
+
+  case 293:
+#line 5174 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 set_nextSibling((yyvsp[(2) - (3)].p),(yyvsp[(3) - (3)].p));
+        (yyval.p) = (yyvsp[(2) - (3)].p);
+                ;}
+    break;
+
+  case 294:
+#line 5178 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.p) = 0; ;}
+    break;
+
+  case 295:
+#line 5182 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.p) = (yyvsp[(1) - (1)].p);
+         {
+           /* We need to make a possible adjustment for integer parameters. */
+           SwigType *type;
+           Node     *n = 0;
+
+           while (!n) {
+             type = Getattr((yyvsp[(1) - (1)].p),"type");
+             n = Swig_symbol_clookup(type,0);     /* See if we can find a node that matches the typename */
+             if ((n) && (Strcmp(nodeType(n),"cdecl") == 0)) {
+           SwigType *decl = Getattr(n,"decl");
+           if (!SwigType_isfunction(decl)) {
+             String *value = Getattr(n,"value");
+             if (value) {
+               String *v = Copy(value);
+               Setattr((yyvsp[(1) - (1)].p),"type",v);
+               Delete(v);
+               n = 0;
+             }
+           }
+             } else {
+           break;
+             }
+           }
+         }
+
+               ;}
+    break;
+
+  case 296:
+#line 5210 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                  (yyval.p) = NewParmWithoutFileLineInfo(0,0);
+                  Setfile((yyval.p),cparse_file);
+         Setline((yyval.p),cparse_line);
+         Setattr((yyval.p),"value",(yyvsp[(1) - (1)].dtype).val);
+               ;}
+    break;
+
+  case 297:
+#line 5218 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                  (yyval.dtype) = (yyvsp[(2) - (2)].dtype);
+         if ((yyvsp[(2) - (2)].dtype).type == T_ERROR) {
+           Swig_warning(WARN_PARSE_BAD_DEFAULT,cparse_file, cparse_line, "Can't set default argument (ignored)\n");
+           (yyval.dtype).val = 0;
+           (yyval.dtype).rawval = 0;
+           (yyval.dtype).bitfield = 0;
+           (yyval.dtype).throws = 0;
+           (yyval.dtype).throwf = 0;
+           (yyval.dtype).nexcept = 0;
+           (yyval.dtype).final = 0;
+         }
+               ;}
+    break;
+
+  case 298:
+#line 5231 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.dtype) = (yyvsp[(2) - (5)].dtype);
+         if ((yyvsp[(2) - (5)].dtype).type == T_ERROR) {
+           Swig_warning(WARN_PARSE_BAD_DEFAULT,cparse_file, cparse_line, "Can't set default argument (ignored)\n");
+           (yyval.dtype) = (yyvsp[(2) - (5)].dtype);
+           (yyval.dtype).val = 0;
+           (yyval.dtype).rawval = 0;
+           (yyval.dtype).bitfield = 0;
+           (yyval.dtype).throws = 0;
+           (yyval.dtype).throwf = 0;
+           (yyval.dtype).nexcept = 0;
+           (yyval.dtype).final = 0;
+         } else {
+           (yyval.dtype).val = NewStringf("%s[%s]",(yyvsp[(2) - (5)].dtype).val,(yyvsp[(4) - (5)].dtype).val);
+         }
+               ;}
+    break;
+
+  case 299:
+#line 5247 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        skip_balanced('{','}');
+        (yyval.dtype).val = NewString(scanner_ccode);
+        (yyval.dtype).rawval = 0;
+                 (yyval.dtype).type = T_INT;
+        (yyval.dtype).bitfield = 0;
+        (yyval.dtype).throws = 0;
+        (yyval.dtype).throwf = 0;
+        (yyval.dtype).nexcept = 0;
+        (yyval.dtype).final = 0;
+          ;}
+    break;
+
+  case 300:
+#line 5258 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype).val = 0;
+        (yyval.dtype).rawval = 0;
+        (yyval.dtype).type = 0;
+        (yyval.dtype).bitfield = (yyvsp[(2) - (2)].dtype).val;
+        (yyval.dtype).throws = 0;
+        (yyval.dtype).throwf = 0;
+        (yyval.dtype).nexcept = 0;
+        (yyval.dtype).final = 0;
+          ;}
+    break;
+
+  case 301:
+#line 5268 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.dtype).val = 0;
+                 (yyval.dtype).rawval = 0;
+                 (yyval.dtype).type = T_INT;
+        (yyval.dtype).bitfield = 0;
+        (yyval.dtype).throws = 0;
+        (yyval.dtype).throwf = 0;
+        (yyval.dtype).nexcept = 0;
+        (yyval.dtype).final = 0;
+               ;}
+    break;
+
+  case 302:
+#line 5280 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.decl) = (yyvsp[(1) - (2)].decl);
+        (yyval.decl).defarg = (yyvsp[(2) - (2)].dtype).rawval ? (yyvsp[(2) - (2)].dtype).rawval : (yyvsp[(2) - (2)].dtype).val;
+            ;}
+    break;
+
+  case 303:
+#line 5284 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+              (yyval.decl) = (yyvsp[(1) - (2)].decl);
+         (yyval.decl).defarg = (yyvsp[(2) - (2)].dtype).rawval ? (yyvsp[(2) - (2)].dtype).rawval : (yyvsp[(2) - (2)].dtype).val;
+            ;}
+    break;
+
+  case 304:
+#line 5288 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+             (yyval.decl).type = 0;
+              (yyval.decl).id = 0;
+         (yyval.decl).defarg = (yyvsp[(1) - (1)].dtype).rawval ? (yyvsp[(1) - (1)].dtype).rawval : (yyvsp[(1) - (1)].dtype).val;
+            ;}
+    break;
+
+  case 305:
+#line 5295 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         SwigType *t;
+         (yyval.decl) = (yyvsp[(1) - (5)].decl);
+         t = NewStringEmpty();
+         SwigType_add_function(t,(yyvsp[(3) - (5)].pl));
+         if ((yyvsp[(5) - (5)].dtype).qualifier)
+           SwigType_push(t, (yyvsp[(5) - (5)].dtype).qualifier);
+         if (!(yyval.decl).have_parms) {
+       (yyval.decl).parms = (yyvsp[(3) - (5)].pl);
+       (yyval.decl).have_parms = 1;
+         }
+         if (!(yyval.decl).type) {
+       (yyval.decl).type = t;
+         } else {
+       SwigType_push(t, (yyval.decl).type);
+       Delete((yyval.decl).type);
+       (yyval.decl).type = t;
+         }
+         (yyval.decl).defarg = 0;
+       ;}
+    break;
+
+  case 306:
+#line 5317 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.decl) = (yyvsp[(1) - (1)].decl);
+        if (SwigType_isfunction((yyvsp[(1) - (1)].decl).type)) {
+          Delete(SwigType_pop_function((yyvsp[(1) - (1)].decl).type));
+        } else if (SwigType_isarray((yyvsp[(1) - (1)].decl).type)) {
+          SwigType *ta = SwigType_pop_arrays((yyvsp[(1) - (1)].decl).type);
+          if (SwigType_isfunction((yyvsp[(1) - (1)].decl).type)) {
+            Delete(SwigType_pop_function((yyvsp[(1) - (1)].decl).type));
+          } else {
+            (yyval.decl).parms = 0;
+          }
+          SwigType_push((yyvsp[(1) - (1)].decl).type,ta);
+          Delete(ta);
+        } else {
+          (yyval.decl).parms = 0;
+        }
+            ;}
+    break;
+
+  case 307:
+#line 5334 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+              (yyval.decl) = (yyvsp[(1) - (1)].decl);
+         if (SwigType_isfunction((yyvsp[(1) - (1)].decl).type)) {
+       Delete(SwigType_pop_function((yyvsp[(1) - (1)].decl).type));
+         } else if (SwigType_isarray((yyvsp[(1) - (1)].decl).type)) {
+       SwigType *ta = SwigType_pop_arrays((yyvsp[(1) - (1)].decl).type);
+       if (SwigType_isfunction((yyvsp[(1) - (1)].decl).type)) {
+         Delete(SwigType_pop_function((yyvsp[(1) - (1)].decl).type));
+       } else {
+         (yyval.decl).parms = 0;
+       }
+       SwigType_push((yyvsp[(1) - (1)].decl).type,ta);
+       Delete(ta);
+         } else {
+       (yyval.decl).parms = 0;
+         }
+            ;}
+    break;
+
+  case 308:
+#line 5353 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         SwigType *t;
+         (yyval.decl) = (yyvsp[(1) - (5)].decl);
+         t = NewStringEmpty();
+         SwigType_add_function(t, (yyvsp[(3) - (5)].pl));
+         if ((yyvsp[(5) - (5)].dtype).qualifier)
+           SwigType_push(t, (yyvsp[(5) - (5)].dtype).qualifier);
+         if (!(yyval.decl).have_parms) {
+       (yyval.decl).parms = (yyvsp[(3) - (5)].pl);
+       (yyval.decl).have_parms = 1;
+         }
+         if (!(yyval.decl).type) {
+       (yyval.decl).type = t;
+         } else {
+       SwigType_push(t, (yyval.decl).type);
+       Delete((yyval.decl).type);
+       (yyval.decl).type = t;
+         }
+       ;}
+    break;
+
+  case 309:
+#line 5372 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+             (yyval.decl).type = 0;
+              (yyval.decl).id = 0;
+         (yyval.decl).parms = 0;
+         ;}
+    break;
+
+  case 310:
+#line 5379 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+              (yyval.decl) = (yyvsp[(2) - (2)].decl);
+         if ((yyval.decl).type) {
+       SwigType_push((yyvsp[(1) - (2)].type),(yyval.decl).type);
+       Delete((yyval.decl).type);
+         }
+         (yyval.decl).type = (yyvsp[(1) - (2)].type);
+           ;}
+    break;
+
+  case 311:
+#line 5387 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+              (yyval.decl) = (yyvsp[(3) - (3)].decl);
+         SwigType_add_reference((yyvsp[(1) - (3)].type));
+              if ((yyval.decl).type) {
+       SwigType_push((yyvsp[(1) - (3)].type),(yyval.decl).type);
+       Delete((yyval.decl).type);
+         }
+         (yyval.decl).type = (yyvsp[(1) - (3)].type);
+           ;}
+    break;
+
+  case 312:
+#line 5396 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+              (yyval.decl) = (yyvsp[(3) - (3)].decl);
+         SwigType_add_rvalue_reference((yyvsp[(1) - (3)].type));
+              if ((yyval.decl).type) {
+       SwigType_push((yyvsp[(1) - (3)].type),(yyval.decl).type);
+       Delete((yyval.decl).type);
+         }
+         (yyval.decl).type = (yyvsp[(1) - (3)].type);
+           ;}
+    break;
+
+  case 313:
+#line 5405 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+              (yyval.decl) = (yyvsp[(1) - (1)].decl);
+         if (!(yyval.decl).type) (yyval.decl).type = NewStringEmpty();
+           ;}
+    break;
+
+  case 314:
+#line 5409 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.decl) = (yyvsp[(2) - (2)].decl);
+        (yyval.decl).type = NewStringEmpty();
+        SwigType_add_reference((yyval.decl).type);
+        if ((yyvsp[(2) - (2)].decl).type) {
+          SwigType_push((yyval.decl).type,(yyvsp[(2) - (2)].decl).type);
+          Delete((yyvsp[(2) - (2)].decl).type);
+        }
+           ;}
+    break;
+
+  case 315:
+#line 5418 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        /* Introduced in C++11, move operator && */
+             /* Adds one S/R conflict */
+        (yyval.decl) = (yyvsp[(2) - (2)].decl);
+        (yyval.decl).type = NewStringEmpty();
+        SwigType_add_rvalue_reference((yyval.decl).type);
+        if ((yyvsp[(2) - (2)].decl).type) {
+          SwigType_push((yyval.decl).type,(yyvsp[(2) - (2)].decl).type);
+          Delete((yyvsp[(2) - (2)].decl).type);
+        }
+           ;}
+    break;
+
+  case 316:
+#line 5429 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        SwigType *t = NewStringEmpty();
+
+        (yyval.decl) = (yyvsp[(3) - (3)].decl);
+        SwigType_add_memberpointer(t,(yyvsp[(1) - (3)].str));
+        if ((yyval.decl).type) {
+          SwigType_push(t,(yyval.decl).type);
+          Delete((yyval.decl).type);
+        }
+        (yyval.decl).type = t;
+        ;}
+    break;
+
+  case 317:
+#line 5440 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        SwigType *t = NewStringEmpty();
+        (yyval.decl) = (yyvsp[(4) - (4)].decl);
+        SwigType_add_memberpointer(t,(yyvsp[(2) - (4)].str));
+        SwigType_push((yyvsp[(1) - (4)].type),t);
+        if ((yyval.decl).type) {
+          SwigType_push((yyvsp[(1) - (4)].type),(yyval.decl).type);
+          Delete((yyval.decl).type);
+        }
+        (yyval.decl).type = (yyvsp[(1) - (4)].type);
+        Delete(t);
+      ;}
+    break;
+
+  case 318:
+#line 5452 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.decl) = (yyvsp[(5) - (5)].decl);
+        SwigType_add_memberpointer((yyvsp[(1) - (5)].type),(yyvsp[(2) - (5)].str));
+        SwigType_add_reference((yyvsp[(1) - (5)].type));
+        if ((yyval.decl).type) {
+          SwigType_push((yyvsp[(1) - (5)].type),(yyval.decl).type);
+          Delete((yyval.decl).type);
+        }
+        (yyval.decl).type = (yyvsp[(1) - (5)].type);
+      ;}
+    break;
+
+  case 319:
+#line 5462 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        SwigType *t = NewStringEmpty();
+        (yyval.decl) = (yyvsp[(4) - (4)].decl);
+        SwigType_add_memberpointer(t,(yyvsp[(1) - (4)].str));
+        SwigType_add_reference(t);
+        if ((yyval.decl).type) {
+          SwigType_push(t,(yyval.decl).type);
+          Delete((yyval.decl).type);
+        }
+        (yyval.decl).type = t;
+      ;}
+    break;
+
+  case 320:
+#line 5476 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+              (yyval.decl) = (yyvsp[(5) - (5)].decl);
+         if ((yyval.decl).type) {
+       SwigType_push((yyvsp[(1) - (5)].type),(yyval.decl).type);
+       Delete((yyval.decl).type);
+         }
+         (yyval.decl).type = (yyvsp[(1) - (5)].type);
+           ;}
+    break;
+
+  case 321:
+#line 5484 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+              (yyval.decl) = (yyvsp[(6) - (6)].decl);
+         SwigType_add_reference((yyvsp[(1) - (6)].type));
+              if ((yyval.decl).type) {
+       SwigType_push((yyvsp[(1) - (6)].type),(yyval.decl).type);
+       Delete((yyval.decl).type);
+         }
+         (yyval.decl).type = (yyvsp[(1) - (6)].type);
+           ;}
+    break;
+
+  case 322:
+#line 5493 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+              (yyval.decl) = (yyvsp[(6) - (6)].decl);
+         SwigType_add_rvalue_reference((yyvsp[(1) - (6)].type));
+              if ((yyval.decl).type) {
+       SwigType_push((yyvsp[(1) - (6)].type),(yyval.decl).type);
+       Delete((yyval.decl).type);
+         }
+         (yyval.decl).type = (yyvsp[(1) - (6)].type);
+           ;}
+    break;
+
+  case 323:
+#line 5502 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+              (yyval.decl) = (yyvsp[(4) - (4)].decl);
+         if (!(yyval.decl).type) (yyval.decl).type = NewStringEmpty();
+           ;}
+    break;
+
+  case 324:
+#line 5506 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.decl) = (yyvsp[(5) - (5)].decl);
+        (yyval.decl).type = NewStringEmpty();
+        SwigType_add_reference((yyval.decl).type);
+        if ((yyvsp[(5) - (5)].decl).type) {
+          SwigType_push((yyval.decl).type,(yyvsp[(5) - (5)].decl).type);
+          Delete((yyvsp[(5) - (5)].decl).type);
+        }
+           ;}
+    break;
+
+  case 325:
+#line 5515 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        /* Introduced in C++11, move operator && */
+             /* Adds one S/R conflict */
+        (yyval.decl) = (yyvsp[(5) - (5)].decl);
+        (yyval.decl).type = NewStringEmpty();
+        SwigType_add_rvalue_reference((yyval.decl).type);
+        if ((yyvsp[(5) - (5)].decl).type) {
+          SwigType_push((yyval.decl).type,(yyvsp[(5) - (5)].decl).type);
+          Delete((yyvsp[(5) - (5)].decl).type);
+        }
+           ;}
+    break;
+
+  case 326:
+#line 5526 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        SwigType *t = NewStringEmpty();
+
+        (yyval.decl) = (yyvsp[(6) - (6)].decl);
+        SwigType_add_memberpointer(t,(yyvsp[(1) - (6)].str));
+        if ((yyval.decl).type) {
+          SwigType_push(t,(yyval.decl).type);
+          Delete((yyval.decl).type);
+        }
+        (yyval.decl).type = t;
+        ;}
+    break;
+
+  case 327:
+#line 5537 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        SwigType *t = NewStringEmpty();
+        (yyval.decl) = (yyvsp[(7) - (7)].decl);
+        SwigType_add_memberpointer(t,(yyvsp[(2) - (7)].str));
+        SwigType_push((yyvsp[(1) - (7)].type),t);
+        if ((yyval.decl).type) {
+          SwigType_push((yyvsp[(1) - (7)].type),(yyval.decl).type);
+          Delete((yyval.decl).type);
+        }
+        (yyval.decl).type = (yyvsp[(1) - (7)].type);
+        Delete(t);
+      ;}
+    break;
+
+  case 328:
+#line 5549 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.decl) = (yyvsp[(8) - (8)].decl);
+        SwigType_add_memberpointer((yyvsp[(1) - (8)].type),(yyvsp[(2) - (8)].str));
+        SwigType_add_reference((yyvsp[(1) - (8)].type));
+        if ((yyval.decl).type) {
+          SwigType_push((yyvsp[(1) - (8)].type),(yyval.decl).type);
+          Delete((yyval.decl).type);
+        }
+        (yyval.decl).type = (yyvsp[(1) - (8)].type);
+      ;}
+    break;
+
+  case 329:
+#line 5559 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.decl) = (yyvsp[(8) - (8)].decl);
+        SwigType_add_memberpointer((yyvsp[(1) - (8)].type),(yyvsp[(2) - (8)].str));
+        SwigType_add_rvalue_reference((yyvsp[(1) - (8)].type));
+        if ((yyval.decl).type) {
+          SwigType_push((yyvsp[(1) - (8)].type),(yyval.decl).type);
+          Delete((yyval.decl).type);
+        }
+        (yyval.decl).type = (yyvsp[(1) - (8)].type);
+      ;}
+    break;
+
+  case 330:
+#line 5569 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        SwigType *t = NewStringEmpty();
+        (yyval.decl) = (yyvsp[(7) - (7)].decl);
+        SwigType_add_memberpointer(t,(yyvsp[(1) - (7)].str));
+        SwigType_add_reference(t);
+        if ((yyval.decl).type) {
+          SwigType_push(t,(yyval.decl).type);
+          Delete((yyval.decl).type);
+        }
+        (yyval.decl).type = t;
+      ;}
+    break;
+
+  case 331:
+#line 5580 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        SwigType *t = NewStringEmpty();
+        (yyval.decl) = (yyvsp[(7) - (7)].decl);
+        SwigType_add_memberpointer(t,(yyvsp[(1) - (7)].str));
+        SwigType_add_rvalue_reference(t);
+        if ((yyval.decl).type) {
+          SwigType_push(t,(yyval.decl).type);
+          Delete((yyval.decl).type);
+        }
+        (yyval.decl).type = t;
+      ;}
+    break;
+
+  case 332:
+#line 5593 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                /* Note: This is non-standard C.  Template declarator is allowed to follow an identifier */
+                 (yyval.decl).id = Char((yyvsp[(1) - (1)].str));
+        (yyval.decl).type = 0;
+        (yyval.decl).parms = 0;
+        (yyval.decl).have_parms = 0;
+                  ;}
+    break;
+
+  case 333:
+#line 5600 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                  (yyval.decl).id = Char(NewStringf("~%s",(yyvsp[(2) - (2)].str)));
+                  (yyval.decl).type = 0;
+                  (yyval.decl).parms = 0;
+                  (yyval.decl).have_parms = 0;
+                  ;}
+    break;
+
+  case 334:
+#line 5608 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                  (yyval.decl).id = Char((yyvsp[(2) - (3)].str));
+                  (yyval.decl).type = 0;
+                  (yyval.decl).parms = 0;
+                  (yyval.decl).have_parms = 0;
+                  ;}
+    break;
+
+  case 335:
+#line 5624 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.decl) = (yyvsp[(3) - (4)].decl);
+           if ((yyval.decl).type) {
+             SwigType_push((yyvsp[(2) - (4)].type),(yyval.decl).type);
+             Delete((yyval.decl).type);
+           }
+           (yyval.decl).type = (yyvsp[(2) - (4)].type);
+                  ;}
+    break;
+
+  case 336:
+#line 5632 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           SwigType *t;
+           (yyval.decl) = (yyvsp[(4) - (5)].decl);
+           t = NewStringEmpty();
+           SwigType_add_memberpointer(t,(yyvsp[(2) - (5)].str));
+           if ((yyval.decl).type) {
+             SwigType_push(t,(yyval.decl).type);
+             Delete((yyval.decl).type);
+           }
+           (yyval.decl).type = t;
+           ;}
+    break;
+
+  case 337:
+#line 5643 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           SwigType *t;
+           (yyval.decl) = (yyvsp[(1) - (3)].decl);
+           t = NewStringEmpty();
+           SwigType_add_array(t,"");
+           if ((yyval.decl).type) {
+             SwigType_push(t,(yyval.decl).type);
+             Delete((yyval.decl).type);
+           }
+           (yyval.decl).type = t;
+                  ;}
+    break;
+
+  case 338:
+#line 5654 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           SwigType *t;
+           (yyval.decl) = (yyvsp[(1) - (4)].decl);
+           t = NewStringEmpty();
+           SwigType_add_array(t,(yyvsp[(3) - (4)].dtype).val);
+           if ((yyval.decl).type) {
+             SwigType_push(t,(yyval.decl).type);
+             Delete((yyval.decl).type);
+           }
+           (yyval.decl).type = t;
+                  ;}
+    break;
+
+  case 339:
+#line 5665 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           SwigType *t;
+                    (yyval.decl) = (yyvsp[(1) - (4)].decl);
+           t = NewStringEmpty();
+           SwigType_add_function(t,(yyvsp[(3) - (4)].pl));
+           if (!(yyval.decl).have_parms) {
+             (yyval.decl).parms = (yyvsp[(3) - (4)].pl);
+             (yyval.decl).have_parms = 1;
+           }
+           if (!(yyval.decl).type) {
+             (yyval.decl).type = t;
+           } else {
+             SwigType_push(t, (yyval.decl).type);
+             Delete((yyval.decl).type);
+             (yyval.decl).type = t;
+           }
+         ;}
+    break;
+
+  case 340:
+#line 5684 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                /* Note: This is non-standard C.  Template declarator is allowed to follow an identifier */
+                 (yyval.decl).id = Char((yyvsp[(1) - (1)].str));
+        (yyval.decl).type = 0;
+        (yyval.decl).parms = 0;
+        (yyval.decl).have_parms = 0;
+                  ;}
+    break;
+
+  case 341:
+#line 5692 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                  (yyval.decl).id = Char(NewStringf("~%s",(yyvsp[(2) - (2)].str)));
+                  (yyval.decl).type = 0;
+                  (yyval.decl).parms = 0;
+                  (yyval.decl).have_parms = 0;
+                  ;}
+    break;
+
+  case 342:
+#line 5709 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.decl) = (yyvsp[(3) - (4)].decl);
+           if ((yyval.decl).type) {
+             SwigType_push((yyvsp[(2) - (4)].type),(yyval.decl).type);
+             Delete((yyval.decl).type);
+           }
+           (yyval.decl).type = (yyvsp[(2) - (4)].type);
+                  ;}
+    break;
+
+  case 343:
+#line 5717 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.decl) = (yyvsp[(3) - (4)].decl);
+           if (!(yyval.decl).type) {
+             (yyval.decl).type = NewStringEmpty();
+           }
+           SwigType_add_reference((yyval.decl).type);
+                  ;}
+    break;
+
+  case 344:
+#line 5724 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.decl) = (yyvsp[(3) - (4)].decl);
+           if (!(yyval.decl).type) {
+             (yyval.decl).type = NewStringEmpty();
+           }
+           SwigType_add_rvalue_reference((yyval.decl).type);
+                  ;}
+    break;
+
+  case 345:
+#line 5731 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           SwigType *t;
+           (yyval.decl) = (yyvsp[(4) - (5)].decl);
+           t = NewStringEmpty();
+           SwigType_add_memberpointer(t,(yyvsp[(2) - (5)].str));
+           if ((yyval.decl).type) {
+             SwigType_push(t,(yyval.decl).type);
+             Delete((yyval.decl).type);
+           }
+           (yyval.decl).type = t;
+         ;}
+    break;
+
+  case 346:
+#line 5742 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           SwigType *t;
+           (yyval.decl) = (yyvsp[(5) - (6)].decl);
+           t = NewStringEmpty();
+           SwigType_add_memberpointer(t, (yyvsp[(2) - (6)].str));
+           SwigType_push(t, (yyvsp[(4) - (6)].str));
+           if ((yyval.decl).type) {
+             SwigType_push(t, (yyval.decl).type);
+             Delete((yyval.decl).type);
+           }
+           (yyval.decl).type = t;
+         ;}
+    break;
+
+  case 347:
+#line 5754 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           SwigType *t;
+           (yyval.decl) = (yyvsp[(4) - (5)].decl);
+           t = NewStringEmpty();
+           SwigType_add_memberpointer(t, (yyvsp[(2) - (5)].str));
+           if ((yyval.decl).type) {
+             SwigType_push(t, (yyval.decl).type);
+             Delete((yyval.decl).type);
+           }
+           (yyval.decl).type = t;
+         ;}
+    break;
+
+  case 348:
+#line 5765 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           SwigType *t;
+           (yyval.decl) = (yyvsp[(5) - (6)].decl);
+           t = NewStringEmpty();
+           SwigType_add_memberpointer(t, (yyvsp[(2) - (6)].str));
+           SwigType_push(t, (yyvsp[(4) - (6)].str));
+           if ((yyval.decl).type) {
+             SwigType_push(t, (yyval.decl).type);
+             Delete((yyval.decl).type);
+           }
+           (yyval.decl).type = t;
+         ;}
+    break;
+
+  case 349:
+#line 5777 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           SwigType *t;
+           (yyval.decl) = (yyvsp[(1) - (3)].decl);
+           t = NewStringEmpty();
+           SwigType_add_array(t,"");
+           if ((yyval.decl).type) {
+             SwigType_push(t,(yyval.decl).type);
+             Delete((yyval.decl).type);
+           }
+           (yyval.decl).type = t;
+                  ;}
+    break;
+
+  case 350:
+#line 5788 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           SwigType *t;
+           (yyval.decl) = (yyvsp[(1) - (4)].decl);
+           t = NewStringEmpty();
+           SwigType_add_array(t,(yyvsp[(3) - (4)].dtype).val);
+           if ((yyval.decl).type) {
+             SwigType_push(t,(yyval.decl).type);
+             Delete((yyval.decl).type);
+           }
+           (yyval.decl).type = t;
+                  ;}
+    break;
+
+  case 351:
+#line 5799 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           SwigType *t;
+                    (yyval.decl) = (yyvsp[(1) - (4)].decl);
+           t = NewStringEmpty();
+           SwigType_add_function(t,(yyvsp[(3) - (4)].pl));
+           if (!(yyval.decl).have_parms) {
+             (yyval.decl).parms = (yyvsp[(3) - (4)].pl);
+             (yyval.decl).have_parms = 1;
+           }
+           if (!(yyval.decl).type) {
+             (yyval.decl).type = t;
+           } else {
+             SwigType_push(t, (yyval.decl).type);
+             Delete((yyval.decl).type);
+             (yyval.decl).type = t;
+           }
+         ;}
+    break;
+
+  case 352:
+#line 5819 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           SwigType *t;
+                    Append((yyvsp[(1) - (5)].str), " "); /* intervening space is mandatory */
+                    Append((yyvsp[(1) - (5)].str), Char((yyvsp[(2) - (5)].id)));
+           (yyval.decl).id = Char((yyvsp[(1) - (5)].str));
+           t = NewStringEmpty();
+           SwigType_add_function(t,(yyvsp[(4) - (5)].pl));
+           if (!(yyval.decl).have_parms) {
+             (yyval.decl).parms = (yyvsp[(4) - (5)].pl);
+             (yyval.decl).have_parms = 1;
+           }
+           if (!(yyval.decl).type) {
+             (yyval.decl).type = t;
+           } else {
+             SwigType_push(t, (yyval.decl).type);
+             Delete((yyval.decl).type);
+             (yyval.decl).type = t;
+           }
+         ;}
+    break;
+
+  case 353:
+#line 5840 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.decl).type = (yyvsp[(1) - (1)].type);
+                    (yyval.decl).id = 0;
+           (yyval.decl).parms = 0;
+           (yyval.decl).have_parms = 0;
+                  ;}
+    break;
+
+  case 354:
+#line 5846 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                     (yyval.decl) = (yyvsp[(2) - (2)].decl);
+                     SwigType_push((yyvsp[(1) - (2)].type),(yyvsp[(2) - (2)].decl).type);
+            (yyval.decl).type = (yyvsp[(1) - (2)].type);
+            Delete((yyvsp[(2) - (2)].decl).type);
+                  ;}
+    break;
+
+  case 355:
+#line 5852 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.decl).type = (yyvsp[(1) - (2)].type);
+           SwigType_add_reference((yyval.decl).type);
+           (yyval.decl).id = 0;
+           (yyval.decl).parms = 0;
+           (yyval.decl).have_parms = 0;
+         ;}
+    break;
+
+  case 356:
+#line 5859 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.decl).type = (yyvsp[(1) - (2)].type);
+           SwigType_add_rvalue_reference((yyval.decl).type);
+           (yyval.decl).id = 0;
+           (yyval.decl).parms = 0;
+           (yyval.decl).have_parms = 0;
+         ;}
+    break;
+
+  case 357:
+#line 5866 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.decl) = (yyvsp[(3) - (3)].decl);
+           SwigType_add_reference((yyvsp[(1) - (3)].type));
+           if ((yyval.decl).type) {
+             SwigType_push((yyvsp[(1) - (3)].type),(yyval.decl).type);
+             Delete((yyval.decl).type);
+           }
+           (yyval.decl).type = (yyvsp[(1) - (3)].type);
+                  ;}
+    break;
+
+  case 358:
+#line 5875 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.decl) = (yyvsp[(3) - (3)].decl);
+           SwigType_add_rvalue_reference((yyvsp[(1) - (3)].type));
+           if ((yyval.decl).type) {
+             SwigType_push((yyvsp[(1) - (3)].type),(yyval.decl).type);
+             Delete((yyval.decl).type);
+           }
+           (yyval.decl).type = (yyvsp[(1) - (3)].type);
+                  ;}
+    break;
+
+  case 359:
+#line 5884 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.decl) = (yyvsp[(1) - (1)].decl);
+                  ;}
+    break;
+
+  case 360:
+#line 5887 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.decl) = (yyvsp[(2) - (2)].decl);
+           (yyval.decl).type = NewStringEmpty();
+           SwigType_add_reference((yyval.decl).type);
+           if ((yyvsp[(2) - (2)].decl).type) {
+             SwigType_push((yyval.decl).type,(yyvsp[(2) - (2)].decl).type);
+             Delete((yyvsp[(2) - (2)].decl).type);
+           }
+                  ;}
+    break;
+
+  case 361:
+#line 5896 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.decl) = (yyvsp[(2) - (2)].decl);
+           (yyval.decl).type = NewStringEmpty();
+           SwigType_add_rvalue_reference((yyval.decl).type);
+           if ((yyvsp[(2) - (2)].decl).type) {
+             SwigType_push((yyval.decl).type,(yyvsp[(2) - (2)].decl).type);
+             Delete((yyvsp[(2) - (2)].decl).type);
+           }
+                  ;}
+    break;
+
+  case 362:
+#line 5905 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.decl).id = 0;
+                    (yyval.decl).parms = 0;
+           (yyval.decl).have_parms = 0;
+                    (yyval.decl).type = NewStringEmpty();
+           SwigType_add_reference((yyval.decl).type);
+                  ;}
+    break;
+
+  case 363:
+#line 5912 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.decl).id = 0;
+                    (yyval.decl).parms = 0;
+           (yyval.decl).have_parms = 0;
+                    (yyval.decl).type = NewStringEmpty();
+           SwigType_add_rvalue_reference((yyval.decl).type);
+                  ;}
+    break;
+
+  case 364:
+#line 5919 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.decl).type = NewStringEmpty();
+                    SwigType_add_memberpointer((yyval.decl).type,(yyvsp[(1) - (2)].str));
+                    (yyval.decl).id = 0;
+                    (yyval.decl).parms = 0;
+           (yyval.decl).have_parms = 0;
+                 ;}
+    break;
+
+  case 365:
+#line 5926 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.decl).type = NewStringEmpty();
+           SwigType_add_memberpointer((yyval.decl).type, (yyvsp[(1) - (3)].str));
+           SwigType_push((yyval.decl).type, (yyvsp[(3) - (3)].str));
+           (yyval.decl).id = 0;
+           (yyval.decl).parms = 0;
+           (yyval.decl).have_parms = 0;
+         ;}
+    break;
+
+  case 366:
+#line 5934 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           SwigType *t = NewStringEmpty();
+                    (yyval.decl).type = (yyvsp[(1) - (3)].type);
+           (yyval.decl).id = 0;
+           (yyval.decl).parms = 0;
+           (yyval.decl).have_parms = 0;
+           SwigType_add_memberpointer(t,(yyvsp[(2) - (3)].str));
+           SwigType_push((yyval.decl).type,t);
+           Delete(t);
+                  ;}
+    break;
+
+  case 367:
+#line 5944 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.decl) = (yyvsp[(4) - (4)].decl);
+           SwigType_add_memberpointer((yyvsp[(1) - (4)].type),(yyvsp[(2) - (4)].str));
+           if ((yyval.decl).type) {
+             SwigType_push((yyvsp[(1) - (4)].type),(yyval.decl).type);
+             Delete((yyval.decl).type);
+           }
+           (yyval.decl).type = (yyvsp[(1) - (4)].type);
+                  ;}
+    break;
+
+  case 368:
+#line 5955 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           SwigType *t;
+           (yyval.decl) = (yyvsp[(1) - (3)].decl);
+           t = NewStringEmpty();
+           SwigType_add_array(t,"");
+           if ((yyval.decl).type) {
+             SwigType_push(t,(yyval.decl).type);
+             Delete((yyval.decl).type);
+           }
+           (yyval.decl).type = t;
+                  ;}
+    break;
+
+  case 369:
+#line 5966 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           SwigType *t;
+           (yyval.decl) = (yyvsp[(1) - (4)].decl);
+           t = NewStringEmpty();
+           SwigType_add_array(t,(yyvsp[(3) - (4)].dtype).val);
+           if ((yyval.decl).type) {
+             SwigType_push(t,(yyval.decl).type);
+             Delete((yyval.decl).type);
+           }
+           (yyval.decl).type = t;
+                  ;}
+    break;
+
+  case 370:
+#line 5977 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.decl).type = NewStringEmpty();
+           (yyval.decl).id = 0;
+           (yyval.decl).parms = 0;
+           (yyval.decl).have_parms = 0;
+           SwigType_add_array((yyval.decl).type,"");
+                  ;}
+    break;
+
+  case 371:
+#line 5984 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.decl).type = NewStringEmpty();
+           (yyval.decl).id = 0;
+           (yyval.decl).parms = 0;
+           (yyval.decl).have_parms = 0;
+           SwigType_add_array((yyval.decl).type,(yyvsp[(2) - (3)].dtype).val);
+         ;}
+    break;
+
+  case 372:
+#line 5991 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.decl) = (yyvsp[(2) - (3)].decl);
+         ;}
+    break;
+
+  case 373:
+#line 5994 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           SwigType *t;
+                    (yyval.decl) = (yyvsp[(1) - (4)].decl);
+           t = NewStringEmpty();
+                    SwigType_add_function(t,(yyvsp[(3) - (4)].pl));
+           if (!(yyval.decl).type) {
+             (yyval.decl).type = t;
+           } else {
+             SwigType_push(t,(yyval.decl).type);
+             Delete((yyval.decl).type);
+             (yyval.decl).type = t;
+           }
+           if (!(yyval.decl).have_parms) {
+             (yyval.decl).parms = (yyvsp[(3) - (4)].pl);
+             (yyval.decl).have_parms = 1;
+           }
+         ;}
+    break;
+
+  case 374:
+#line 6011 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           SwigType *t;
+                    (yyval.decl) = (yyvsp[(1) - (5)].decl);
+           t = NewStringEmpty();
+                    SwigType_add_function(t,(yyvsp[(3) - (5)].pl));
+           SwigType_push(t, (yyvsp[(5) - (5)].dtype).qualifier);
+           if (!(yyval.decl).type) {
+             (yyval.decl).type = t;
+           } else {
+             SwigType_push(t,(yyval.decl).type);
+             Delete((yyval.decl).type);
+             (yyval.decl).type = t;
+           }
+           if (!(yyval.decl).have_parms) {
+             (yyval.decl).parms = (yyvsp[(3) - (5)].pl);
+             (yyval.decl).have_parms = 1;
+           }
+         ;}
+    break;
+
+  case 375:
+#line 6029 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.decl).type = NewStringEmpty();
+                    SwigType_add_function((yyval.decl).type,(yyvsp[(2) - (3)].pl));
+           (yyval.decl).parms = (yyvsp[(2) - (3)].pl);
+           (yyval.decl).have_parms = 1;
+           (yyval.decl).id = 0;
+                  ;}
+    break;
+
+  case 376:
+#line 6039 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+             (yyval.type) = NewStringEmpty();
+             SwigType_add_pointer((yyval.type));
+        SwigType_push((yyval.type),(yyvsp[(2) - (3)].str));
+        SwigType_push((yyval.type),(yyvsp[(3) - (3)].type));
+        Delete((yyvsp[(3) - (3)].type));
+           ;}
+    break;
+
+  case 377:
+#line 6046 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.type) = NewStringEmpty();
+        SwigType_add_pointer((yyval.type));
+        SwigType_push((yyval.type),(yyvsp[(2) - (2)].type));
+        Delete((yyvsp[(2) - (2)].type));
+      ;}
+    break;
+
+  case 378:
+#line 6052 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.type) = NewStringEmpty();
+        SwigType_add_pointer((yyval.type));
+        SwigType_push((yyval.type),(yyvsp[(2) - (2)].str));
+           ;}
+    break;
+
+  case 379:
+#line 6057 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.type) = NewStringEmpty();
+        SwigType_add_pointer((yyval.type));
+           ;}
+    break;
+
+  case 380:
+#line 6064 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.dtype).qualifier = (yyvsp[(1) - (1)].str);
+         (yyval.dtype).refqualifier = 0;
+          ;}
+    break;
+
+  case 381:
+#line 6068 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.dtype).qualifier = (yyvsp[(1) - (2)].str);
+         (yyval.dtype).refqualifier = (yyvsp[(2) - (2)].str);
+         SwigType_push((yyval.dtype).qualifier, (yyvsp[(2) - (2)].str));
+          ;}
+    break;
+
+  case 382:
+#line 6073 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.dtype).qualifier = NewStringEmpty();
+         (yyval.dtype).refqualifier = (yyvsp[(1) - (1)].str);
+         SwigType_push((yyval.dtype).qualifier, (yyvsp[(1) - (1)].str));
+          ;}
+    break;
+
+  case 383:
+#line 6080 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+             (yyval.str) = NewStringEmpty();
+             SwigType_add_reference((yyval.str));
+          ;}
+    break;
+
+  case 384:
+#line 6084 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+             (yyval.str) = NewStringEmpty();
+             SwigType_add_rvalue_reference((yyval.str));
+          ;}
+    break;
+
+  case 385:
+#line 6090 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+             (yyval.str) = NewStringEmpty();
+             if ((yyvsp[(1) - (1)].id)) SwigType_add_qualifier((yyval.str),(yyvsp[(1) - (1)].id));
+               ;}
+    break;
+
+  case 386:
+#line 6094 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.str) = (yyvsp[(2) - (2)].str);
+             if ((yyvsp[(1) - (2)].id)) SwigType_add_qualifier((yyval.str),(yyvsp[(1) - (2)].id));
+               ;}
+    break;
+
+  case 387:
+#line 6100 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = "const"; ;}
+    break;
+
+  case 388:
+#line 6101 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = "volatile"; ;}
+    break;
+
+  case 389:
+#line 6102 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = 0; ;}
+    break;
+
+  case 390:
+#line 6108 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.type) = (yyvsp[(1) - (1)].type);
+                   Replace((yyval.type),"typename ","", DOH_REPLACE_ANY);
+                ;}
+    break;
+
+  case 391:
+#line 6114 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.type) = (yyvsp[(2) - (2)].type);
+              SwigType_push((yyval.type),(yyvsp[(1) - (2)].str));
+               ;}
+    break;
+
+  case 392:
+#line 6118 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.type) = (yyvsp[(1) - (1)].type); ;}
+    break;
+
+  case 393:
+#line 6119 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.type) = (yyvsp[(1) - (2)].type);
+             SwigType_push((yyval.type),(yyvsp[(2) - (2)].str));
+          ;}
+    break;
+
+  case 394:
+#line 6123 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.type) = (yyvsp[(2) - (3)].type);
+             SwigType_push((yyval.type),(yyvsp[(3) - (3)].str));
+             SwigType_push((yyval.type),(yyvsp[(1) - (3)].str));
+          ;}
+    break;
+
+  case 395:
+#line 6130 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.type) = (yyvsp[(1) - (1)].type);
+                  /* Printf(stdout,"primitive = '%s'\n", $$);*/
+               ;}
+    break;
+
+  case 396:
+#line 6133 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.type) = (yyvsp[(1) - (1)].type); ;}
+    break;
+
+  case 397:
+#line 6134 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.type) = (yyvsp[(1) - (1)].type); ;}
+    break;
+
+  case 398:
+#line 6138 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.type) = NewStringf("enum %s", (yyvsp[(2) - (2)].str)); ;}
+    break;
+
+  case 399:
+#line 6139 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.type) = (yyvsp[(1) - (1)].type); ;}
+    break;
+
+  case 400:
+#line 6141 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.type) = (yyvsp[(1) - (1)].str);
+               ;}
+    break;
+
+  case 401:
+#line 6144 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.type) = NewStringf("%s %s", (yyvsp[(1) - (2)].id), (yyvsp[(2) - (2)].str));
+               ;}
+    break;
+
+  case 402:
+#line 6147 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.type) = (yyvsp[(1) - (1)].type);
+               ;}
+    break;
+
+  case 403:
+#line 6152 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 Node *n = Swig_symbol_clookup((yyvsp[(3) - (4)].str),0);
+                 if (!n) {
+          Swig_error(cparse_file, cparse_line, "Identifier %s not defined.\n", (yyvsp[(3) - (4)].str));
+                   (yyval.type) = (yyvsp[(3) - (4)].str);
+                 } else {
+                   (yyval.type) = Getattr(n, "type");
+                 }
+               ;}
+    break;
+
+  case 404:
+#line 6163 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        if (!(yyvsp[(1) - (1)].ptype).type) (yyvsp[(1) - (1)].ptype).type = NewString("int");
+        if ((yyvsp[(1) - (1)].ptype).us) {
+          (yyval.type) = NewStringf("%s %s", (yyvsp[(1) - (1)].ptype).us, (yyvsp[(1) - (1)].ptype).type);
+          Delete((yyvsp[(1) - (1)].ptype).us);
+                   Delete((yyvsp[(1) - (1)].ptype).type);
+        } else {
+                   (yyval.type) = (yyvsp[(1) - (1)].ptype).type;
+        }
+        if (Cmp((yyval.type),"signed int") == 0) {
+          Delete((yyval.type));
+          (yyval.type) = NewString("int");
+                 } else if (Cmp((yyval.type),"signed long") == 0) {
+          Delete((yyval.type));
+                   (yyval.type) = NewString("long");
+                 } else if (Cmp((yyval.type),"signed short") == 0) {
+          Delete((yyval.type));
+          (yyval.type) = NewString("short");
+        } else if (Cmp((yyval.type),"signed long long") == 0) {
+          Delete((yyval.type));
+          (yyval.type) = NewString("long long");
+        }
+               ;}
+    break;
+
+  case 405:
+#line 6188 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.ptype) = (yyvsp[(1) - (1)].ptype);
+               ;}
+    break;
+
+  case 406:
+#line 6191 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    if ((yyvsp[(1) - (2)].ptype).us && (yyvsp[(2) - (2)].ptype).us) {
+             Swig_error(cparse_file, cparse_line, "Extra %s specifier.\n", (yyvsp[(2) - (2)].ptype).us);
+           }
+                    (yyval.ptype) = (yyvsp[(2) - (2)].ptype);
+                    if ((yyvsp[(1) - (2)].ptype).us) (yyval.ptype).us = (yyvsp[(1) - (2)].ptype).us;
+           if ((yyvsp[(1) - (2)].ptype).type) {
+             if (!(yyvsp[(2) - (2)].ptype).type) (yyval.ptype).type = (yyvsp[(1) - (2)].ptype).type;
+             else {
+           int err = 0;
+           if ((Cmp((yyvsp[(1) - (2)].ptype).type,"long") == 0)) {
+             if ((Cmp((yyvsp[(2) - (2)].ptype).type,"long") == 0) || (Strncmp((yyvsp[(2) - (2)].ptype).type,"double",6) == 0)) {
+               (yyval.ptype).type = NewStringf("long %s", (yyvsp[(2) - (2)].ptype).type);
+             } else if (Cmp((yyvsp[(2) - (2)].ptype).type,"int") == 0) {
+               (yyval.ptype).type = (yyvsp[(1) - (2)].ptype).type;
+             } else {
+               err = 1;
+             }
+           } else if ((Cmp((yyvsp[(1) - (2)].ptype).type,"short")) == 0) {
+             if (Cmp((yyvsp[(2) - (2)].ptype).type,"int") == 0) {
+               (yyval.ptype).type = (yyvsp[(1) - (2)].ptype).type;
+             } else {
+               err = 1;
+             }
+           } else if (Cmp((yyvsp[(1) - (2)].ptype).type,"int") == 0) {
+             (yyval.ptype).type = (yyvsp[(2) - (2)].ptype).type;
+           } else if (Cmp((yyvsp[(1) - (2)].ptype).type,"double") == 0) {
+             if (Cmp((yyvsp[(2) - (2)].ptype).type,"long") == 0) {
+               (yyval.ptype).type = NewString("long double");
+             } else if (Cmp((yyvsp[(2) - (2)].ptype).type,"complex") == 0) {
+               (yyval.ptype).type = NewString("double complex");
+             } else {
+               err = 1;
+             }
+           } else if (Cmp((yyvsp[(1) - (2)].ptype).type,"float") == 0) {
+             if (Cmp((yyvsp[(2) - (2)].ptype).type,"complex") == 0) {
+               (yyval.ptype).type = NewString("float complex");
+             } else {
+               err = 1;
+             }
+           } else if (Cmp((yyvsp[(1) - (2)].ptype).type,"complex") == 0) {
+             (yyval.ptype).type = NewStringf("%s complex", (yyvsp[(2) - (2)].ptype).type);
+           } else {
+             err = 1;
+           }
+           if (err) {
+             Swig_error(cparse_file, cparse_line, "Extra %s specifier.\n", (yyvsp[(1) - (2)].ptype).type);
+           }
+             }
+           }
+               ;}
+    break;
+
+  case 407:
+#line 6245 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.ptype).type = NewString("int");
+                    (yyval.ptype).us = 0;
+               ;}
+    break;
+
+  case 408:
+#line 6249 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.ptype).type = NewString("short");
+                    (yyval.ptype).us = 0;
+                ;}
+    break;
+
+  case 409:
+#line 6253 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.ptype).type = NewString("long");
+                    (yyval.ptype).us = 0;
+                ;}
+    break;
+
+  case 410:
+#line 6257 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.ptype).type = NewString("char");
+                    (yyval.ptype).us = 0;
+                ;}
+    break;
+
+  case 411:
+#line 6261 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.ptype).type = NewString("wchar_t");
+                    (yyval.ptype).us = 0;
+                ;}
+    break;
+
+  case 412:
+#line 6265 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.ptype).type = NewString("float");
+                    (yyval.ptype).us = 0;
+                ;}
+    break;
+
+  case 413:
+#line 6269 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.ptype).type = NewString("double");
+                    (yyval.ptype).us = 0;
+                ;}
+    break;
+
+  case 414:
+#line 6273 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.ptype).us = NewString("signed");
+                    (yyval.ptype).type = 0;
+                ;}
+    break;
+
+  case 415:
+#line 6277 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.ptype).us = NewString("unsigned");
+                    (yyval.ptype).type = 0;
+                ;}
+    break;
+
+  case 416:
+#line 6281 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.ptype).type = NewString("complex");
+                    (yyval.ptype).us = 0;
+                ;}
+    break;
+
+  case 417:
+#line 6285 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.ptype).type = NewString("__int8");
+                    (yyval.ptype).us = 0;
+                ;}
+    break;
+
+  case 418:
+#line 6289 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.ptype).type = NewString("__int16");
+                    (yyval.ptype).us = 0;
+                ;}
+    break;
+
+  case 419:
+#line 6293 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.ptype).type = NewString("__int32");
+                    (yyval.ptype).us = 0;
+                ;}
+    break;
+
+  case 420:
+#line 6297 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.ptype).type = NewString("__int64");
+                    (yyval.ptype).us = 0;
+                ;}
+    break;
+
+  case 421:
+#line 6303 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { /* scanner_check_typedef(); */ ;}
+    break;
+
+  case 422:
+#line 6303 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.dtype) = (yyvsp[(2) - (2)].dtype);
+          if ((yyval.dtype).type == T_STRING) {
+            (yyval.dtype).rawval = NewStringf("\"%(escape)s\"",(yyval.dtype).val);
+          } else if ((yyval.dtype).type != T_CHAR && (yyval.dtype).type != T_WSTRING && (yyval.dtype).type != T_WCHAR) {
+            (yyval.dtype).rawval = NewStringf("%s", (yyval.dtype).val);
+          }
+          (yyval.dtype).qualifier = 0;
+          (yyval.dtype).refqualifier = 0;
+          (yyval.dtype).bitfield = 0;
+          (yyval.dtype).throws = 0;
+          (yyval.dtype).throwf = 0;
+          (yyval.dtype).nexcept = 0;
+          (yyval.dtype).final = 0;
+          scanner_ignore_typedef();
+                ;}
+    break;
+
+  case 423:
+#line 6319 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.dtype) = (yyvsp[(1) - (1)].dtype);
+       ;}
+    break;
+
+  case 424:
+#line 6324 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.dtype) = (yyvsp[(1) - (1)].dtype);
+       ;}
+    break;
+
+  case 425:
+#line 6327 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.dtype) = (yyvsp[(1) - (1)].dtype);
+       ;}
+    break;
+
+  case 426:
+#line 6333 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.dtype).val = NewString("delete");
+         (yyval.dtype).rawval = 0;
+         (yyval.dtype).type = T_STRING;
+         (yyval.dtype).qualifier = 0;
+         (yyval.dtype).refqualifier = 0;
+         (yyval.dtype).bitfield = 0;
+         (yyval.dtype).throws = 0;
+         (yyval.dtype).throwf = 0;
+         (yyval.dtype).nexcept = 0;
+         (yyval.dtype).final = 0;
+       ;}
+    break;
+
+  case 427:
+#line 6348 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.dtype).val = NewString("default");
+         (yyval.dtype).rawval = 0;
+         (yyval.dtype).type = T_STRING;
+         (yyval.dtype).qualifier = 0;
+         (yyval.dtype).refqualifier = 0;
+         (yyval.dtype).bitfield = 0;
+         (yyval.dtype).throws = 0;
+         (yyval.dtype).throwf = 0;
+         (yyval.dtype).nexcept = 0;
+         (yyval.dtype).final = 0;
+       ;}
+    break;
+
+  case 428:
+#line 6364 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = (yyvsp[(1) - (1)].id); ;}
+    break;
+
+  case 429:
+#line 6365 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = (char *) 0;;}
+    break;
+
+  case 437:
+#line 6384 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         Setattr((yyvsp[(1) - (2)].node),"_last",(yyvsp[(1) - (2)].node));
+         (yyval.node) = (yyvsp[(1) - (2)].node);
+       ;}
+    break;
+
+  case 438:
+#line 6388 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         set_nextSibling((yyvsp[(1) - (3)].node), (yyvsp[(2) - (3)].node));
+         Setattr((yyvsp[(1) - (3)].node),"_last",Getattr((yyvsp[(2) - (3)].node),"_last"));
+         Setattr((yyvsp[(2) - (3)].node),"_last",NULL);
+         (yyval.node) = (yyvsp[(1) - (3)].node);
+       ;}
+    break;
+
+  case 439:
+#line 6394 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.node) = 0;
+       ;}
+    break;
+
+  case 440:
+#line 6399 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         Setattr((yyvsp[(2) - (2)].node),"_last",(yyvsp[(2) - (2)].node));
+         (yyval.node) = (yyvsp[(2) - (2)].node);
+       ;}
+    break;
+
+  case 441:
+#line 6403 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         set_nextSibling(Getattr((yyvsp[(1) - (3)].node),"_last"), (yyvsp[(3) - (3)].node));
+         Setattr((yyvsp[(1) - (3)].node),"_last",(yyvsp[(3) - (3)].node));
+         (yyval.node) = (yyvsp[(1) - (3)].node);
+       ;}
+    break;
+
+  case 442:
+#line 6410 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.node) = (yyvsp[(2) - (3)].node);
+       ;}
+    break;
+
+  case 443:
+#line 6415 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.node) = (yyvsp[(1) - (1)].node);
+       ;}
+    break;
+
+  case 444:
+#line 6418 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.node) = (yyvsp[(2) - (2)].node);
+         set_comment((yyvsp[(2) - (2)].node), (yyvsp[(1) - (2)].str));
+       ;}
+    break;
+
+  case 445:
+#line 6422 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.node) = (yyvsp[(1) - (2)].node);
+         set_comment((yyvsp[(1) - (2)].node), (yyvsp[(2) - (2)].str));
+       ;}
+    break;
+
+  case 446:
+#line 6426 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.node) = (yyvsp[(2) - (2)].node);
+         set_comment(previousNode, (yyvsp[(1) - (2)].str));
+       ;}
+    break;
+
+  case 447:
+#line 6430 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.node) = (yyvsp[(2) - (3)].node);
+         set_comment(previousNode, (yyvsp[(1) - (3)].str));
+         set_comment((yyvsp[(2) - (3)].node), (yyvsp[(3) - (3)].str));
+       ;}
+    break;
+
+  case 448:
+#line 6437 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          SwigType *type = NewSwigType(T_INT);
+          (yyval.node) = new_node("enumitem");
+          Setattr((yyval.node),"name",(yyvsp[(1) - (1)].id));
+          Setattr((yyval.node),"type",type);
+          SetFlag((yyval.node),"feature:immutable");
+          Delete(type);
+        ;}
+    break;
+
+  case 449:
+#line 6445 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          SwigType *type = NewSwigType((yyvsp[(3) - (3)].dtype).type == T_BOOL ? T_BOOL : ((yyvsp[(3) - (3)].dtype).type == T_CHAR ? T_CHAR : T_INT));
+          (yyval.node) = new_node("enumitem");
+          Setattr((yyval.node),"name",(yyvsp[(1) - (3)].id));
+          Setattr((yyval.node),"type",type);
+          SetFlag((yyval.node),"feature:immutable");
+          Setattr((yyval.node),"enumvalue", (yyvsp[(3) - (3)].dtype).val);
+          Setattr((yyval.node),"value",(yyvsp[(1) - (3)].id));
+          Delete(type);
+                 ;}
+    break;
+
+  case 450:
+#line 6457 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.dtype) = (yyvsp[(1) - (1)].dtype);
+          if (((yyval.dtype).type != T_INT) && ((yyval.dtype).type != T_UINT) &&
+              ((yyval.dtype).type != T_LONG) && ((yyval.dtype).type != T_ULONG) &&
+              ((yyval.dtype).type != T_LONGLONG) && ((yyval.dtype).type != T_ULONGLONG) &&
+              ((yyval.dtype).type != T_SHORT) && ((yyval.dtype).type != T_USHORT) &&
+              ((yyval.dtype).type != T_SCHAR) && ((yyval.dtype).type != T_UCHAR) &&
+              ((yyval.dtype).type != T_CHAR) && ((yyval.dtype).type != T_BOOL)) {
+            Swig_error(cparse_file,cparse_line,"Type error. Expecting an integral type\n");
+          }
+                ;}
+    break;
+
+  case 451:
+#line 6472 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.dtype) = (yyvsp[(1) - (1)].dtype); ;}
+    break;
+
+  case 452:
+#line 6473 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        Node *n;
+        (yyval.dtype).val = (yyvsp[(1) - (1)].type);
+        (yyval.dtype).type = T_INT;
+        /* Check if value is in scope */
+        n = Swig_symbol_clookup((yyvsp[(1) - (1)].type),0);
+        if (n) {
+                   /* A band-aid for enum values used in expressions. */
+                   if (Strcmp(nodeType(n),"enumitem") == 0) {
+                     String *q = Swig_symbol_qualified(n);
+                     if (q) {
+                       (yyval.dtype).val = NewStringf("%s::%s", q, Getattr(n,"name"));
+                       Delete(q);
+                     }
+                   }
+        }
+               ;}
+    break;
+
+  case 453:
+#line 6493 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype).val = NewStringf("%s->%s", (yyvsp[(1) - (3)].id), (yyvsp[(3) - (3)].id));
+        (yyval.dtype).type = 0;
+          ;}
+    break;
+
+  case 454:
+#line 6497 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype) = (yyvsp[(1) - (3)].dtype);
+        Printf((yyval.dtype).val, "->%s", (yyvsp[(3) - (3)].id));
+          ;}
+    break;
+
+  case 455:
+#line 6507 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype) = (yyvsp[(1) - (3)].dtype);
+        Printf((yyval.dtype).val, ".%s", (yyvsp[(3) - (3)].id));
+          ;}
+    break;
+
+  case 456:
+#line 6513 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.dtype) = (yyvsp[(1) - (1)].dtype);
+               ;}
+    break;
+
+  case 457:
+#line 6516 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.dtype) = (yyvsp[(1) - (1)].dtype);
+               ;}
+    break;
+
+  case 458:
+#line 6519 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.dtype).val = (yyvsp[(1) - (1)].str);
+                    (yyval.dtype).type = T_STRING;
+               ;}
+    break;
+
+  case 459:
+#line 6523 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         SwigType_push((yyvsp[(3) - (5)].type),(yyvsp[(4) - (5)].decl).type);
+         (yyval.dtype).val = NewStringf("sizeof(%s)",SwigType_str((yyvsp[(3) - (5)].type),0));
+         (yyval.dtype).type = T_ULONG;
+               ;}
+    break;
+
+  case 460:
+#line 6528 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         SwigType_push((yyvsp[(6) - (8)].type),(yyvsp[(7) - (8)].decl).type);
+         (yyval.dtype).val = NewStringf("sizeof...(%s)",SwigType_str((yyvsp[(6) - (8)].type),0));
+         (yyval.dtype).type = T_ULONG;
+               ;}
+    break;
+
+  case 461:
+#line 6533 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.dtype) = (yyvsp[(1) - (1)].dtype); ;}
+    break;
+
+  case 462:
+#line 6534 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.dtype).val = (yyvsp[(1) - (1)].str);
+           (yyval.dtype).rawval = NewStringf("L\"%s\"", (yyval.dtype).val);
+                    (yyval.dtype).type = T_WSTRING;
+          ;}
+    break;
+
+  case 463:
+#line 6539 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.dtype).val = NewString((yyvsp[(1) - (1)].str));
+         if (Len((yyval.dtype).val)) {
+           (yyval.dtype).rawval = NewStringf("'%(escape)s'", (yyval.dtype).val);
+         } else {
+           (yyval.dtype).rawval = NewString("'\\0'");
+         }
+         (yyval.dtype).type = T_CHAR;
+         (yyval.dtype).bitfield = 0;
+         (yyval.dtype).throws = 0;
+         (yyval.dtype).throwf = 0;
+         (yyval.dtype).nexcept = 0;
+         (yyval.dtype).final = 0;
+          ;}
+    break;
+
+  case 464:
+#line 6553 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         (yyval.dtype).val = NewString((yyvsp[(1) - (1)].str));
+         if (Len((yyval.dtype).val)) {
+           (yyval.dtype).rawval = NewStringf("L\'%s\'", (yyval.dtype).val);
+         } else {
+           (yyval.dtype).rawval = NewString("L'\\0'");
+         }
+         (yyval.dtype).type = T_WCHAR;
+         (yyval.dtype).bitfield = 0;
+         (yyval.dtype).throws = 0;
+         (yyval.dtype).throwf = 0;
+         (yyval.dtype).nexcept = 0;
+         (yyval.dtype).final = 0;
+          ;}
+    break;
+
+  case 465:
+#line 6569 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.dtype).val = NewStringf("(%s)",(yyvsp[(2) - (3)].dtype).val);
+           if ((yyvsp[(2) - (3)].dtype).rawval) {
+             (yyval.dtype).rawval = NewStringf("(%s)",(yyvsp[(2) - (3)].dtype).rawval);
+           }
+           (yyval.dtype).type = (yyvsp[(2) - (3)].dtype).type;
+          ;}
+    break;
+
+  case 466:
+#line 6579 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.dtype) = (yyvsp[(4) - (4)].dtype);
+        if ((yyvsp[(4) - (4)].dtype).type != T_STRING) {
+          switch ((yyvsp[(2) - (4)].dtype).type) {
+            case T_FLOAT:
+            case T_DOUBLE:
+            case T_LONGDOUBLE:
+            case T_FLTCPLX:
+            case T_DBLCPLX:
+              (yyval.dtype).val = NewStringf("(%s)%s", (yyvsp[(2) - (4)].dtype).val, (yyvsp[(4) - (4)].dtype).val); /* SwigType_str and decimal points don't mix! */
+              break;
+            default:
+              (yyval.dtype).val = NewStringf("(%s) %s", SwigType_str((yyvsp[(2) - (4)].dtype).val,0), (yyvsp[(4) - (4)].dtype).val);
+              break;
+          }
+        }
+        (yyval.dtype).type = promote((yyvsp[(2) - (4)].dtype).type, (yyvsp[(4) - (4)].dtype).type);
+          ;}
+    break;
+
+  case 467:
+#line 6597 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.dtype) = (yyvsp[(5) - (5)].dtype);
+        if ((yyvsp[(5) - (5)].dtype).type != T_STRING) {
+          SwigType_push((yyvsp[(2) - (5)].dtype).val,(yyvsp[(3) - (5)].type));
+          (yyval.dtype).val = NewStringf("(%s) %s", SwigType_str((yyvsp[(2) - (5)].dtype).val,0), (yyvsp[(5) - (5)].dtype).val);
+        }
+          ;}
+    break;
+
+  case 468:
+#line 6604 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.dtype) = (yyvsp[(5) - (5)].dtype);
+        if ((yyvsp[(5) - (5)].dtype).type != T_STRING) {
+          SwigType_add_reference((yyvsp[(2) - (5)].dtype).val);
+          (yyval.dtype).val = NewStringf("(%s) %s", SwigType_str((yyvsp[(2) - (5)].dtype).val,0), (yyvsp[(5) - (5)].dtype).val);
+        }
+          ;}
+    break;
+
+  case 469:
+#line 6611 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.dtype) = (yyvsp[(5) - (5)].dtype);
+        if ((yyvsp[(5) - (5)].dtype).type != T_STRING) {
+          SwigType_add_rvalue_reference((yyvsp[(2) - (5)].dtype).val);
+          (yyval.dtype).val = NewStringf("(%s) %s", SwigType_str((yyvsp[(2) - (5)].dtype).val,0), (yyvsp[(5) - (5)].dtype).val);
+        }
+          ;}
+    break;
+
+  case 470:
+#line 6618 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.dtype) = (yyvsp[(6) - (6)].dtype);
+        if ((yyvsp[(6) - (6)].dtype).type != T_STRING) {
+          SwigType_push((yyvsp[(2) - (6)].dtype).val,(yyvsp[(3) - (6)].type));
+          SwigType_add_reference((yyvsp[(2) - (6)].dtype).val);
+          (yyval.dtype).val = NewStringf("(%s) %s", SwigType_str((yyvsp[(2) - (6)].dtype).val,0), (yyvsp[(6) - (6)].dtype).val);
+        }
+          ;}
+    break;
+
+  case 471:
+#line 6626 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.dtype) = (yyvsp[(6) - (6)].dtype);
+        if ((yyvsp[(6) - (6)].dtype).type != T_STRING) {
+          SwigType_push((yyvsp[(2) - (6)].dtype).val,(yyvsp[(3) - (6)].type));
+          SwigType_add_rvalue_reference((yyvsp[(2) - (6)].dtype).val);
+          (yyval.dtype).val = NewStringf("(%s) %s", SwigType_str((yyvsp[(2) - (6)].dtype).val,0), (yyvsp[(6) - (6)].dtype).val);
+        }
+          ;}
+    break;
+
+  case 472:
+#line 6634 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype) = (yyvsp[(2) - (2)].dtype);
+                 (yyval.dtype).val = NewStringf("&%s",(yyvsp[(2) - (2)].dtype).val);
+          ;}
+    break;
+
+  case 473:
+#line 6638 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype) = (yyvsp[(2) - (2)].dtype);
+                 (yyval.dtype).val = NewStringf("&&%s",(yyvsp[(2) - (2)].dtype).val);
+          ;}
+    break;
+
+  case 474:
+#line 6642 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype) = (yyvsp[(2) - (2)].dtype);
+                 (yyval.dtype).val = NewStringf("*%s",(yyvsp[(2) - (2)].dtype).val);
+          ;}
+    break;
+
+  case 475:
+#line 6648 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.dtype) = (yyvsp[(1) - (1)].dtype); ;}
+    break;
+
+  case 476:
+#line 6649 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.dtype) = (yyvsp[(1) - (1)].dtype); ;}
+    break;
+
+  case 477:
+#line 6650 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.dtype) = (yyvsp[(1) - (1)].dtype); ;}
+    break;
+
+  case 478:
+#line 6651 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.dtype) = (yyvsp[(1) - (1)].dtype); ;}
+    break;
+
+  case 479:
+#line 6652 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.dtype) = (yyvsp[(1) - (1)].dtype); ;}
+    break;
+
+  case 480:
+#line 6653 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.dtype) = (yyvsp[(1) - (1)].dtype); ;}
+    break;
+
+  case 481:
+#line 6654 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.dtype) = (yyvsp[(1) - (1)].dtype); ;}
+    break;
+
+  case 482:
+#line 6655 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.dtype) = (yyvsp[(1) - (1)].dtype); ;}
+    break;
+
+  case 483:
+#line 6658 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype).val = NewStringf("%s+%s", COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+        (yyval.dtype).type = promote((yyvsp[(1) - (3)].dtype).type,(yyvsp[(3) - (3)].dtype).type);
+          ;}
+    break;
+
+  case 484:
+#line 6662 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype).val = NewStringf("%s-%s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+        (yyval.dtype).type = promote((yyvsp[(1) - (3)].dtype).type,(yyvsp[(3) - (3)].dtype).type);
+          ;}
+    break;
+
+  case 485:
+#line 6666 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype).val = NewStringf("%s*%s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+        (yyval.dtype).type = promote((yyvsp[(1) - (3)].dtype).type,(yyvsp[(3) - (3)].dtype).type);
+          ;}
+    break;
+
+  case 486:
+#line 6670 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype).val = NewStringf("%s/%s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+        (yyval.dtype).type = promote((yyvsp[(1) - (3)].dtype).type,(yyvsp[(3) - (3)].dtype).type);
+          ;}
+    break;
+
+  case 487:
+#line 6674 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype).val = NewStringf("%s%%%s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+        (yyval.dtype).type = promote((yyvsp[(1) - (3)].dtype).type,(yyvsp[(3) - (3)].dtype).type);
+          ;}
+    break;
+
+  case 488:
+#line 6678 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype).val = NewStringf("%s&%s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+        (yyval.dtype).type = promote((yyvsp[(1) - (3)].dtype).type,(yyvsp[(3) - (3)].dtype).type);
+          ;}
+    break;
+
+  case 489:
+#line 6682 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype).val = NewStringf("%s|%s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+        (yyval.dtype).type = promote((yyvsp[(1) - (3)].dtype).type,(yyvsp[(3) - (3)].dtype).type);
+          ;}
+    break;
+
+  case 490:
+#line 6686 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype).val = NewStringf("%s^%s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+        (yyval.dtype).type = promote((yyvsp[(1) - (3)].dtype).type,(yyvsp[(3) - (3)].dtype).type);
+          ;}
+    break;
+
+  case 491:
+#line 6690 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype).val = NewStringf("%s << %s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+        (yyval.dtype).type = promote_type((yyvsp[(1) - (3)].dtype).type);
+          ;}
+    break;
+
+  case 492:
+#line 6694 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype).val = NewStringf("%s >> %s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+        (yyval.dtype).type = promote_type((yyvsp[(1) - (3)].dtype).type);
+          ;}
+    break;
+
+  case 493:
+#line 6698 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype).val = NewStringf("%s&&%s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+        (yyval.dtype).type = cparse_cplusplus ? T_BOOL : T_INT;
+          ;}
+    break;
+
+  case 494:
+#line 6702 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype).val = NewStringf("%s||%s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+        (yyval.dtype).type = cparse_cplusplus ? T_BOOL : T_INT;
+          ;}
+    break;
+
+  case 495:
+#line 6706 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype).val = NewStringf("%s==%s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+        (yyval.dtype).type = cparse_cplusplus ? T_BOOL : T_INT;
+          ;}
+    break;
+
+  case 496:
+#line 6710 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype).val = NewStringf("%s!=%s",COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)),COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+        (yyval.dtype).type = cparse_cplusplus ? T_BOOL : T_INT;
+          ;}
+    break;
+
+  case 497:
+#line 6724 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype).val = NewStringf("%s >= %s", COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)), COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+        (yyval.dtype).type = cparse_cplusplus ? T_BOOL : T_INT;
+          ;}
+    break;
+
+  case 498:
+#line 6728 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype).val = NewStringf("%s <= %s", COMPOUND_EXPR_VAL((yyvsp[(1) - (3)].dtype)), COMPOUND_EXPR_VAL((yyvsp[(3) - (3)].dtype)));
+        (yyval.dtype).type = cparse_cplusplus ? T_BOOL : T_INT;
+          ;}
+    break;
+
+  case 499:
+#line 6732 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype).val = NewStringf("%s?%s:%s", COMPOUND_EXPR_VAL((yyvsp[(1) - (5)].dtype)), COMPOUND_EXPR_VAL((yyvsp[(3) - (5)].dtype)), COMPOUND_EXPR_VAL((yyvsp[(5) - (5)].dtype)));
+        /* This may not be exactly right, but is probably good enough
+         * for the purposes of parsing constant expressions. */
+        (yyval.dtype).type = promote((yyvsp[(3) - (5)].dtype).type, (yyvsp[(5) - (5)].dtype).type);
+          ;}
+    break;
+
+  case 500:
+#line 6738 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype).val = NewStringf("-%s",(yyvsp[(2) - (2)].dtype).val);
+        (yyval.dtype).type = (yyvsp[(2) - (2)].dtype).type;
+          ;}
+    break;
+
+  case 501:
+#line 6742 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.dtype).val = NewStringf("+%s",(yyvsp[(2) - (2)].dtype).val);
+        (yyval.dtype).type = (yyvsp[(2) - (2)].dtype).type;
+          ;}
+    break;
+
+  case 502:
+#line 6746 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.dtype).val = NewStringf("~%s",(yyvsp[(2) - (2)].dtype).val);
+        (yyval.dtype).type = (yyvsp[(2) - (2)].dtype).type;
+          ;}
+    break;
+
+  case 503:
+#line 6750 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.dtype).val = NewStringf("!%s",COMPOUND_EXPR_VAL((yyvsp[(2) - (2)].dtype)));
+        (yyval.dtype).type = T_INT;
+          ;}
+    break;
+
+  case 504:
+#line 6754 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        String *qty;
+                 skip_balanced('(',')');
+        qty = Swig_symbol_type_qualify((yyvsp[(1) - (2)].type),0);
+        if (SwigType_istemplate(qty)) {
+          String *nstr = SwigType_namestr(qty);
+          Delete(qty);
+          qty = nstr;
+        }
+        (yyval.dtype).val = NewStringf("%s%s",qty,scanner_ccode);
+        Clear(scanner_ccode);
+        (yyval.dtype).type = T_INT;
+        Delete(qty);
+               ;}
+    break;
+
+  case 505:
+#line 6770 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.str) = NewString("...");
+         ;}
+    break;
+
+  case 506:
+#line 6775 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.str) = (yyvsp[(1) - (1)].str);
+         ;}
+    break;
+
+  case 507:
+#line 6778 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.str) = 0;
+         ;}
+    break;
+
+  case 508:
+#line 6783 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.bases) = (yyvsp[(1) - (1)].bases);
+               ;}
+    break;
+
+  case 509:
+#line 6788 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { inherit_list = 1; ;}
+    break;
+
+  case 510:
+#line 6788 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.bases) = (yyvsp[(3) - (3)].bases); inherit_list = 0; ;}
+    break;
+
+  case 511:
+#line 6789 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.bases) = 0; ;}
+    break;
+
+  case 512:
+#line 6792 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          Hash *list = NewHash();
+          Node *base = (yyvsp[(1) - (1)].node);
+          Node *name = Getattr(base,"name");
+          List *lpublic = NewList();
+          List *lprotected = NewList();
+          List *lprivate = NewList();
+          Setattr(list,"public",lpublic);
+          Setattr(list,"protected",lprotected);
+          Setattr(list,"private",lprivate);
+          Delete(lpublic);
+          Delete(lprotected);
+          Delete(lprivate);
+          Append(Getattr(list,Getattr(base,"access")),name);
+              (yyval.bases) = list;
+               ;}
+    break;
+
+  case 513:
+#line 6809 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          Hash *list = (yyvsp[(1) - (3)].bases);
+          Node *base = (yyvsp[(3) - (3)].node);
+          Node *name = Getattr(base,"name");
+          Append(Getattr(list,Getattr(base,"access")),name);
+                   (yyval.bases) = list;
+               ;}
+    break;
+
+  case 514:
+#line 6818 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.intvalue) = cparse_line;
+          ;}
+    break;
+
+  case 515:
+#line 6820 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.node) = NewHash();
+        Setfile((yyval.node),cparse_file);
+        Setline((yyval.node),(yyvsp[(2) - (4)].intvalue));
+        Setattr((yyval.node),"name",(yyvsp[(3) - (4)].str));
+        Setfile((yyvsp[(3) - (4)].str),cparse_file);
+        Setline((yyvsp[(3) - (4)].str),(yyvsp[(2) - (4)].intvalue));
+                 if (last_cpptype && (Strcmp(last_cpptype,"struct") != 0)) {
+          Setattr((yyval.node),"access","private");
+          Swig_warning(WARN_PARSE_NO_ACCESS, Getfile((yyval.node)), Getline((yyval.node)), "No access specifier given for base class '%s' (ignored).\n", SwigType_namestr((yyvsp[(3) - (4)].str)));
+                 } else {
+          Setattr((yyval.node),"access","public");
+        }
+        if ((yyvsp[(4) - (4)].str))
+          SetFlag((yyval.node), "variadic");
+               ;}
+    break;
+
+  case 516:
+#line 6836 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.intvalue) = cparse_line;
+          ;}
+    break;
+
+  case 517:
+#line 6838 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.node) = NewHash();
+        Setfile((yyval.node),cparse_file);
+        Setline((yyval.node),(yyvsp[(3) - (6)].intvalue));
+        Setattr((yyval.node),"name",(yyvsp[(5) - (6)].str));
+        Setfile((yyvsp[(5) - (6)].str),cparse_file);
+        Setline((yyvsp[(5) - (6)].str),(yyvsp[(3) - (6)].intvalue));
+        Setattr((yyval.node),"access",(yyvsp[(2) - (6)].id));
+            if (Strcmp((yyvsp[(2) - (6)].id),"public") != 0) {
+          Swig_warning(WARN_PARSE_PRIVATE_INHERIT, Getfile((yyval.node)), Getline((yyval.node)), "%s inheritance from base '%s' (ignored).\n", (yyvsp[(2) - (6)].id), SwigType_namestr((yyvsp[(5) - (6)].str)));
+        }
+        if ((yyvsp[(6) - (6)].str))
+          SetFlag((yyval.node), "variadic");
+               ;}
+    break;
+
+  case 518:
+#line 6854 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = (char*)"public"; ;}
+    break;
+
+  case 519:
+#line 6855 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = (char*)"private"; ;}
+    break;
+
+  case 520:
+#line 6856 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = (char*)"protected"; ;}
+    break;
+
+  case 521:
+#line 6859 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.id) = (char*)"class";
+          if (!inherit_list) last_cpptype = (yyval.id);
+               ;}
+    break;
+
+  case 522:
+#line 6863 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.id) = (char *)"typename";
+          if (!inherit_list) last_cpptype = (yyval.id);
+               ;}
+    break;
+
+  case 523:
+#line 6867 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.id) = (char *)"class...";
+          if (!inherit_list) last_cpptype = (yyval.id);
+               ;}
+    break;
+
+  case 524:
+#line 6871 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.id) = (char *)"typename...";
+          if (!inherit_list) last_cpptype = (yyval.id);
+               ;}
+    break;
+
+  case 525:
+#line 6877 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.id) = (yyvsp[(1) - (1)].id);
+               ;}
+    break;
+
+  case 526:
+#line 6880 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.id) = (char*)"struct";
+          if (!inherit_list) last_cpptype = (yyval.id);
+               ;}
+    break;
+
+  case 527:
+#line 6884 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.id) = (char*)"union";
+          if (!inherit_list) last_cpptype = (yyval.id);
+               ;}
+    break;
+
+  case 528:
+#line 6890 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.id) = (char*)"class";
+          if (!inherit_list) last_cpptype = (yyval.id);
+               ;}
+    break;
+
+  case 529:
+#line 6894 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.id) = (char*)"struct";
+          if (!inherit_list) last_cpptype = (yyval.id);
+               ;}
+    break;
+
+  case 530:
+#line 6898 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.id) = (char*)"union";
+          if (!inherit_list) last_cpptype = (yyval.id);
+               ;}
+    break;
+
+  case 531:
+#line 6904 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          (yyval.id) = (yyvsp[(1) - (1)].id);
+               ;}
+    break;
+
+  case 532:
+#line 6907 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+          (yyval.id) = 0;
+               ;}
+    break;
+
+  case 535:
+#line 6916 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.str) = 0;
+          ;}
+    break;
+
+  case 536:
+#line 6919 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.str) = NewString("1");
+          ;}
+    break;
+
+  case 537:
+#line 6922 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.str) = NewString("1");
+          ;}
+    break;
+
+  case 538:
+#line 6925 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.str) = NewString("1");
+          ;}
+    break;
+
+  case 539:
+#line 6930 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.str) = (yyvsp[(1) - (1)].str);
+               ;}
+    break;
+
+  case 540:
+#line 6933 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.str) = 0;
+               ;}
+    break;
+
+  case 541:
+#line 6938 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.dtype).throws = (yyvsp[(3) - (4)].pl);
+                    (yyval.dtype).throwf = NewString("1");
+                    (yyval.dtype).nexcept = 0;
+                    (yyval.dtype).final = 0;
+          ;}
+    break;
+
+  case 542:
+#line 6944 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.dtype).throws = 0;
+                    (yyval.dtype).throwf = 0;
+                    (yyval.dtype).nexcept = NewString("true");
+                    (yyval.dtype).final = 0;
+          ;}
+    break;
+
+  case 543:
+#line 6950 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.dtype).throws = 0;
+                    (yyval.dtype).throwf = 0;
+                    (yyval.dtype).nexcept = 0;
+                    (yyval.dtype).final = (yyvsp[(1) - (1)].str);
+          ;}
+    break;
+
+  case 544:
+#line 6956 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.dtype).throws = (yyvsp[(3) - (5)].pl);
+                    (yyval.dtype).throwf = NewString("1");
+                    (yyval.dtype).nexcept = 0;
+                    (yyval.dtype).final = (yyvsp[(5) - (5)].str);
+          ;}
+    break;
+
+  case 545:
+#line 6962 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.dtype).throws = 0;
+                    (yyval.dtype).throwf = 0;
+                    (yyval.dtype).nexcept = NewString("true");
+                    (yyval.dtype).final = (yyvsp[(2) - (2)].str);
+          ;}
+    break;
+
+  case 546:
+#line 6968 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.dtype).throws = 0;
+                    (yyval.dtype).throwf = 0;
+                    (yyval.dtype).nexcept = (yyvsp[(3) - (4)].dtype).val;
+                    (yyval.dtype).final = 0;
+          ;}
+    break;
+
+  case 547:
+#line 6976 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.dtype).throws = 0;
+                    (yyval.dtype).throwf = 0;
+                    (yyval.dtype).nexcept = 0;
+                    (yyval.dtype).final = 0;
+                    (yyval.dtype).qualifier = (yyvsp[(1) - (1)].dtype).qualifier;
+                    (yyval.dtype).refqualifier = (yyvsp[(1) - (1)].dtype).refqualifier;
+               ;}
+    break;
+
+  case 548:
+#line 6984 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.dtype) = (yyvsp[(1) - (1)].dtype);
+                    (yyval.dtype).qualifier = 0;
+                    (yyval.dtype).refqualifier = 0;
+               ;}
+    break;
+
+  case 549:
+#line 6989 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+           (yyval.dtype) = (yyvsp[(2) - (2)].dtype);
+                    (yyval.dtype).qualifier = (yyvsp[(1) - (2)].dtype).qualifier;
+                    (yyval.dtype).refqualifier = (yyvsp[(1) - (2)].dtype).refqualifier;
+               ;}
+    break;
+
+  case 550:
+#line 6996 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.dtype) = (yyvsp[(1) - (1)].dtype);
+               ;}
+    break;
+
+  case 551:
+#line 6999 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.dtype).throws = 0;
+                    (yyval.dtype).throwf = 0;
+                    (yyval.dtype).nexcept = 0;
+                    (yyval.dtype).final = 0;
+                    (yyval.dtype).qualifier = 0;
+                    (yyval.dtype).refqualifier = 0;
+               ;}
+    break;
+
+  case 552:
+#line 7009 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    Clear(scanner_ccode);
+                    (yyval.decl).have_parms = 0;
+                    (yyval.decl).defarg = 0;
+           (yyval.decl).throws = (yyvsp[(1) - (3)].dtype).throws;
+           (yyval.decl).throwf = (yyvsp[(1) - (3)].dtype).throwf;
+           (yyval.decl).nexcept = (yyvsp[(1) - (3)].dtype).nexcept;
+           (yyval.decl).final = (yyvsp[(1) - (3)].dtype).final;
+                    if ((yyvsp[(1) - (3)].dtype).qualifier)
+                      Swig_error(cparse_file, cparse_line, "Constructor cannot have a qualifier.\n");
+               ;}
+    break;
+
+  case 553:
+#line 7020 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    skip_balanced('{','}');
+                    (yyval.decl).have_parms = 0;
+                    (yyval.decl).defarg = 0;
+                    (yyval.decl).throws = (yyvsp[(1) - (3)].dtype).throws;
+                    (yyval.decl).throwf = (yyvsp[(1) - (3)].dtype).throwf;
+                    (yyval.decl).nexcept = (yyvsp[(1) - (3)].dtype).nexcept;
+                    (yyval.decl).final = (yyvsp[(1) - (3)].dtype).final;
+                    if ((yyvsp[(1) - (3)].dtype).qualifier)
+                      Swig_error(cparse_file, cparse_line, "Constructor cannot have a qualifier.\n");
+               ;}
+    break;
+
+  case 554:
+#line 7031 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    Clear(scanner_ccode);
+                    (yyval.decl).parms = (yyvsp[(2) - (4)].pl);
+                    (yyval.decl).have_parms = 1;
+                    (yyval.decl).defarg = 0;
+           (yyval.decl).throws = 0;
+           (yyval.decl).throwf = 0;
+           (yyval.decl).nexcept = 0;
+           (yyval.decl).final = 0;
+               ;}
+    break;
+
+  case 555:
+#line 7041 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    skip_balanced('{','}');
+                    (yyval.decl).parms = (yyvsp[(2) - (4)].pl);
+                    (yyval.decl).have_parms = 1;
+                    (yyval.decl).defarg = 0;
+                    (yyval.decl).throws = 0;
+                    (yyval.decl).throwf = 0;
+                    (yyval.decl).nexcept = 0;
+                    (yyval.decl).final = 0;
+               ;}
+    break;
+
+  case 556:
+#line 7051 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.decl).have_parms = 0;
+                    (yyval.decl).defarg = (yyvsp[(2) - (3)].dtype).val;
+                    (yyval.decl).throws = 0;
+                    (yyval.decl).throwf = 0;
+                    (yyval.decl).nexcept = 0;
+                    (yyval.decl).final = 0;
+               ;}
+    break;
+
+  case 557:
+#line 7059 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                    (yyval.decl).have_parms = 0;
+                    (yyval.decl).defarg = (yyvsp[(3) - (4)].dtype).val;
+                    (yyval.decl).throws = (yyvsp[(1) - (4)].dtype).throws;
+                    (yyval.decl).throwf = (yyvsp[(1) - (4)].dtype).throwf;
+                    (yyval.decl).nexcept = (yyvsp[(1) - (4)].dtype).nexcept;
+                    (yyval.decl).final = (yyvsp[(1) - (4)].dtype).final;
+                    if ((yyvsp[(1) - (4)].dtype).qualifier)
+                      Swig_error(cparse_file, cparse_line, "Constructor cannot have a qualifier.\n");
+               ;}
+    break;
+
+  case 564:
+#line 7081 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         skip_balanced('(',')');
+         Clear(scanner_ccode);
+       ;}
+    break;
+
+  case 565:
+#line 7093 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+         skip_balanced('{','}');
+         Clear(scanner_ccode);
+       ;}
+    break;
+
+  case 566:
+#line 7099 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                     String *s = NewStringEmpty();
+                     SwigType_add_template(s,(yyvsp[(2) - (3)].p));
+                     (yyval.id) = Char(s);
+            scanner_last_id(1);
+                ;}
+    break;
+
+  case 567:
+#line 7108 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = (yyvsp[(1) - (1)].id); ;}
+    break;
+
+  case 568:
+#line 7109 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = Swig_copy_string("override"); ;}
+    break;
+
+  case 569:
+#line 7110 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = Swig_copy_string("final"); ;}
+    break;
+
+  case 570:
+#line 7113 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = (yyvsp[(1) - (1)].id); ;}
+    break;
+
+  case 571:
+#line 7114 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = Char((yyvsp[(1) - (1)].dtype).val); ;}
+    break;
+
+  case 572:
+#line 7115 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = Char((yyvsp[(1) - (1)].str)); ;}
+    break;
+
+  case 573:
+#line 7118 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = (yyvsp[(1) - (1)].id); ;}
+    break;
+
+  case 574:
+#line 7119 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.id) = 0; ;}
+    break;
+
+  case 575:
+#line 7122 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                  (yyval.str) = 0;
+         if (!(yyval.str)) (yyval.str) = NewStringf("%s%s", (yyvsp[(1) - (2)].str),(yyvsp[(2) - (2)].str));
+                 Delete((yyvsp[(2) - (2)].str));
+               ;}
+    break;
+
+  case 576:
+#line 7127 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.str) = NewStringf("::%s%s",(yyvsp[(3) - (4)].str),(yyvsp[(4) - (4)].str));
+                 Delete((yyvsp[(4) - (4)].str));
+               ;}
+    break;
+
+  case 577:
+#line 7131 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.str) = NewString((yyvsp[(1) - (1)].str));
+              ;}
+    break;
+
+  case 578:
+#line 7134 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.str) = NewStringf("::%s",(yyvsp[(3) - (3)].str));
+               ;}
+    break;
+
+  case 579:
+#line 7137 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.str) = NewStringf("%s", (yyvsp[(1) - (1)].str));
+          ;}
+    break;
+
+  case 580:
+#line 7140 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.str) = NewStringf("%s%s", (yyvsp[(1) - (2)].str), (yyvsp[(2) - (2)].id));
+          ;}
+    break;
+
+  case 581:
+#line 7143 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.str) = NewStringf("::%s",(yyvsp[(3) - (3)].str));
+               ;}
+    break;
+
+  case 582:
+#line 7148 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.str) = NewStringf("::%s%s",(yyvsp[(2) - (3)].str),(yyvsp[(3) - (3)].str));
+          Delete((yyvsp[(3) - (3)].str));
+               ;}
+    break;
+
+  case 583:
+#line 7152 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.str) = NewStringf("::%s",(yyvsp[(2) - (2)].str));
+               ;}
+    break;
+
+  case 584:
+#line 7155 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.str) = NewStringf("::%s",(yyvsp[(2) - (2)].str));
+               ;}
+    break;
+
+  case 585:
+#line 7162 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.str) = NewStringf("::~%s",(yyvsp[(2) - (2)].str));
+               ;}
+    break;
+
+  case 586:
+#line 7168 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+       (yyval.str) = NewStringf("%s", (yyvsp[(1) - (1)].id));
+         ;}
+    break;
+
+  case 587:
+#line 7171 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+       (yyval.str) = NewStringf("%s%s", (yyvsp[(1) - (2)].id), (yyvsp[(2) - (2)].id));
+         ;}
+    break;
+
+  case 588:
+#line 7176 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+       (yyval.str) = (yyvsp[(1) - (1)].str);
+         ;}
+    break;
+
+  case 589:
+#line 7179 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+       (yyval.str) = NewStringf("%s%s", (yyvsp[(2) - (3)].id), (yyvsp[(3) - (3)].id));
+         ;}
+    break;
+
+  case 590:
+#line 7185 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                  (yyval.str) = 0;
+         if (!(yyval.str)) (yyval.str) = NewStringf("%s%s", (yyvsp[(1) - (2)].id),(yyvsp[(2) - (2)].str));
+                 Delete((yyvsp[(2) - (2)].str));
+               ;}
+    break;
+
+  case 591:
+#line 7190 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.str) = NewStringf("::%s%s",(yyvsp[(3) - (4)].id),(yyvsp[(4) - (4)].str));
+                 Delete((yyvsp[(4) - (4)].str));
+               ;}
+    break;
+
+  case 592:
+#line 7194 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.str) = NewString((yyvsp[(1) - (1)].id));
+              ;}
+    break;
+
+  case 593:
+#line 7197 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.str) = NewStringf("::%s",(yyvsp[(3) - (3)].id));
+               ;}
+    break;
+
+  case 594:
+#line 7200 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.str) = NewString((yyvsp[(1) - (1)].str));
+          ;}
+    break;
+
+  case 595:
+#line 7203 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.str) = NewStringf("::%s",(yyvsp[(3) - (3)].str));
+               ;}
+    break;
+
+  case 596:
+#line 7208 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.str) = NewStringf("::%s%s",(yyvsp[(2) - (3)].id),(yyvsp[(3) - (3)].str));
+          Delete((yyvsp[(3) - (3)].str));
+               ;}
+    break;
+
+  case 597:
+#line 7212 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.str) = NewStringf("::%s",(yyvsp[(2) - (2)].id));
+               ;}
+    break;
+
+  case 598:
+#line 7215 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.str) = NewStringf("::%s",(yyvsp[(2) - (2)].str));
+               ;}
+    break;
+
+  case 599:
+#line 7218 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.str) = NewStringf("::~%s",(yyvsp[(2) - (2)].id));
+               ;}
+    break;
+
+  case 600:
+#line 7224 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.str) = NewStringf("%s%s", (yyvsp[(1) - (2)].str), (yyvsp[(2) - (2)].id));
+               ;}
+    break;
+
+  case 601:
+#line 7227 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.str) = NewString((yyvsp[(1) - (1)].id));;}
+    break;
+
+  case 602:
+#line 7230 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                   (yyval.str) = NewStringf("%s%s", (yyvsp[(1) - (2)].str), (yyvsp[(2) - (2)].id));
+               ;}
+    break;
+
+  case 603:
+#line 7238 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.str) = NewString((yyvsp[(1) - (1)].id));;}
+    break;
+
+  case 604:
+#line 7241 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.str) = (yyvsp[(1) - (1)].str);
+               ;}
+    break;
+
+  case 605:
+#line 7244 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                  skip_balanced('{','}');
+         (yyval.str) = NewString(scanner_ccode);
+               ;}
+    break;
+
+  case 606:
+#line 7248 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.str) = (yyvsp[(1) - (1)].str);
+              ;}
+    break;
+
+  case 607:
+#line 7253 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                  Hash *n;
+                  (yyval.node) = NewHash();
+                  n = (yyvsp[(2) - (3)].node);
+                  while(n) {
+                     String *name, *value;
+                     name = Getattr(n,"name");
+                     value = Getattr(n,"value");
+            if (!value) value = (String *) "1";
+                     Setattr((yyval.node),name, value);
+            n = nextSibling(n);
+         }
+               ;}
+    break;
+
+  case 608:
+#line 7266 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    { (yyval.node) = 0; ;}
+    break;
+
+  case 609:
+#line 7270 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.node) = NewHash();
+        Setattr((yyval.node),"name",(yyvsp[(1) - (3)].id));
+        Setattr((yyval.node),"value",(yyvsp[(3) - (3)].str));
+               ;}
+    break;
+
+  case 610:
+#line 7275 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.node) = NewHash();
+        Setattr((yyval.node),"name",(yyvsp[(1) - (5)].id));
+        Setattr((yyval.node),"value",(yyvsp[(3) - (5)].str));
+        set_nextSibling((yyval.node),(yyvsp[(5) - (5)].node));
+               ;}
+    break;
+
+  case 611:
+#line 7281 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.node) = NewHash();
+                 Setattr((yyval.node),"name",(yyvsp[(1) - (1)].id));
+          ;}
+    break;
+
+  case 612:
+#line 7285 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.node) = NewHash();
+                 Setattr((yyval.node),"name",(yyvsp[(1) - (3)].id));
+                 set_nextSibling((yyval.node),(yyvsp[(3) - (3)].node));
+               ;}
+    break;
+
+  case 613:
+#line 7290 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.node) = (yyvsp[(3) - (3)].node);
+        Setattr((yyval.node),"name",(yyvsp[(1) - (3)].id));
+               ;}
+    break;
+
+  case 614:
+#line 7294 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.node) = (yyvsp[(3) - (5)].node);
+        Setattr((yyval.node),"name",(yyvsp[(1) - (5)].id));
+        set_nextSibling((yyval.node),(yyvsp[(5) - (5)].node));
+               ;}
+    break;
+
+  case 615:
+#line 7301 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+        (yyval.str) = (yyvsp[(1) - (1)].str);
+               ;}
+    break;
+
+  case 616:
+#line 7304 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+    {
+                 (yyval.str) = Char((yyvsp[(1) - (1)].dtype).val);
+               ;}
+    break;
+
+
+/* Line 1267 of yacc.c.  */
+#line 12517 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig-build/Source/CParse/parser.c"
+      default: break;
+    }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if ! YYERROR_VERBOSE
+      yyerror (YY_("syntax error"));
+#else
+      {
+   YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+   if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+     {
+       YYSIZE_T yyalloc = 2 * yysize;
+       if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+         yyalloc = YYSTACK_ALLOC_MAXIMUM;
+       if (yymsg != yymsgbuf)
+         YYSTACK_FREE (yymsg);
+       yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+       if (yymsg)
+         yymsg_alloc = yyalloc;
+       else
+         {
+       yymsg = yymsgbuf;
+       yymsg_alloc = sizeof yymsgbuf;
+         }
+     }
+
+   if (0 < yysize && yysize <= yymsg_alloc)
+     {
+       (void) yysyntax_error (yymsg, yystate, yychar);
+       yyerror (yymsg);
+     }
+   else
+     {
+       yyerror (YY_("syntax error"));
+       if (yysize != 0)
+         goto yyexhaustedlab;
+     }
+      }
+#endif
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse look-ahead token after an
+    error, discard it.  */
+
+      if (yychar <= YYEOF)
+   {
+     /* Return failure if at end of input.  */
+     if (yychar == YYEOF)
+       YYABORT;
+   }
+      else
+   {
+     yydestruct ("Error: discarding",
+             yytoken, &yylval);
+     yychar = YYEMPTY;
+   }
+    }
+
+  /* Else will try to reuse look-ahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (/*CONSTCOND*/ 0)
+     goto yyerrorlab;
+
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3; /* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+   {
+     yyn += YYTERROR;
+     if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+       {
+         yyn = yytable[yyn];
+         if (0 < yyn)
+       break;
+       }
+   }
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+   YYABORT;
+
+
+      yydestruct ("Error: popping",
+         yystos[yystate], yyvsp);
+      YYPOPSTACK (1);
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token.  */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#ifndef yyoverflow
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+        yytoken, &yylval);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+         yystos[*yyssp], yyvsp);
+      YYPOPSTACK (1);
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
+}
+
+
+#line 7311 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+
+
+SwigType *Swig_cparse_type(String *s) {
+   String *ns;
+   ns = NewStringf("%s;",s);
+   Seek(ns,0,SEEK_SET);
+   scanner_file(ns);
+   top = 0;
+   scanner_next_token(PARSETYPE);
+   yyparse();
+   /*   Printf(stdout,"typeparse: '%s' ---> '%s'\n", s, top); */
+   return top;
+}
+
+
+Parm *Swig_cparse_parm(String *s) {
+   String *ns;
+   ns = NewStringf("%s;",s);
+   Seek(ns,0,SEEK_SET);
+   scanner_file(ns);
+   top = 0;
+   scanner_next_token(PARSEPARM);
+   yyparse();
+   /*   Printf(stdout,"typeparse: '%s' ---> '%s'\n", s, top); */
+   Delete(ns);
+   return top;
+}
+
+
+ParmList *Swig_cparse_parms(String *s, Node *file_line_node) {
+   String *ns;
+   char *cs = Char(s);
+   if (cs && cs[0] != '(') {
+     ns = NewStringf("(%s);",s);
+   } else {
+     ns = NewStringf("%s;",s);
+   }
+   Setfile(ns, Getfile(file_line_node));
+   Setline(ns, Getline(file_line_node));
+   Seek(ns,0,SEEK_SET);
+   scanner_file(ns);
+   top = 0;
+   scanner_next_token(PARSEPARMS);
+   yyparse();
+   /*   Printf(stdout,"typeparse: '%s' ---> '%s'\n", s, top); */
+   return top;
+}
+
+
diff --git a/Source/CParse/parser.h b/Source/CParse/parser.h
new file mode 100644
index 000000000..bfafa72c5
--- /dev/null
+++ b/Source/CParse/parser.h
@@ -0,0 +1,388 @@
+/* A Bison parser, made by GNU Bison 2.3.  */
+
+/* Skeleton interface for Bison's Yacc-like parsers in C
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
+
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     ID = 258,
+     HBLOCK = 259,
+     POUND = 260,
+     STRING = 261,
+     WSTRING = 262,
+     INCLUDE = 263,
+     IMPORT = 264,
+     INSERT = 265,
+     CHARCONST = 266,
+     WCHARCONST = 267,
+     NUM_INT = 268,
+     NUM_FLOAT = 269,
+     NUM_UNSIGNED = 270,
+     NUM_LONG = 271,
+     NUM_ULONG = 272,
+     NUM_LONGLONG = 273,
+     NUM_ULONGLONG = 274,
+     NUM_BOOL = 275,
+     TYPEDEF = 276,
+     TYPE_INT = 277,
+     TYPE_UNSIGNED = 278,
+     TYPE_SHORT = 279,
+     TYPE_LONG = 280,
+     TYPE_FLOAT = 281,
+     TYPE_DOUBLE = 282,
+     TYPE_CHAR = 283,
+     TYPE_WCHAR = 284,
+     TYPE_VOID = 285,
+     TYPE_SIGNED = 286,
+     TYPE_BOOL = 287,
+     TYPE_COMPLEX = 288,
+     TYPE_TYPEDEF = 289,
+     TYPE_RAW = 290,
+     TYPE_NON_ISO_INT8 = 291,
+     TYPE_NON_ISO_INT16 = 292,
+     TYPE_NON_ISO_INT32 = 293,
+     TYPE_NON_ISO_INT64 = 294,
+     LPAREN = 295,
+     RPAREN = 296,
+     COMMA = 297,
+     SEMI = 298,
+     EXTERN = 299,
+     INIT = 300,
+     LBRACE = 301,
+     RBRACE = 302,
+     PERIOD = 303,
+     CONST_QUAL = 304,
+     VOLATILE = 305,
+     REGISTER = 306,
+     STRUCT = 307,
+     UNION = 308,
+     EQUAL = 309,
+     SIZEOF = 310,
+     MODULE = 311,
+     LBRACKET = 312,
+     RBRACKET = 313,
+     BEGINFILE = 314,
+     ENDOFFILE = 315,
+     ILLEGAL = 316,
+     CONSTANT = 317,
+     NAME = 318,
+     RENAME = 319,
+     NAMEWARN = 320,
+     EXTEND = 321,
+     PRAGMA = 322,
+     FEATURE = 323,
+     VARARGS = 324,
+     ENUM = 325,
+     CLASS = 326,
+     TYPENAME = 327,
+     PRIVATE = 328,
+     PUBLIC = 329,
+     PROTECTED = 330,
+     COLON = 331,
+     STATIC = 332,
+     VIRTUAL = 333,
+     FRIEND = 334,
+     THROW = 335,
+     CATCH = 336,
+     EXPLICIT = 337,
+     STATIC_ASSERT = 338,
+     CONSTEXPR = 339,
+     THREAD_LOCAL = 340,
+     DECLTYPE = 341,
+     AUTO = 342,
+     NOEXCEPT = 343,
+     OVERRIDE = 344,
+     FINAL = 345,
+     USING = 346,
+     NAMESPACE = 347,
+     NATIVE = 348,
+     INLINE = 349,
+     TYPEMAP = 350,
+     EXCEPT = 351,
+     ECHO = 352,
+     APPLY = 353,
+     CLEAR = 354,
+     SWIGTEMPLATE = 355,
+     FRAGMENT = 356,
+     WARN = 357,
+     LESSTHAN = 358,
+     GREATERTHAN = 359,
+     DELETE_KW = 360,
+     DEFAULT = 361,
+     LESSTHANOREQUALTO = 362,
+     GREATERTHANOREQUALTO = 363,
+     EQUALTO = 364,
+     NOTEQUALTO = 365,
+     ARROW = 366,
+     QUESTIONMARK = 367,
+     TYPES = 368,
+     PARMS = 369,
+     NONID = 370,
+     DSTAR = 371,
+     DCNOT = 372,
+     TEMPLATE = 373,
+     OPERATOR = 374,
+     CONVERSIONOPERATOR = 375,
+     PARSETYPE = 376,
+     PARSEPARM = 377,
+     PARSEPARMS = 378,
+     DOXYGENSTRING = 379,
+     DOXYGENPOSTSTRING = 380,
+     CAST = 381,
+     LOR = 382,
+     LAND = 383,
+     OR = 384,
+     XOR = 385,
+     AND = 386,
+     RSHIFT = 387,
+     LSHIFT = 388,
+     MINUS = 389,
+     PLUS = 390,
+     MODULO = 391,
+     SLASH = 392,
+     STAR = 393,
+     LNOT = 394,
+     NOT = 395,
+     UMINUS = 396,
+     DCOLON = 397
+   };
+#endif
+/* Tokens.  */
+#define ID 258
+#define HBLOCK 259
+#define POUND 260
+#define STRING 261
+#define WSTRING 262
+#define INCLUDE 263
+#define IMPORT 264
+#define INSERT 265
+#define CHARCONST 266
+#define WCHARCONST 267
+#define NUM_INT 268
+#define NUM_FLOAT 269
+#define NUM_UNSIGNED 270
+#define NUM_LONG 271
+#define NUM_ULONG 272
+#define NUM_LONGLONG 273
+#define NUM_ULONGLONG 274
+#define NUM_BOOL 275
+#define TYPEDEF 276
+#define TYPE_INT 277
+#define TYPE_UNSIGNED 278
+#define TYPE_SHORT 279
+#define TYPE_LONG 280
+#define TYPE_FLOAT 281
+#define TYPE_DOUBLE 282
+#define TYPE_CHAR 283
+#define TYPE_WCHAR 284
+#define TYPE_VOID 285
+#define TYPE_SIGNED 286
+#define TYPE_BOOL 287
+#define TYPE_COMPLEX 288
+#define TYPE_TYPEDEF 289
+#define TYPE_RAW 290
+#define TYPE_NON_ISO_INT8 291
+#define TYPE_NON_ISO_INT16 292
+#define TYPE_NON_ISO_INT32 293
+#define TYPE_NON_ISO_INT64 294
+#define LPAREN 295
+#define RPAREN 296
+#define COMMA 297
+#define SEMI 298
+#define EXTERN 299
+#define INIT 300
+#define LBRACE 301
+#define RBRACE 302
+#define PERIOD 303
+#define CONST_QUAL 304
+#define VOLATILE 305
+#define REGISTER 306
+#define STRUCT 307
+#define UNION 308
+#define EQUAL 309
+#define SIZEOF 310
+#define MODULE 311
+#define LBRACKET 312
+#define RBRACKET 313
+#define BEGINFILE 314
+#define ENDOFFILE 315
+#define ILLEGAL 316
+#define CONSTANT 317
+#define NAME 318
+#define RENAME 319
+#define NAMEWARN 320
+#define EXTEND 321
+#define PRAGMA 322
+#define FEATURE 323
+#define VARARGS 324
+#define ENUM 325
+#define CLASS 326
+#define TYPENAME 327
+#define PRIVATE 328
+#define PUBLIC 329
+#define PROTECTED 330
+#define COLON 331
+#define STATIC 332
+#define VIRTUAL 333
+#define FRIEND 334
+#define THROW 335
+#define CATCH 336
+#define EXPLICIT 337
+#define STATIC_ASSERT 338
+#define CONSTEXPR 339
+#define THREAD_LOCAL 340
+#define DECLTYPE 341
+#define AUTO 342
+#define NOEXCEPT 343
+#define OVERRIDE 344
+#define FINAL 345
+#define USING 346
+#define NAMESPACE 347
+#define NATIVE 348
+#define INLINE 349
+#define TYPEMAP 350
+#define EXCEPT 351
+#define ECHO 352
+#define APPLY 353
+#define CLEAR 354
+#define SWIGTEMPLATE 355
+#define FRAGMENT 356
+#define WARN 357
+#define LESSTHAN 358
+#define GREATERTHAN 359
+#define DELETE_KW 360
+#define DEFAULT 361
+#define LESSTHANOREQUALTO 362
+#define GREATERTHANOREQUALTO 363
+#define EQUALTO 364
+#define NOTEQUALTO 365
+#define ARROW 366
+#define QUESTIONMARK 367
+#define TYPES 368
+#define PARMS 369
+#define NONID 370
+#define DSTAR 371
+#define DCNOT 372
+#define TEMPLATE 373
+#define OPERATOR 374
+#define CONVERSIONOPERATOR 375
+#define PARSETYPE 376
+#define PARSEPARM 377
+#define PARSEPARMS 378
+#define DOXYGENSTRING 379
+#define DOXYGENPOSTSTRING 380
+#define CAST 381
+#define LOR 382
+#define LAND 383
+#define OR 384
+#define XOR 385
+#define AND 386
+#define RSHIFT 387
+#define LSHIFT 388
+#define MINUS 389
+#define PLUS 390
+#define MODULO 391
+#define SLASH 392
+#define STAR 393
+#define LNOT 394
+#define NOT 395
+#define UMINUS 396
+#define DCOLON 397
+
+
+
+
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
+#line 1542 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig/Source/CParse/parser.y"
+{
+  const char  *id;
+  List  *bases;
+  struct Define {
+    String *val;
+    String *rawval;
+    int     type;
+    String *qualifier;
+    String *refqualifier;
+    String *bitfield;
+    Parm   *throws;
+    String *throwf;
+    String *nexcept;
+    String *final;
+  } dtype;
+  struct {
+    const char *type;
+    String *filename;
+    int   line;
+  } loc;
+  struct {
+    char      *id;
+    SwigType  *type;
+    String    *defarg;
+    ParmList  *parms;
+    short      have_parms;
+    ParmList  *throws;
+    String    *throwf;
+    String    *nexcept;
+    String    *final;
+  } decl;
+  Parm         *tparms;
+  struct {
+    String     *method;
+    Hash       *kwargs;
+  } tmap;
+  struct {
+    String     *type;
+    String     *us;
+  } ptype;
+  SwigType     *type;
+  String       *str;
+  Parm         *p;
+  ParmList     *pl;
+  int           intvalue;
+  Node         *node;
+}
+/* Line 1529 of yacc.c.  */
+#line 381 "/Users/anthony.liot/Desktop/github/TTT/third_party/external/swig/b2365f119/build/src/swig-build/Source/CParse/parser.h"
+   YYSTYPE;
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+extern YYSTYPE yylval;
+
diff --git a/Tools/cmake/swigconfig.h.cmake b/Tools/cmake/swigconfig.h.cmake
new file mode 100644
index 000000000..455fa0da9
--- /dev/null
+++ b/Tools/cmake/swigconfig.h.cmake
@@ -0,0 +1,92 @@
+/* Define to 1 if the system has the type `bool'. */
+#cmakedefine HAVE_BOOL 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#cmakedefine HAVE_INTTYPES_H 1
+
+/* Define to 1 if you have the `dl' library (-ldl). */
+#cmakedefine HAVE_LIBDL 1
+
+/* Define to 1 if you have the `dld' library (-ldld). */
+#cmakedefine HAVE_LIBDLD 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#cmakedefine HAVE_MEMORY_H 1
+
+/* Define if popen is available */
+#cmakedefine HAVE_POPEN 1
+
+/* Define if pcre is available */
+#cmakedefine HAVE_PCRE 1
+
+/* Define if rxspencer is available */
+#cmakedefine HAVE_RXSPENCER 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#cmakedefine HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#cmakedefine HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the <strings.h> header file. */
+#cmakedefine HAVE_STRINGS_H 1
+
+/* Define to 1 if you have the <string.h> header file. */
+#cmakedefine HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#cmakedefine HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#cmakedefine HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#cmakedefine HAVE_UNISTD_H 1
+
+/* Define to 1 if your C compiler doesn't accept -c and -o together. */
+#cmakedefine NO_MINUS_C_MINUS_O 1
+
+/* Define to 1 if you have the ANSI C header files. */
+#cmakedefine STDC_HEADERS 1
+
+/* Name of package */
+#define PACKAGE "swig"
+
+/* Define to the address where bug reports for this package should be sent. */
+#define PACKAGE_BUGREPORT "http://www.swig.org"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "swig"
+
+/* Define to the full name and version of this package. */
+#define PACKAGE_STRING "swig @SWIG_VERSION@"
+
+/* Define to the one symbol short name of this package. */
+#define PACKAGE_TARNAME "swig"
+
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "@SWIG_VERSION@"
+
+/* Compiler that built SWIG */
+#define SWIG_CXX "@SWIG_CXX@"
+
+/* Directory for SWIG system-independent libraries */
+#define SWIG_LIB "@SWIG_LIB@/Lib"
+
+/* Directory for SWIG system-independent libraries (Unix install on native
+   Windows) */
+#define SWIG_LIB_WIN_UNIX "@SWIG_LIB@/Lib"
+
+/* Platform that SWIG is built for */
+#define SWIG_PLATFORM "i686-pc-cygwin"
+
+/* Version number of package */
+#define VERSION "@SWIG_VERSION@"
+
+/* Default language */
+#define SWIG_LANG               "-tcl"
+
+/* Deal with Microsoft's attempt at deprecating C standard runtime functions */
+#if defined(_MSC_VER)
+# define _CRT_SECURE_NO_DEPRECATE
+#endif
-- 
2.30.1

